{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/auth-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface User {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    roleId: number;\n    roleCode: string;\n    roleName: string;\n    permissions: string[];\n    status: string;\n    mfaEnabled: boolean;\n}\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    status: string;\n    kycStatus: string;\n}\n\nexport interface TokenPayload {\n    sub: string;\n    type: 'user' | 'customer';\n    email: string;\n    role?: string;\n    permissions?: string[];\n    tokenVersion: number;\n    iat: number;\n    exp: number;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User | Customer;\n    token?: string;\n    refreshToken?: string;\n    error?: string;\n}\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\nconst BCRYPT_ROUNDS = 12;\nconst MAX_FAILED_ATTEMPTS = 5;\n\n// =============================================================================\n// Password Management\n// =============================================================================\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// =============================================================================\n// JWT Token Management\n// =============================================================================\n\nexport function generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n}\n\nexport function generateRefreshToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)({ ...payload, refresh: true }, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n}\n\nexport function verifyToken(token: string): TokenPayload | null {\n    try {\n        return jwt.verify(token, JWT_SECRET) as TokenPayload;\n    } catch {\n        return null;\n    }\n}\n\n// =============================================================================\n// User Authentication\n// =============================================================================\n\nexport async function authenticateUser(email: string, password: string): Promise<AuthResult> {\n    interface UserRow extends RowDataPacket {\n        id: number;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        role_id: number;\n        role_code: string;\n        role_name: string;\n        permissions: string;\n        status: string;\n    }\n\n    const userRow = await queryOne<UserRow>(\n        `SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,\n            u.role_id, r.code as role_code, r.name as role_name, r.permissions,\n            u.status\n     FROM users u\n     INNER JOIN roles r ON r.id = u.role_id\n     WHERE u.email = ?`,\n        [email]\n    );\n\n    if (!userRow) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    if (userRow.status !== 'ACTIVE') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, userRow.password_hash);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    // Update last login\n    await execute(\n        'UPDATE users SET last_login_at = NOW() WHERE id = ?',\n        [userRow.id]\n    );\n\n    // Parse permissions (MySQL may return JSON as already-parsed array)\n    const permissions = Array.isArray(userRow.permissions)\n        ? userRow.permissions as string[]\n        : JSON.parse(userRow.permissions || '[]') as string[];\n\n    const user: User = {\n        id: userRow.id,\n        email: userRow.email,\n        firstName: userRow.first_name,\n        lastName: userRow.last_name,\n        roleId: userRow.role_id,\n        roleCode: userRow.role_code,\n        roleName: userRow.role_name,\n        permissions,\n        status: userRow.status,\n        mfaEnabled: false, // Simplified - no MFA\n    };\n\n    // Generate tokens\n    const token = generateToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        permissions,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user, token, refreshToken };\n}\n\n// =============================================================================\n// Customer Authentication\n// =============================================================================\n\nexport async function authenticateCustomer(email: string, password: string): Promise<AuthResult> {\n    interface CustomerRow extends RowDataPacket {\n        id: number;\n        customer_number: string;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        status: string;\n        kyc_status: string;\n    }\n\n    const customerRow = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, password_hash, first_name, last_name,\n            status, kyc_status\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!customerRow) {\n        console.log(`[Auth] Customer not found: ${email}`);\n        return { success: false, error: 'Invalid email or password' };\n    }\n    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);\n\n    if (customerRow.status === 'SUSPENDED') {\n        return { success: false, error: 'Account is suspended. Please contact support.' };\n    }\n\n    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, customerRow.password_hash);\n    console.log(`[Auth] Password valid: ${passwordValid}`);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    const customer: Customer = {\n        id: customerRow.id,\n        customerNumber: customerRow.customer_number,\n        email: customerRow.email,\n        firstName: customerRow.first_name,\n        lastName: customerRow.last_name,\n        status: customerRow.status,\n        kycStatus: customerRow.kyc_status,\n    };\n\n    const token = generateToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user: customer, token, refreshToken };\n}\n\n// =============================================================================\n// Token Refresh\n// =============================================================================\n\nexport async function refreshAccessToken(refreshToken: string): Promise<AuthResult> {\n    const payload = verifyToken(refreshToken);\n\n    if (!payload) {\n        return { success: false, error: 'Invalid refresh token' };\n    }\n\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            role_code: string;\n            permissions: string;\n        }\n\n        const userRow = await queryOne<UserRow>(\n            `SELECT u.id, u.email, r.code as role_code, r.permissions\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return { success: false, error: 'User not found or inactive' };\n        }\n\n        const permissions = Array.isArray(userRow.permissions)\n            ? userRow.permissions as string[]\n            : JSON.parse(userRow.permissions || '[]') as string[];\n\n        const newToken = generateToken({\n            sub: userRow.id.toString(),\n            type: 'user',\n            email: userRow.email,\n            role: userRow.role_code,\n            permissions,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            email: string;\n        }\n\n        const customerRow = await queryOne<CustomerRow>(\n            `SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return { success: false, error: 'Customer not found or inactive' };\n        }\n\n        const newToken = generateToken({\n            sub: customerRow.id.toString(),\n            type: 'customer',\n            email: customerRow.email,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    return { success: false, error: 'Invalid token type' };\n}\n\n// =============================================================================\n// User Management\n// =============================================================================\n\nexport async function createUser(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    roleId: number,\n    createdBy?: number\n): Promise<{ success: boolean; userId?: number; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`,\n            [email, passwordHash, firstName, lastName, roleId, createdBy ?? null]\n        );\n\n        return { success: true, userId: result.insertId };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\nexport async function createCustomer(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    createdBy?: number\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)\n       VALUES (?, ?, ?, ?, ?, 'PENDING', ?)`,\n            [customerNumber, email, passwordHash, firstName, lastName, createdBy ?? null]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\n// =============================================================================\n// Authorization Helpers\n// =============================================================================\n\nexport function hasPermission(user: User, permission: string): boolean {\n    return user.permissions.includes(permission);\n}\n\nexport function hasAnyPermission(user: User, permissions: string[]): boolean {\n    return permissions.some((p) => user.permissions.includes(p));\n}\n\nexport function hasAllPermissions(user: User, permissions: string[]): boolean {\n    return permissions.every((p) => user.permissions.includes(p));\n}\n\nexport function isRole(user: User, role: string): boolean {\n    return user.roleCode === role;\n}\n\nexport function isAnyRole(user: User, roles: string[]): boolean {\n    return roles.includes(user.roleCode);\n}\n\n// =============================================================================\n// Logout / Global Sign Out\n// =============================================================================\n\nexport async function logout(userId: number, type: 'user' | 'customer'): Promise<void> {\n    const table = type === 'user' ? 'users' : 'customers';\n\n    // Increment token version to invalidate all existing tokens\n    await execute(\n        `UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`,\n        [userId]\n    );\n\n    // Also remove any active sessions\n    if (type === 'user') {\n        await execute('DELETE FROM user_sessions WHERE user_id = ?', [userId]);\n    }\n}\n\n// =============================================================================\n// Signup Token Management\n// =============================================================================\n\nimport crypto from 'crypto';\n\ninterface SignupTokenResult {\n    success: boolean;\n    token?: string;\n    error?: string;\n}\n\nexport async function generateSignupToken(\n    customerId: number,\n    accountId: number,\n    createdBy: number\n): Promise<SignupTokenResult> {\n    // 1. Strict Validation\n    // Verify Customer exists AND Account belongs to them AND they are eligible for signup\n    interface ValidationRow extends RowDataPacket {\n        customer_id: number;\n        status: string;\n        kyc_status: string;\n        onboarding_status: string;\n        account_customer_id: number;\n        password_hash: string;\n    }\n\n    const validation = await queryOne<ValidationRow>(\n        `SELECT c.id as customer_id, c.status, c.kyc_status, c.onboarding_status, c.password_hash,\n                a.customer_id as account_customer_id\n         FROM customers c\n         LEFT JOIN accounts a ON a.id = ?\n         WHERE c.id = ?`,\n        [accountId, customerId]\n    );\n\n    if (!validation) {\n        return { success: false, error: 'Customer not found' };\n    }\n\n    // Check Account Ownership\n    if (validation.account_customer_id !== validation.customer_id) {\n        return { success: false, error: 'Account does not belong to this customer' };\n    }\n\n    // Check Customer Status\n    if (validation.status !== 'PENDING' && validation.status !== 'ACTIVE') {\n        return { success: false, error: 'Customer status invalid for onboarding' };\n    }\n\n    // Check KYC Status (Must be VERIFIED or PENDING, usually VERIFIED is preferred but strict mode might allow PENDING if reviewing)\n    // Requirement said: VERIFIED or PENDING\n    if (validation.kyc_status !== 'VERIFIED' && validation.kyc_status !== 'PENDING') {\n        return { success: false, error: 'Customer KYC must be Verified or Pending' };\n    }\n\n    // Check Onboarding Status (Must be PENDING_SIGNUP)\n    if (validation.onboarding_status !== 'PENDING_SIGNUP') {\n        return { success: false, error: 'Customer has already signed up or is not in signup phase' };\n    }\n\n    // Check for existing password (redundant but safe)\n    if (validation.password_hash) {\n        return { success: false, error: 'Customer already has credentials' };\n    }\n\n    // 2. Generate random token\n    const token = crypto.randomBytes(32).toString('hex');\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    // 3. Set expiry (e.g., 48 hours)\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 48);\n\n    try {\n        await execute(\n            `INSERT INTO customer_signup_tokens (token_hash, customer_id, account_id, created_by, expires_at)\n             VALUES (?, ?, ?, ?, ?)`,\n            [tokenHash, customerId, accountId, createdBy, expiresAt]\n        );\n\n        return { success: true, token };\n    } catch (error) {\n        return { success: false, error: 'Failed to generate signup token' };\n    }\n}\n\nexport async function verifySignupToken(token: string): Promise<{ success: boolean; data?: any; error?: string }> {\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    const tokenRow = await queryOne<RowDataPacket & {\n        customer_id: number;\n        account_id: number;\n        expires_at: Date;\n        used_at: Date | null\n    }>(\n        `SELECT customer_id, account_id, expires_at, used_at \n         FROM customer_signup_tokens \n         WHERE token_hash = ?`,\n        [tokenHash]\n    );\n\n    if (!tokenRow) {\n        return { success: false, error: 'Invalid signup link' };\n    }\n\n    if (tokenRow.used_at) {\n        return { success: false, error: 'This link has already been used' };\n    }\n\n    if (new Date() > tokenRow.expires_at) {\n        return { success: false, error: 'Signup link has expired' };\n    }\n\n    return {\n        success: true,\n        data: {\n            customerId: tokenRow.customer_id,\n            accountId: tokenRow.account_id\n        }\n    };\n}\n\nexport async function completeSignup(\n    token: string,\n    password: string\n): Promise<{ success: boolean; error?: string }> {\n    const verifyResult = await verifySignupToken(token);\n\n    if (!verifyResult.success || !verifyResult.data) {\n        return { success: false, error: verifyResult.error };\n    }\n\n    const { customerId } = verifyResult.data;\n    const passwordHash = await hashPassword(password);\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    try {\n        // 1. Update customer password and status\n        await execute(\n            `UPDATE customers \n             SET password_hash = ?, \n                 onboarding_status = 'PENDING_APPROVAL',\n                 updated_at = NOW() \n             WHERE id = ?`,\n            [passwordHash, customerId]\n        );\n\n        // 2. Mark token as used\n        await execute(\n            `UPDATE customer_signup_tokens \n             SET used_at = NOW() \n             WHERE token_hash = ?`,\n            [tokenHash]\n        );\n\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: 'Failed to complete signup' };\n    }\n}\n\n// =============================================================================\n// Session Helper for Next.js App Router\n// =============================================================================\n\nimport { cookies, headers } from 'next/headers';\n\nexport async function getSession(): Promise<{ user?: User | Customer; role?: string } | null> {\n    try {\n        const cookieStore = await cookies();\n        const headerList = await headers();\n\n        let token = cookieStore.get('token')?.value;\n\n        if (!token) {\n            const authHeader = headerList.get('Authorization');\n            if (authHeader?.startsWith('Bearer ')) {\n                token = authHeader.substring(7);\n            }\n        }\n\n        if (!token) return null;\n\n        const payload = verifyToken(token);\n        if (!payload) return null;\n\n        if (payload.type === 'user') {\n            const userRow = await queryOne<RowDataPacket & User>(\n                `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status\n             FROM users u\n             JOIN roles r ON r.id = u.role_id\n             WHERE u.id = ?`,\n                [payload.sub]\n            );\n            if (!userRow) return null;\n\n            const permissions = Array.isArray(userRow.permissions)\n                ? userRow.permissions as string[]\n                : JSON.parse((userRow.permissions as any) || '[]') as string[];\n\n            return {\n                user: { ...userRow, firstName: userRow.first_name, lastName: userRow.last_name, roleId: userRow.role_id, roleCode: userRow.role_code, roleName: userRow.role_name, permissions, mfaEnabled: false },\n                role: userRow.role_code\n            };\n        }\n\n        if (payload.type === 'customer') {\n            const customerRow = await queryOne<RowDataPacket & Customer>(\n                `SELECT id, customer_number, email, first_name, last_name, status, kyc_status\n             FROM customers WHERE id = ?`,\n                [payload.sub]\n            );\n            if (!customerRow) return null;\n\n            return {\n                user: { ...customerRow, customerNumber: customerRow.customer_number, firstName: customerRow.first_name, lastName: customerRow.last_name, kycStatus: customerRow.kyc_status },\n                role: 'CUSTOMER'\n            };\n        }\n\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AA8aA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAEhF;AA+JA,gFAAgF;AAChF,wCAAwC;AACxC,gFAAgF;AAEhF;;;;AApiBA,gFAAgF;AAChF,gBAAgB;AAChB,gFAAgF;AAEhF,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AACrD,MAAM,yBAAyB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACrE,MAAM,gBAAgB;AACtB,MAAM,sBAAsB;AAMrB,eAAe,aAAa,QAAgB;IAC/C,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AACjC;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IAC/D,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AACpC;AAMO,SAAS,cAAc,OAA0C;IACpE,8DAA8D;IAC9D,OAAO,AAAC,2MAAG,CAAC,IAAI,CAAS,SAAS,YAAY;QAAE,WAAW;IAAe;AAC9E;AAEO,SAAS,qBAAqB,OAA0C;IAC3E,8DAA8D;IAC9D,OAAO,AAAC,2MAAG,CAAC,IAAI,CAAS;QAAE,GAAG,OAAO;QAAE,SAAS;IAAK,GAAG,YAAY;QAAE,WAAW;IAAuB;AAC5G;AAEO,SAAS,YAAY,KAAa;IACrC,IAAI;QACA,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC7B,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAMO,eAAe,iBAAiB,KAAa,EAAE,QAAgB;IAclE,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;;;sBAKa,CAAC,EACf;QAAC;KAAM;IAGX,IAAI,CAAC,SAAS;QACV,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,IAAI,QAAQ,MAAM,KAAK,UAAU;QAC7B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,kBAAkB;IAClB,MAAM,gBAAgB,MAAM,eAAe,UAAU,QAAQ,aAAa;IAE1E,IAAI,CAAC,eAAe;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,oBAAoB;IACpB,MAAM,IAAA,6HAAO,EACT,uDACA;QAAC,QAAQ,EAAE;KAAC;IAGhB,oEAAoE;IACpE,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,QAAQ,WAAW,IAAI;IAExC,MAAM,OAAa;QACf,IAAI,QAAQ,EAAE;QACd,OAAO,QAAQ,KAAK;QACpB,WAAW,QAAQ,UAAU;QAC7B,UAAU,QAAQ,SAAS;QAC3B,QAAQ,QAAQ,OAAO;QACvB,UAAU,QAAQ,SAAS;QAC3B,UAAU,QAAQ,SAAS;QAC3B;QACA,QAAQ,QAAQ,MAAM;QACtB,YAAY;IAChB;IAEA,kBAAkB;IAClB,MAAM,QAAQ,cAAc;QACxB,KAAK,QAAQ,EAAE,CAAC,QAAQ;QACxB,MAAM;QACN,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,SAAS;QACvB;QACA,cAAc;IAClB;IAEA,MAAM,eAAe,qBAAqB;QACtC,KAAK,QAAQ,EAAE,CAAC,QAAQ;QACxB,MAAM;QACN,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,SAAS;QACvB,cAAc;IAClB;IAEA,OAAO;QAAE,SAAS;QAAM;QAAM;QAAO;IAAa;AACtD;AAMO,eAAe,qBAAqB,KAAa,EAAE,QAAgB;IAYtE,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC;;;oBAGW,CAAC,EACb;QAAC;KAAM;IAGX,IAAI,CAAC,aAAa;QACd,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,OAAO;QACjD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IACA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,YAAY,EAAE,CAAC,UAAU,EAAE,YAAY,MAAM,EAAE;IAErF,IAAI,YAAY,MAAM,KAAK,aAAa;QACpC,OAAO;YAAE,SAAS;YAAO,OAAO;QAAgD;IACpF;IAEA,IAAI,YAAY,MAAM,KAAK,YAAY,YAAY,MAAM,KAAK,WAAW;QACrE,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,kBAAkB;IAClB,MAAM,gBAAgB,MAAM,eAAe,UAAU,YAAY,aAAa;IAC9E,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,eAAe;IAErD,IAAI,CAAC,eAAe;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,MAAM,WAAqB;QACvB,IAAI,YAAY,EAAE;QAClB,gBAAgB,YAAY,eAAe;QAC3C,OAAO,YAAY,KAAK;QACxB,WAAW,YAAY,UAAU;QACjC,UAAU,YAAY,SAAS;QAC/B,QAAQ,YAAY,MAAM;QAC1B,WAAW,YAAY,UAAU;IACrC;IAEA,MAAM,QAAQ,cAAc;QACxB,KAAK,YAAY,EAAE,CAAC,QAAQ;QAC5B,MAAM;QACN,OAAO,YAAY,KAAK;QACxB,cAAc;IAClB;IAEA,MAAM,eAAe,qBAAqB;QACtC,KAAK,YAAY,EAAE,CAAC,QAAQ;QAC5B,MAAM;QACN,OAAO,YAAY,KAAK;QACxB,cAAc;IAClB;IAEA,OAAO;QAAE,SAAS;QAAM,MAAM;QAAU;QAAO;IAAa;AAChE;AAMO,eAAe,mBAAmB,YAAoB;IACzD,MAAM,UAAU,YAAY;IAE5B,IAAI,CAAC,SAAS;QACV,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAQzB,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;6CAGgC,CAAC,EAClC;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,SAAS;YACV,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA6B;QACjE;QAEA,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,QAAQ,WAAW,IAAI;QAExC,MAAM,WAAW,cAAc;YAC3B,KAAK,QAAQ,EAAE,CAAC,QAAQ;YACxB,MAAM;YACN,OAAO,QAAQ,KAAK;YACpB,MAAM,QAAQ,SAAS;YACvB;YACA,cAAc;QAClB;QAEA,OAAO;YAAE,SAAS;YAAM,OAAO;QAAS;IAC5C;IAEA,IAAI,QAAQ,IAAI,KAAK,YAAY;QAM7B,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC,kEAAkE,CAAC,EACpE;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,aAAa;YACd,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiC;QACrE;QAEA,MAAM,WAAW,cAAc;YAC3B,KAAK,YAAY,EAAE,CAAC,QAAQ;YAC5B,MAAM;YACN,OAAO,YAAY,KAAK;YACxB,cAAc;QAClB;QAEA,OAAO;YAAE,SAAS;YAAM,OAAO;QAAS;IAC5C;IAEA,OAAO;QAAE,SAAS;QAAO,OAAO;IAAqB;AACzD;AAMO,eAAe,WAClB,KAAa,EACb,QAAgB,EAChB,SAAiB,EACjB,QAAgB,EAChB,MAAc,EACd,SAAkB;IAElB,MAAM,eAAe,MAAM,aAAa;IAExC,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,6HAAO,EACxB,CAAC;iDACoC,CAAC,EACtC;YAAC;YAAO;YAAc;YAAW;YAAU;YAAQ,aAAa;SAAK;QAGzE,OAAO;YAAE,SAAS;YAAM,QAAQ,OAAO,QAAQ;QAAC;IACpD,EAAE,OAAO,OAAO;QACZ,IAAI,AAAC,MAA4B,IAAI,KAAK,gBAAgB;YACtD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuB;QAC3D;QACA,MAAM;IACV;AACJ;AAEO,eAAe,eAClB,KAAa,EACb,QAAgB,EAChB,SAAiB,EACjB,QAAgB,EAChB,SAAkB;IAElB,MAAM,eAAe,MAAM,aAAa;IAExC,2BAA2B;IAC3B,MAAM,iBAAiB,CAAC,CAAC,EAAE,KAAK,GAAG,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,KAAK;IAE7D,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,6HAAO,EACxB,CAAC;2CAC8B,CAAC,EAChC;YAAC;YAAgB;YAAO;YAAc;YAAW;YAAU,aAAa;SAAK;QAGjF,OAAO;YAAE,SAAS;YAAM,YAAY,OAAO,QAAQ;YAAE;QAAe;IACxE,EAAE,OAAO,OAAO;QACZ,IAAI,AAAC,MAA4B,IAAI,KAAK,gBAAgB;YACtD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuB;QAC3D;QACA,MAAM;IACV;AACJ;AAMO,SAAS,cAAc,IAAU,EAAE,UAAkB;IACxD,OAAO,KAAK,WAAW,CAAC,QAAQ,CAAC;AACrC;AAEO,SAAS,iBAAiB,IAAU,EAAE,WAAqB;IAC9D,OAAO,YAAY,IAAI,CAAC,CAAC,IAAM,KAAK,WAAW,CAAC,QAAQ,CAAC;AAC7D;AAEO,SAAS,kBAAkB,IAAU,EAAE,WAAqB;IAC/D,OAAO,YAAY,KAAK,CAAC,CAAC,IAAM,KAAK,WAAW,CAAC,QAAQ,CAAC;AAC9D;AAEO,SAAS,OAAO,IAAU,EAAE,IAAY;IAC3C,OAAO,KAAK,QAAQ,KAAK;AAC7B;AAEO,SAAS,UAAU,IAAU,EAAE,KAAe;IACjD,OAAO,MAAM,QAAQ,CAAC,KAAK,QAAQ;AACvC;AAMO,eAAe,OAAO,MAAc,EAAE,IAAyB;IAClE,MAAM,QAAQ,SAAS,SAAS,UAAU;IAE1C,4DAA4D;IAC5D,MAAM,IAAA,6HAAO,EACT,CAAC,OAAO,EAAE,MAAM,mDAAmD,CAAC,EACpE;QAAC;KAAO;IAGZ,kCAAkC;IAClC,IAAI,SAAS,QAAQ;QACjB,MAAM,IAAA,6HAAO,EAAC,+CAA+C;YAAC;SAAO;IACzE;AACJ;;AAcO,eAAe,oBAClB,UAAkB,EAClB,SAAiB,EACjB,SAAiB;IAajB,MAAM,aAAa,MAAM,IAAA,8HAAQ,EAC7B,CAAC;;;;uBAIc,CAAC,EAChB;QAAC;QAAW;KAAW;IAG3B,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,SAAS;YAAO,OAAO;QAAqB;IACzD;IAEA,0BAA0B;IAC1B,IAAI,WAAW,mBAAmB,KAAK,WAAW,WAAW,EAAE;QAC3D,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2C;IAC/E;IAEA,wBAAwB;IACxB,IAAI,WAAW,MAAM,KAAK,aAAa,WAAW,MAAM,KAAK,UAAU;QACnE,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyC;IAC7E;IAEA,iIAAiI;IACjI,wCAAwC;IACxC,IAAI,WAAW,UAAU,KAAK,cAAc,WAAW,UAAU,KAAK,WAAW;QAC7E,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2C;IAC/E;IAEA,mDAAmD;IACnD,IAAI,WAAW,iBAAiB,KAAK,kBAAkB;QACnD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2D;IAC/F;IAEA,mDAAmD;IACnD,IAAI,WAAW,aAAa,EAAE;QAC1B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAmC;IACvE;IAEA,2BAA2B;IAC3B,MAAM,QAAQ,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;IAC9C,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,iCAAiC;IACjC,MAAM,YAAY,IAAI;IACtB,UAAU,QAAQ,CAAC,UAAU,QAAQ,KAAK;IAE1C,IAAI;QACA,MAAM,IAAA,6HAAO,EACT,CAAC;mCACsB,CAAC,EACxB;YAAC;YAAW;YAAY;YAAW;YAAW;SAAU;QAG5D,OAAO;YAAE,SAAS;YAAM;QAAM;IAClC,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkC;IACtE;AACJ;AAEO,eAAe,kBAAkB,KAAa;IACjD,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,MAAM,WAAW,MAAM,IAAA,8HAAQ,EAM3B,CAAC;;6BAEoB,CAAC,EACtB;QAAC;KAAU;IAGf,IAAI,CAAC,UAAU;QACX,OAAO;YAAE,SAAS;YAAO,OAAO;QAAsB;IAC1D;IAEA,IAAI,SAAS,OAAO,EAAE;QAClB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkC;IACtE;IAEA,IAAI,IAAI,SAAS,SAAS,UAAU,EAAE;QAClC,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0B;IAC9D;IAEA,OAAO;QACH,SAAS;QACT,MAAM;YACF,YAAY,SAAS,WAAW;YAChC,WAAW,SAAS,UAAU;QAClC;IACJ;AACJ;AAEO,eAAe,eAClB,KAAa,EACb,QAAgB;IAEhB,MAAM,eAAe,MAAM,kBAAkB;IAE7C,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,IAAI,EAAE;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO,aAAa,KAAK;QAAC;IACvD;IAEA,MAAM,EAAE,UAAU,EAAE,GAAG,aAAa,IAAI;IACxC,MAAM,eAAe,MAAM,aAAa;IACxC,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,IAAI;QACA,yCAAyC;QACzC,MAAM,IAAA,6HAAO,EACT,CAAC;;;;yBAIY,CAAC,EACd;YAAC;YAAc;SAAW;QAG9B,wBAAwB;QACxB,MAAM,IAAA,6HAAO,EACT,CAAC;;iCAEoB,CAAC,EACtB;YAAC;SAAU;QAGf,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;AACJ;;AAQO,eAAe;IAClB,IAAI;QACA,MAAM,cAAc,MAAM,IAAA,2PAAO;QACjC,MAAM,aAAa,MAAM,IAAA,2PAAO;QAEhC,IAAI,QAAQ,YAAY,GAAG,CAAC,UAAU;QAEtC,IAAI,CAAC,OAAO;YACR,MAAM,aAAa,WAAW,GAAG,CAAC;YAClC,IAAI,YAAY,WAAW,YAAY;gBACnC,QAAQ,WAAW,SAAS,CAAC;YACjC;QACJ;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,UAAU,YAAY;QAC5B,IAAI,CAAC,SAAS,OAAO;QAErB,IAAI,QAAQ,IAAI,KAAK,QAAQ;YACzB,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;2BAGU,CAAC,EACZ;gBAAC,QAAQ,GAAG;aAAC;YAEjB,IAAI,CAAC,SAAS,OAAO;YAErB,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,AAAC,QAAQ,WAAW,IAAY;YAEjD,OAAO;gBACH,MAAM;oBAAE,GAAG,OAAO;oBAAE,WAAW,QAAQ,UAAU;oBAAE,UAAU,QAAQ,SAAS;oBAAE,QAAQ,QAAQ,OAAO;oBAAE,UAAU,QAAQ,SAAS;oBAAE,UAAU,QAAQ,SAAS;oBAAE;oBAAa,YAAY;gBAAM;gBAClM,MAAM,QAAQ,SAAS;YAC3B;QACJ;QAEA,IAAI,QAAQ,IAAI,KAAK,YAAY;YAC7B,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC;wCACuB,CAAC,EACzB;gBAAC,QAAQ,GAAG;aAAC;YAEjB,IAAI,CAAC,aAAa,OAAO;YAEzB,OAAO;gBACH,MAAM;oBAAE,GAAG,WAAW;oBAAE,gBAAgB,YAAY,eAAe;oBAAE,WAAW,YAAY,UAAU;oBAAE,UAAU,YAAY,SAAS;oBAAE,WAAW,YAAY,UAAU;gBAAC;gBAC3K,MAAM;YACV;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,GAAG;QACR,OAAO;IACX;AACJ"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/analytics-service.ts"],"sourcesContent":["/**\n * Analytics Service\n * Feature 15: Financial Analytics, Management Reports & Materialized Aggregates\n * \n * Provides functions to query analytics tables and trigger aggregate generation.\n * Analytics data is derived from the ledger and must never be treated as source of truth.\n */\n\nimport { query, queryOne, execute } from '../db';\nimport { RowDataPacket, ResultSetHeader } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface DailyTotal {\n    id: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    date: string;\n    openingBalance: number;\n    closingBalance: number;\n    totalDebits: number;\n    totalCredits: number;\n    debitCount: number;\n    creditCount: number;\n}\n\nexport interface MonthlySummary {\n    id: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    year: number;\n    month: number;\n    openingBalance: number;\n    closingBalance: number;\n    totalDebits: number;\n    totalCredits: number;\n    debitCount: number;\n    creditCount: number;\n    avgDailyBalance: number;\n    interestEarned: number;\n    feesCharged: number;\n}\n\nexport interface DailyTransactionSummary {\n    date: string;\n    totalDeposits: number;\n    totalWithdrawals: number;\n    transactionCount: number;\n    volume: number;\n}\n\nexport interface TopAccount {\n    rank: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    category: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME';\n    metricValue: number;\n}\n\nexport interface SystemTotals {\n    totalAccounts: number;\n    totalActiveAccounts: number;\n    totalVolume: number;\n    totalDeposits: number;\n    totalWithdrawals: number;\n    totalTransactions: number;\n    avgAccountBalance: number;\n}\n\nexport interface AggregateGenerationResult {\n    accountsProcessed: number;\n    status: string;\n    message: string;\n}\n\nexport interface RebuildResult {\n    dailyRows: number;\n    monthlyRows: number;\n    status: string;\n    message: string;\n}\n\n// =============================================================================\n// Row Types\n// =============================================================================\n\ninterface DailyTotalRow extends RowDataPacket {\n    id: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    date: Date;\n    opening_balance: string;\n    closing_balance: string;\n    total_debits: string;\n    total_credits: string;\n    debit_count: number;\n    credit_count: number;\n}\n\ninterface MonthlySummaryRow extends RowDataPacket {\n    id: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    year: number;\n    month: number;\n    opening_balance: string;\n    closing_balance: string;\n    total_debits: string;\n    total_credits: string;\n    debit_count: number;\n    credit_count: number;\n    avg_daily_balance: string;\n    interest_earned: string;\n    fees_charged: string;\n}\n\ninterface TopAccountRow extends RowDataPacket {\n    rank_position: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    category: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME';\n    metric_value: string;\n}\n\ninterface SystemTotalsRow extends RowDataPacket {\n    total_accounts: number;\n    total_active_accounts: number;\n    total_volume: string;\n    total_deposits: string;\n    total_withdrawals: string;\n    total_transactions: number;\n    avg_account_balance: string;\n}\n\n// =============================================================================\n// Daily Totals\n// =============================================================================\n\n/**\n * Get daily totals for a specific date\n */\nexport async function getDailyTotals(\n    date: string,\n    options: { accountId?: number; page?: number; size?: number } = {}\n): Promise<{ totals: DailyTotal[]; total: number }> {\n    const { accountId, page = 1, size = 50 } = options;\n    const offset = (page - 1) * size;\n\n    let whereClause = 'WHERE le.entry_date = ?';\n    const params: (string | number)[] = [date];\n\n    if (accountId) {\n        whereClause += ' AND le.account_id = ?';\n        params.push(accountId);\n    }\n\n    // Get count of accounts with activity\n    const countResult = await queryOne<{ count: number } & RowDataPacket>(\n        `SELECT COUNT(DISTINCT le.account_id) as count \n         FROM ledger_entries le \n         ${whereClause}`,\n        params\n    );\n\n    // Get ledger-based daily totals per account\n    // This is computationally more expensive but adheres to the non-negotiable rule\n    const rows = await query<RowDataPacket[]>(\n        `SELECT \n            le.account_id, \n            a.account_number,\n            CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n            SUM(CASE WHEN le.entry_type = 'CREDIT' THEN le.amount ELSE 0 END) as total_credits,\n            SUM(CASE WHEN le.entry_type = 'DEBIT' THEN le.amount ELSE 0 END) as total_debits,\n            COUNT(CASE WHEN le.entry_type = 'CREDIT' THEN 1 END) as credit_count,\n            COUNT(CASE WHEN le.entry_type = 'DEBIT' THEN 1 END) as debit_count,\n            -- Opening balance: balance_after - amount of the first entry of the day\n            (SELECT l1.balance_after - l1.amount \n             FROM ledger_entries l1 \n             WHERE l1.account_id = le.account_id AND l1.entry_date = ? \n             ORDER BY l1.id ASC LIMIT 1) as opening_balance,\n            -- Closing balance: balance_after of the last entry of the day\n            (SELECT l2.balance_after \n             FROM ledger_entries l2 \n             WHERE l2.account_id = le.account_id AND l2.entry_date = ? \n             ORDER BY l2.id DESC LIMIT 1) as closing_balance\n         FROM ledger_entries le\n         INNER JOIN accounts a ON a.id = le.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         GROUP BY le.account_id, a.account_number, customer_name\n         ORDER BY closing_balance DESC\n         LIMIT ? OFFSET ?`,\n        [date, date, ...params, size, offset]\n    );\n\n    return {\n        totals: rows.map(row => ({\n            id: row.account_id, // Use account_id as unique ID for the row\n            accountId: row.account_id,\n            accountNumber: row.account_number,\n            customerName: row.customer_name,\n            date: date,\n            openingBalance: parseFloat(row.opening_balance || '0'),\n            closingBalance: parseFloat(row.closing_balance || '0'),\n            totalDebits: parseFloat(row.total_debits || '0'),\n            totalCredits: parseFloat(row.total_credits || '0'),\n            debitCount: row.debit_count,\n            creditCount: row.credit_count,\n        })),\n        total: countResult?.count || 0,\n    };\n}\n\n/**\n * Get system-wide totals for a specific date\n */\nexport async function getDailySystemTotals(date: string): Promise<SystemTotals> {\n    const row = await queryOne<RowDataPacket>(\n        `SELECT \n            COUNT(DISTINCT le.account_id) as total_accounts,\n            COALESCE(SUM(le.amount), 0) as total_volume,\n            COALESCE(SUM(CASE WHEN le.entry_type = 'CREDIT' THEN le.amount ELSE 0 END), 0) as total_deposits,\n            COALESCE(SUM(CASE WHEN le.entry_type = 'DEBIT' THEN le.amount ELSE 0 END), 0) as total_withdrawals,\n            COUNT(DISTINCT le.transaction_id) as total_transactions,\n            -- For lack of precomputed data, we average the closing balances of all accounts with activity today\n            COALESCE((\n                SELECT AVG(closing_balance) FROM (\n                    SELECT MAX(l2.balance_after) as closing_balance\n                    FROM ledger_entries l2\n                    WHERE l2.entry_date = ?\n                    GROUP BY l2.account_id\n                ) as daily_averages\n            ), 0) as avg_account_balance\n         FROM ledger_entries le\n         WHERE le.entry_date = ?`,\n        [date, date]\n    );\n\n    return {\n        totalAccounts: row?.total_accounts || 0,\n        totalActiveAccounts: row?.total_accounts || 0, // Simplified since we only know active ones today\n        totalVolume: parseFloat(row?.total_volume || '0'),\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        totalTransactions: row?.total_transactions || 0,\n        avgAccountBalance: parseFloat(row?.avg_account_balance || '0'),\n    };\n}\n\n/**\n * Get daily transaction summary directly from ledger_entries\n * ADHERES TO NON-NEGOTIABLE RULE: Compute on-the-fly from ledger_entries\n */\nexport async function getDailyTransactionSummary(date: string): Promise<DailyTransactionSummary> {\n    const row = await queryOne<RowDataPacket>(\n        `SELECT \n            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_deposits,\n            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_withdrawals,\n            COUNT(DISTINCT transaction_id) as transaction_count,\n            COALESCE(SUM(amount), 0) as volume\n         FROM ledger_entries\n         WHERE entry_date = ?`,\n        [date]\n    );\n\n    const result = {\n        date,\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        transactionCount: row?.transaction_count || 0,\n        volume: parseFloat(row?.volume || '0'),\n    };\n\n    return result;\n}\n\n// =============================================================================\n// Monthly Summaries\n// =============================================================================\n\n/**\n * Get monthly summaries for a specific month\n */\nexport async function getMonthlySummaries(\n    year: number,\n    month: number,\n    options: { accountId?: number; page?: number; size?: number } = {}\n): Promise<{ summaries: MonthlySummary[]; total: number }> {\n    const { accountId, page = 1, size = 50 } = options;\n    const offset = (page - 1) * size;\n\n    let whereClause = 'WHERE mas.year = ? AND mas.month = ?';\n    const params: (number)[] = [year, month];\n\n    if (accountId) {\n        whereClause += ' AND mas.account_id = ?';\n        params.push(accountId);\n    }\n\n    // Get count\n    const countResult = await queryOne<{ count: number } & RowDataPacket>(\n        `SELECT COUNT(*) as count \n         FROM monthly_account_summaries mas \n         ${whereClause}`,\n        params\n    );\n\n    // Get data\n    const rows = await query<MonthlySummaryRow[]>(\n        `SELECT mas.id, mas.account_id, a.account_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                mas.year, mas.month, mas.opening_balance, mas.closing_balance,\n                mas.total_debits, mas.total_credits,\n                mas.debit_count, mas.credit_count,\n                mas.avg_daily_balance, mas.interest_earned, mas.fees_charged\n         FROM monthly_account_summaries mas\n         INNER JOIN accounts a ON a.id = mas.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         ORDER BY mas.closing_balance DESC\n         LIMIT ? OFFSET ?`,\n        [...params, size, offset]\n    );\n\n    return {\n        summaries: rows.map(row => ({\n            id: row.id,\n            accountId: row.account_id,\n            accountNumber: row.account_number,\n            customerName: row.customer_name,\n            year: row.year,\n            month: row.month,\n            openingBalance: parseFloat(row.opening_balance),\n            closingBalance: parseFloat(row.closing_balance),\n            totalDebits: parseFloat(row.total_debits),\n            totalCredits: parseFloat(row.total_credits),\n            debitCount: row.debit_count,\n            creditCount: row.credit_count,\n            avgDailyBalance: parseFloat(row.avg_daily_balance),\n            interestEarned: parseFloat(row.interest_earned),\n            feesCharged: parseFloat(row.fees_charged),\n        })),\n        total: countResult?.count || 0,\n    };\n}\n\n/**\n * Get system-wide totals for a specific month\n */\nexport async function getMonthlySystemTotals(year: number, month: number): Promise<SystemTotals> {\n    const row = await queryOne<SystemTotalsRow>(\n        `SELECT \n            COUNT(DISTINCT mas.account_id) as total_accounts,\n            COUNT(DISTINCT CASE WHEN a.status = 'ACTIVE' THEN a.id END) as total_active_accounts,\n            COALESCE(SUM(mas.total_debits + mas.total_credits), 0) as total_volume,\n            COALESCE(SUM(mas.total_credits), 0) as total_deposits,\n            COALESCE(SUM(mas.total_debits), 0) as total_withdrawals,\n            COALESCE(SUM(mas.debit_count + mas.credit_count), 0) as total_transactions,\n            COALESCE(AVG(mas.avg_daily_balance), 0) as avg_account_balance\n         FROM monthly_account_summaries mas\n         INNER JOIN accounts a ON a.id = mas.account_id\n         WHERE mas.year = ? AND mas.month = ?`,\n        [year, month]\n    );\n\n    return {\n        totalAccounts: row?.total_accounts || 0,\n        totalActiveAccounts: row?.total_active_accounts || 0,\n        totalVolume: parseFloat(row?.total_volume || '0'),\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        totalTransactions: row?.total_transactions || 0,\n        avgAccountBalance: parseFloat(row?.avg_account_balance || '0'),\n    };\n}\n\n// =============================================================================\n// Top Accounts\n// =============================================================================\n\n/**\n * Get top accounts for a specific month and category\n */\nexport async function getTopAccounts(\n    year: number,\n    month: number,\n    category?: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME'\n): Promise<TopAccount[]> {\n    let whereClause = 'WHERE tam.year = ? AND tam.month = ?';\n    const params: (number | string)[] = [year, month];\n\n    if (category) {\n        whereClause += ' AND tam.category = ?';\n        params.push(category);\n    }\n\n    const rows = await query<TopAccountRow[]>(\n        `SELECT tam.rank_position, tam.account_id, a.account_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                tam.category, tam.metric_value\n         FROM top_accounts_monthly tam\n         INNER JOIN accounts a ON a.id = tam.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         ORDER BY tam.category, tam.rank_position`,\n        params\n    );\n\n    return rows.map(row => ({\n        rank: row.rank_position,\n        accountId: row.account_id,\n        accountNumber: row.account_number,\n        customerName: row.customer_name,\n        category: row.category,\n        metricValue: parseFloat(row.metric_value),\n    }));\n}\n\n// =============================================================================\n// Aggregate Generation & Rebuild\n// =============================================================================\n\n/**\n * Generate monthly aggregates for a specific month\n * Calls sp_generate_monthly_aggregates stored procedure\n */\nexport async function generateMonthlyAggregates(\n    year: number,\n    month: number,\n    userId: number\n): Promise<AggregateGenerationResult> {\n    // Call the stored procedure\n    await execute(\n        `CALL sp_generate_monthly_aggregates(?, ?, ?, @accounts_processed, @status, @message)`,\n        [year, month, userId]\n    );\n\n    // Get output parameters\n    const result = await queryOne<{\n        accounts_processed: number;\n        status: string;\n        message: string;\n    } & RowDataPacket>(\n        `SELECT @accounts_processed as accounts_processed, @status as status, @message as message`\n    );\n\n    return {\n        accountsProcessed: result?.accounts_processed || 0,\n        status: result?.status || 'UNKNOWN',\n        message: result?.message || '',\n    };\n}\n\n/**\n * Rebuild all analytics tables from ledger\n * Admin-only operation - can be long-running\n */\nexport async function rebuildAnalytics(userId: number): Promise<RebuildResult> {\n    // Call the stored procedure\n    await execute(\n        `CALL sp_rebuild_analytics(?, @daily_rows, @monthly_rows, @status, @message)`,\n        [userId]\n    );\n\n    // Get output parameters\n    const result = await queryOne<{\n        daily_rows: number;\n        monthly_rows: number;\n        status: string;\n        message: string;\n    } & RowDataPacket>(\n        `SELECT @daily_rows as daily_rows, @monthly_rows as monthly_rows, @status as status, @message as message`\n    );\n\n    return {\n        dailyRows: result?.daily_rows || 0,\n        monthlyRows: result?.monthly_rows || 0,\n        status: result?.status || 'UNKNOWN',\n        message: result?.message || '',\n    };\n}\n\n// =============================================================================\n// Available Periods\n// =============================================================================\n\n/**\n * Get list of months with available analytics data\n */\nexport async function getAvailablePeriods(): Promise<{ year: number; month: number }[]> {\n    const rows = await query<({ year: number; month: number } & RowDataPacket)[]>(\n        `SELECT DISTINCT YEAR(entry_date) as year, MONTH(entry_date) as month \n         FROM ledger_entries \n         ORDER BY year DESC, month DESC \n         LIMIT 24`\n    );\n\n    return rows.map(row => ({\n        year: row.year,\n        month: row.month,\n    }));\n}\n\n/**\n * Get list of dates with available daily analytics data\n */\nexport async function getAvailableDates(limit: number = 30): Promise<string[]> {\n    const rows = await query<({ date: Date } & RowDataPacket)[]>(\n        `SELECT DISTINCT entry_date as date \n         FROM ledger_entries \n         ORDER BY entry_date DESC \n         LIMIT ?`,\n        [limit]\n    );\n\n    return rows.map(row => row.date.toISOString().split('T')[0]);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1178, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/app/api/v1/reports/daily-totals/route.ts"],"sourcesContent":["/**\n * GET /api/v1/reports/daily-totals\n * \n * Returns daily aggregate totals for accounts.\n * Query params:\n *   - date: YYYY-MM-DD format (required)\n *   - accountId: (optional) filter to specific account\n *   - page: (optional) pagination page, default 1\n *   - size: (optional) page size, default 50\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getSession } from '@/lib/services/auth-service';\nimport { getDailyTotals, getDailySystemTotals, getDailyTransactionSummary } from '@/lib/services/analytics-service';\n\nexport async function GET(request: NextRequest) {\n    let date: string | null = null;\n    try {\n        // Verify authentication - bankers and admins only\n        const session = await getSession();\n        if (!session) {\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n        }\n\n        if (!['ADMIN', 'BANKER'].includes(session.role || '')) {\n            return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n        }\n\n        const { searchParams } = new URL(request.url);\n        date = searchParams.get('date');\n        const accountId = searchParams.get('accountId');\n        const page = parseInt(searchParams.get('page') || '1');\n        const size = parseInt(searchParams.get('size') || '50');\n\n        if (!date) {\n            return NextResponse.json(\n                { error: 'Date parameter is required (YYYY-MM-DD format)' },\n                { status: 400 }\n            );\n        }\n\n        // Validate date format\n        if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n            return NextResponse.json(\n                { error: 'Invalid date format. Use YYYY-MM-DD' },\n                { status: 400 }\n            );\n        }\n\n        // Get daily totals (still from precomputed if needed for detail, but summary MUST be from ledger)\n        const { totals, total } = await getDailyTotals(date, {\n            accountId: accountId ? parseInt(accountId) : undefined,\n            page,\n            size,\n        });\n\n        // Get system totals (precomputed)\n        const systemTotals = await getDailySystemTotals(date);\n\n        // Get LIVE summary from ledger (as required)\n        const liveSummary = await getDailyTransactionSummary(date);\n\n        return NextResponse.json({\n            success: true,\n            data: totals,\n            summary: systemTotals,\n            liveSummary: liveSummary,\n            meta: {\n                date,\n                serverTime: new Date().toISOString(),\n                currentPage: page,\n                itemsPerPage: size,\n                totalItems: total,\n                totalPages: Math.ceil(total / size),\n            },\n        });\n    } catch (error: any) {\n        console.error('Daily totals error:', error);\n        return NextResponse.json(\n            { error: 'Failed to fetch daily totals' },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;CASC,GAED;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC1C,IAAI,OAAsB;IAC1B,IAAI;QACA,kDAAkD;QAClD,MAAM,UAAU,MAAM,IAAA,yJAAU;QAChC,IAAI,CAAC,SAAS;YACV,OAAO,+PAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,IAAI,CAAC;YAAC;YAAS;SAAS,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,KAAK;YACnD,OAAO,+PAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAY,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,OAAO,aAAa,GAAG,CAAC;QACxB,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAClD,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAElD,IAAI,CAAC,MAAM;YACP,OAAO,+PAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAiD,GAC1D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,uBAAuB;QACvB,IAAI,CAAC,sBAAsB,IAAI,CAAC,OAAO;YACnC,OAAO,+PAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAsC,GAC/C;gBAAE,QAAQ;YAAI;QAEtB;QAEA,kGAAkG;QAClG,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,IAAA,kKAAc,EAAC,MAAM;YACjD,WAAW,YAAY,SAAS,aAAa;YAC7C;YACA;QACJ;QAEA,kCAAkC;QAClC,MAAM,eAAe,MAAM,IAAA,wKAAoB,EAAC;QAEhD,6CAA6C;QAC7C,MAAM,cAAc,MAAM,IAAA,8KAA0B,EAAC;QAErD,OAAO,+PAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,MAAM;YACN,SAAS;YACT,aAAa;YACb,MAAM;gBACF;gBACA,YAAY,IAAI,OAAO,WAAW;gBAClC,aAAa;gBACb,cAAc;gBACd,YAAY;gBACZ,YAAY,KAAK,IAAI,CAAC,QAAQ;YAClC;QACJ;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,+PAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}