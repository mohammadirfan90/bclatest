{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/auth-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface User {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    roleId: number;\n    roleCode: string;\n    roleName: string;\n    permissions: string[];\n    status: string;\n    mfaEnabled: boolean;\n}\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    status: string;\n    kycStatus: string;\n}\n\nexport interface TokenPayload {\n    sub: string;\n    type: 'user' | 'customer';\n    email: string;\n    role?: string;\n    permissions?: string[];\n    tokenVersion: number;\n    iat: number;\n    exp: number;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User | Customer;\n    token?: string;\n    refreshToken?: string;\n    error?: string;\n}\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\nconst BCRYPT_ROUNDS = 12;\nconst MAX_FAILED_ATTEMPTS = 5;\n\n// =============================================================================\n// Password Management\n// =============================================================================\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// =============================================================================\n// JWT Token Management\n// =============================================================================\n\nexport function generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n}\n\nexport function generateRefreshToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)({ ...payload, refresh: true }, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n}\n\nexport function verifyToken(token: string): TokenPayload | null {\n    try {\n        return jwt.verify(token, JWT_SECRET) as TokenPayload;\n    } catch {\n        return null;\n    }\n}\n\n// =============================================================================\n// User Authentication\n// =============================================================================\n\nexport async function authenticateUser(email: string, password: string): Promise<AuthResult> {\n    interface UserRow extends RowDataPacket {\n        id: number;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        role_id: number;\n        role_code: string;\n        role_name: string;\n        permissions: string;\n        status: string;\n    }\n\n    const userRow = await queryOne<UserRow>(\n        `SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,\n            u.role_id, r.code as role_code, r.name as role_name, r.permissions,\n            u.status\n     FROM users u\n     INNER JOIN roles r ON r.id = u.role_id\n     WHERE u.email = ?`,\n        [email]\n    );\n\n    if (!userRow) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    if (userRow.status !== 'ACTIVE') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, userRow.password_hash);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    // Update last login\n    await execute(\n        'UPDATE users SET last_login_at = NOW() WHERE id = ?',\n        [userRow.id]\n    );\n\n    // Parse permissions (MySQL may return JSON as already-parsed array)\n    const permissions = Array.isArray(userRow.permissions)\n        ? userRow.permissions as string[]\n        : JSON.parse(userRow.permissions || '[]') as string[];\n\n    const user: User = {\n        id: userRow.id,\n        email: userRow.email,\n        firstName: userRow.first_name,\n        lastName: userRow.last_name,\n        roleId: userRow.role_id,\n        roleCode: userRow.role_code,\n        roleName: userRow.role_name,\n        permissions,\n        status: userRow.status,\n        mfaEnabled: false, // Simplified - no MFA\n    };\n\n    // Generate tokens\n    const token = generateToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        permissions,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user, token, refreshToken };\n}\n\n// =============================================================================\n// Customer Authentication\n// =============================================================================\n\nexport async function authenticateCustomer(email: string, password: string): Promise<AuthResult> {\n    interface CustomerRow extends RowDataPacket {\n        id: number;\n        customer_number: string;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        status: string;\n        kyc_status: string;\n    }\n\n    const customerRow = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, password_hash, first_name, last_name,\n            status, kyc_status\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!customerRow) {\n        console.log(`[Auth] Customer not found: ${email}`);\n        return { success: false, error: 'Invalid email or password' };\n    }\n    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);\n\n    if (customerRow.status === 'SUSPENDED') {\n        return { success: false, error: 'Account is suspended. Please contact support.' };\n    }\n\n    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, customerRow.password_hash);\n    console.log(`[Auth] Password valid: ${passwordValid}`);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    const customer: Customer = {\n        id: customerRow.id,\n        customerNumber: customerRow.customer_number,\n        email: customerRow.email,\n        firstName: customerRow.first_name,\n        lastName: customerRow.last_name,\n        status: customerRow.status,\n        kycStatus: customerRow.kyc_status,\n    };\n\n    const token = generateToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user: customer, token, refreshToken };\n}\n\n// =============================================================================\n// Token Refresh\n// =============================================================================\n\nexport async function refreshAccessToken(refreshToken: string): Promise<AuthResult> {\n    const payload = verifyToken(refreshToken);\n\n    if (!payload) {\n        return { success: false, error: 'Invalid refresh token' };\n    }\n\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            role_code: string;\n            permissions: string;\n        }\n\n        const userRow = await queryOne<UserRow>(\n            `SELECT u.id, u.email, r.code as role_code, r.permissions\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return { success: false, error: 'User not found or inactive' };\n        }\n\n        const permissions = Array.isArray(userRow.permissions)\n            ? userRow.permissions as string[]\n            : JSON.parse(userRow.permissions || '[]') as string[];\n\n        const newToken = generateToken({\n            sub: userRow.id.toString(),\n            type: 'user',\n            email: userRow.email,\n            role: userRow.role_code,\n            permissions,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            email: string;\n        }\n\n        const customerRow = await queryOne<CustomerRow>(\n            `SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return { success: false, error: 'Customer not found or inactive' };\n        }\n\n        const newToken = generateToken({\n            sub: customerRow.id.toString(),\n            type: 'customer',\n            email: customerRow.email,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    return { success: false, error: 'Invalid token type' };\n}\n\n// =============================================================================\n// User Management\n// =============================================================================\n\nexport async function createUser(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    roleId: number,\n    createdBy?: number\n): Promise<{ success: boolean; userId?: number; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`,\n            [email, passwordHash, firstName, lastName, roleId, createdBy ?? null]\n        );\n\n        return { success: true, userId: result.insertId };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\nexport async function createCustomer(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    createdBy?: number\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?)`,\n            [customerNumber, email, passwordHash, firstName, lastName, createdBy ?? null]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\n// =============================================================================\n// Authorization Helpers\n// =============================================================================\n\nexport function hasPermission(user: User, permission: string): boolean {\n    return user.permissions.includes(permission);\n}\n\nexport function hasAnyPermission(user: User, permissions: string[]): boolean {\n    return permissions.some((p) => user.permissions.includes(p));\n}\n\nexport function hasAllPermissions(user: User, permissions: string[]): boolean {\n    return permissions.every((p) => user.permissions.includes(p));\n}\n\nexport function isRole(user: User, role: string): boolean {\n    return user.roleCode === role;\n}\n\nexport function isAnyRole(user: User, roles: string[]): boolean {\n    return roles.includes(user.roleCode);\n}\n\n// =============================================================================\n// Logout / Global Sign Out\n// =============================================================================\n\nexport async function logout(userId: number, type: 'user' | 'customer'): Promise<void> {\n    const table = type === 'user' ? 'users' : 'customers';\n    // Increment token version to invalidate all existing tokens\n    await execute(\n        `UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`,\n        [userId]\n    );\n\n    // Also remove any active sessions\n    if (type === 'user') {\n        await execute('DELETE FROM user_sessions WHERE user_id = ?', [userId]);\n    }\n}\n\n// =============================================================================\n// Session Helper for Next.js App Router\n// =============================================================================\n\nimport { cookies, headers } from 'next/headers';\n\nexport async function getSession(): Promise<{ user?: User | Customer; role?: string } | null> {\n    try {\n        const cookieStore = await cookies();\n        const headerList = await headers();\n\n        let token = cookieStore.get('token')?.value;\n\n        if (!token) {\n            const authHeader = headerList.get('Authorization');\n            if (authHeader?.startsWith('Bearer ')) {\n                token = authHeader.substring(7);\n            }\n        }\n\n        if (!token) return null;\n\n        const payload = verifyToken(token);\n        if (!payload) return null;\n\n        if (payload.type === 'user') {\n            const userRow = await queryOne<RowDataPacket & User>(\n                `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status\n             FROM users u\n             JOIN roles r ON r.id = u.role_id\n             WHERE u.id = ?`,\n                [payload.sub]\n            );\n            if (!userRow) return null;\n\n            const permissions = Array.isArray(userRow.permissions)\n                ? userRow.permissions as string[]\n                : JSON.parse((userRow.permissions as any) || '[]') as string[];\n\n            return {\n                user: { ...userRow, firstName: userRow.first_name, lastName: userRow.last_name, roleId: userRow.role_id, roleCode: userRow.role_code, roleName: userRow.role_name, permissions, mfaEnabled: false },\n                role: userRow.role_code\n            };\n        }\n\n        if (payload.type === 'customer') {\n            const customerRow = await queryOne<RowDataPacket & Customer>(\n                `SELECT id, customer_number, email, first_name, last_name, status, kyc_status\n             FROM customers WHERE id = ?`,\n                [payload.sub]\n            );\n            if (!customerRow) return null;\n\n            return {\n                user: { ...customerRow, customerNumber: customerRow.customer_number, firstName: customerRow.first_name, lastName: customerRow.last_name, kycStatus: customerRow.kyc_status },\n                role: 'CUSTOMER'\n            };\n        }\n\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/api-utils.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { verifyToken, TokenPayload, User } from '@/lib/services/auth-service';\nimport { query } from '@/lib/db';\nimport { RowDataPacket } from 'mysql2/promise';\nimport { ZodSchema, ZodError } from 'zod';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface AuthenticatedRequest extends NextRequest {\n    user?: User;\n    customer?: {\n        id: number;\n        customerNumber: string;\n        email: string;\n    };\n    tokenPayload?: TokenPayload;\n}\n\nexport interface ApiResponse<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: string;\n    errors?: Array<{ field: string; message: string }>;\n    meta?: {\n        page?: number;\n        limit?: number;\n        total?: number;\n        totalPages?: number;\n    };\n}\n\n// =============================================================================\n// Response Helpers\n// =============================================================================\n\nexport function successResponse<T>(data: T, meta?: ApiResponse['meta']): NextResponse {\n    return NextResponse.json({ success: true, data, meta }, { status: 200 });\n}\n\nexport function createdResponse<T>(data: T): NextResponse {\n    return NextResponse.json({ success: true, data }, { status: 201 });\n}\n\nexport function errorResponse(error: string, status: number = 400): NextResponse {\n    return NextResponse.json({ success: false, error }, { status });\n}\n\nexport function validationErrorResponse(errors: Array<{ field: string; message: string }>): NextResponse {\n    return NextResponse.json({ success: false, error: 'Validation failed', errors }, { status: 400 });\n}\n\nexport function unauthorizedResponse(error: string = 'Unauthorized'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 401 });\n}\n\nexport function forbiddenResponse(error: string = 'Forbidden'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 403 });\n}\n\nexport function notFoundResponse(error: string = 'Not found'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 404 });\n}\n\nexport function serverErrorResponse(error: string = 'Internal server error'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 500 });\n}\n\n// =============================================================================\n// Authentication Middleware\n// =============================================================================\n\nexport async function withAuth(\n    request: NextRequest,\n    handler: (req: AuthenticatedRequest) => Promise<NextResponse>,\n    options: {\n        requiredType?: 'user' | 'customer' | 'any';\n        requiredRoles?: string[];\n        requiredPermissions?: string[];\n        hideFailure?: boolean; // If true, returns 404 instead of 401/403 to hide existence\n    } = {}\n): Promise<NextResponse> {\n    const { requiredType = 'any', requiredRoles, requiredPermissions, hideFailure = false } = options;\n\n    // Helper to return 404 if hideFailure is on, otherwise the actual error\n    const getErrorResponse = (actualResponse: NextResponse) => {\n        return hideFailure ? notFoundResponse() : actualResponse;\n    };\n\n    // Get token from header\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return getErrorResponse(unauthorizedResponse('No token provided'));\n    }\n\n    const token = authHeader.substring(7);\n    const payload = verifyToken(token);\n\n    if (!payload) {\n        return getErrorResponse(unauthorizedResponse('Invalid or expired token'));\n    }\n\n    // Check required type\n    if (requiredType !== 'any' && payload.type !== requiredType) {\n        return getErrorResponse(forbiddenResponse(`Access restricted to ${requiredType}s`));\n    }\n\n    const authenticatedRequest = request as AuthenticatedRequest;\n    authenticatedRequest.tokenPayload = payload;\n\n    // For user tokens, load full user info\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            first_name: string;\n            last_name: string;\n            role_id: number;\n            role_code: string;\n            role_name: string;\n            permissions: string;\n            status: string;\n        }\n\n        const [userRow] = await query<UserRow[]>(\n            `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id,\n              r.code as role_code, r.name as role_name, r.permissions,\n              u.status\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return getErrorResponse(unauthorizedResponse('User not found or inactive'));\n        }\n\n        // Safely parse permissions - handle invalid JSON gracefully\n        let permissions: string[] = [];\n        try {\n            const rawPerms = userRow.permissions;\n            if (rawPerms && typeof rawPerms === 'string' && rawPerms.startsWith('[')) {\n                permissions = JSON.parse(rawPerms);\n            } else if (Array.isArray(rawPerms)) {\n                permissions = rawPerms;\n            }\n        } catch (e) {\n            console.warn('Invalid permissions JSON, defaulting to empty array');\n            permissions = [];\n        }\n\n        authenticatedRequest.user = {\n            id: userRow.id,\n            email: userRow.email,\n            firstName: userRow.first_name,\n            lastName: userRow.last_name,\n            roleId: userRow.role_id,\n            roleCode: userRow.role_code,\n            roleName: userRow.role_name,\n            permissions,\n            status: userRow.status,\n            mfaEnabled: false, // Simplified - no MFA\n        };\n\n        // Check required roles\n        if (requiredRoles && requiredRoles.length > 0) {\n            if (!requiredRoles.includes(userRow.role_code)) {\n                return getErrorResponse(forbiddenResponse('Insufficient role privileges'));\n            }\n        }\n\n        // Check required permissions\n        if (requiredPermissions && requiredPermissions.length > 0) {\n            const hasPermission = requiredPermissions.some((p) => permissions.includes(p));\n            if (!hasPermission) {\n                return getErrorResponse(forbiddenResponse('Insufficient permissions'));\n            }\n        }\n    }\n\n    // For customer tokens\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            customer_number: string;\n            email: string;\n            status: string;\n        }\n\n        const [customerRow] = await query<CustomerRow[]>(\n            `SELECT id, customer_number, email, status\n       FROM customers\n       WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return unauthorizedResponse('Customer not found or inactive');\n        }\n\n        authenticatedRequest.customer = {\n            id: customerRow.id,\n            customerNumber: customerRow.customer_number,\n            email: customerRow.email,\n        };\n    }\n\n    return handler(authenticatedRequest);\n}\n\n// =============================================================================\n// Validation Middleware\n// =============================================================================\n\nexport async function validateBody<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): Promise<{ success: true; data: T } | { success: false; response: NextResponse }> {\n    try {\n        const body = await request.json();\n        const data = schema.parse(body);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid request body') };\n    }\n}\n\nexport function validateQuery<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): { success: true; data: T } | { success: false; response: NextResponse } {\n    try {\n        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());\n        const data = schema.parse(searchParams);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid query parameters') };\n    }\n}\n\n// =============================================================================\n// Idempotency Middleware\n// =============================================================================\n\nexport function getIdempotencyKey(request: NextRequest): string | null {\n    return request.headers.get('Idempotency-Key') ||\n        request.headers.get('idempotency-key') ||\n        null;\n}\n\nexport function requireIdempotencyKey(request: NextRequest): { success: true; key: string } | { success: false; response: NextResponse } {\n    const key = getIdempotencyKey(request);\n    if (!key) {\n        return {\n            success: false,\n            response: errorResponse('Idempotency-Key header is required for this operation', 400)\n        };\n    }\n    // Validate UUID format\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(key)) {\n        return {\n            success: false,\n            response: errorResponse('Invalid Idempotency-Key format. Must be a valid UUID.', 400)\n        };\n    }\n    return { success: true, key };\n}\n\nexport async function checkIdempotency(\n    idempotencyKey: string | undefined\n): Promise<{ cached: true; response: NextResponse } | { cached: false }> {\n    if (!idempotencyKey) {\n        return { cached: false };\n    }\n\n    interface CachedRow extends RowDataPacket {\n        response_status: number;\n        response_body: string;\n    }\n\n    const [cached] = await query<CachedRow[]>(\n        `SELECT response_status, response_body\n     FROM idempotency_keys\n     WHERE idempotency_key = ? AND expires_at > NOW()`,\n        [idempotencyKey]\n    );\n\n    if (cached) {\n        const body = JSON.parse(cached.response_body);\n        return {\n            cached: true,\n            response: NextResponse.json(body, { status: cached.response_status }),\n        };\n    }\n\n    return { cached: false };\n}\n\n// =============================================================================\n// Error Handler Wrapper\n// =============================================================================\n\nexport function withErrorHandler<T = { id?: string }>(\n    handler: (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse>\n): (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse> {\n    return async (request: NextRequest, context?: { params: Promise<T> }) => {\n        try {\n            // Context is optional - routes without dynamic params won't have it\n            return await handler(request, context);\n        } catch (error) {\n            console.error('API Error:', error);\n\n            if (error instanceof Error) {\n                // Don't expose internal error messages in production\n                const message = process.env.NODE_ENV === 'development'\n                    ? error.message\n                    : 'An unexpected error occurred';\n                return serverErrorResponse(message);\n            }\n\n            return serverErrorResponse();\n        }\n    };\n}\n\n// =============================================================================\n// Pagination Helper\n// =============================================================================\n\nexport function getPaginationMeta(page: number, limit: number, total: number) {\n    return {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n    };\n}\n\nexport function getOffset(page: number, limit: number): number {\n    return (page - 1) * limit;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/validations/schemas.ts"],"sourcesContent":["import { z } from 'zod';\n\n// =============================================================================\n// Common Validators\n// =============================================================================\n\nexport const paginationSchema = z.object({\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\nexport const idParamSchema = z.object({\n    id: z.coerce.number().int().positive(),\n});\n\n// =============================================================================\n// Auth Validators\n// =============================================================================\n\nexport const loginSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: z.string().min(1, 'Password is required'),\n    type: z.enum(['user', 'customer']).default('user'),\n});\n\nexport const refreshTokenSchema = z.object({\n    refreshToken: z.string().min(1, 'Refresh token is required'),\n});\n\n// =============================================================================\n// Customer Validators\n// =============================================================================\n\n// =============================================================================\n// Common Validators\n// =============================================================================\n\nexport const strongPasswordSchema = z.string()\n    .min(8, 'Password must be at least 8 characters')\n    // Regex: At least one uppercase, one lowercase, one number, one special char\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\n    .regex(/[0-9]/, 'Password must contain at least one number')\n    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character');\n\nexport const createCustomerSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: strongPasswordSchema,\n    firstName: z.string().min(1, 'First name is required').max(100),\n    lastName: z.string().min(1, 'Last name is required').max(100),\n    phone: z.string().max(20).optional(),\n    dateOfBirth: z.string().datetime().optional().transform((val) => val ? new Date(val) : undefined),\n    nationalId: z.string().max(50).optional(),\n    addressLine1: z.string().max(255).optional(),\n    addressLine2: z.string().max(255).optional(),\n    city: z.string().max(100).optional(),\n    postalCode: z.string().max(20).optional(),\n});\n\nexport const updateCustomerSchema = z.object({\n    firstName: z.string().min(1).max(100).optional(),\n    lastName: z.string().min(1).max(100).optional(),\n    phone: z.string().max(20).optional(),\n    addressLine1: z.string().max(255).optional(),\n    addressLine2: z.string().max(255).optional(),\n    city: z.string().max(100).optional(),\n    postalCode: z.string().max(20).optional(),\n});\n\nexport const customerSearchSchema = z.object({\n    search: z.string().optional(),\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']).optional(),\n    kycStatus: z.enum(['NOT_STARTED', 'PENDING', 'VERIFIED', 'REJECTED']).optional(),\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\nexport const updateCustomerStatusSchema = z.object({\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']),\n});\n\nexport const updateKycStatusSchema = z.object({\n    status: z.enum(['NOT_STARTED', 'PENDING', 'VERIFIED', 'REJECTED']),\n});\n\n// =============================================================================\n// Account Validators\n// =============================================================================\n\nexport const createAccountSchema = z.object({\n    customerId: z.number().int().positive(),\n    accountType: z.enum(['SAVINGS', 'CHECKING', 'FIXED']),\n});\n\nexport const updateAccountStatusSchema = z.object({\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']),\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\n// =============================================================================\n// Transaction Validators\n// =============================================================================\n\n// BDT amount validator - max 10 million, min 1\nconst bdtAmount = z.number()\n    .positive('Amount must be positive')\n    .max(10000000, 'Amount exceeds maximum limit of 10,000,000')\n    .transform((val) => Math.round(val * 100) / 100); // Round to 2 decimal places\n\nexport const transferSchema = z.object({\n    fromAccountId: z.number().int().positive('Source account is required'),\n    toAccountNumber: z.string().min(1, 'Destination account number is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    idempotencyKey: z.string().uuid().optional(),\n});\n\nexport const depositSchema = z.object({\n    accountId: z.number().int().positive('Account is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    externalReference: z.string().max(100).optional(),\n    idempotencyKey: z.string().uuid('Invalid idempotency key format').optional(),\n});\n\nexport const withdrawSchema = z.object({\n    accountId: z.number().int().positive('Account is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    externalReference: z.string().max(100).optional(),\n    idempotencyKey: z.string().uuid('Invalid idempotency key format').optional(),\n});\n\nexport const reversalSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\nexport const transactionSearchSchema = z.object({\n    accountId: z.coerce.number().int().positive().optional(),\n    startDate: z.string().datetime().optional(),\n    endDate: z.string().datetime().optional(),\n    status: z.enum(['PENDING', 'COMPLETED', 'FAILED', 'REVERSED', 'CANCELLED']).optional(),\n    type: z.string().optional(),\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\n// =============================================================================\n// Reconciliation Validators\n// =============================================================================\n\nexport const createReconciliationSchema = z.object({\n    name: z.string().min(1, 'Name is required').max(255),\n    sourceType: z.enum(['BANK_STATEMENT', 'PAYMENT_GATEWAY', 'MANUAL']),\n});\n\nexport const matchReconciliationItemSchema = z.object({\n    transactionId: z.number().int().positive(),\n    matchReason: z.string().max(500).optional(),\n});\n\nexport const unmatchReconciliationItemSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\n// =============================================================================\n// Fraud Validators\n// =============================================================================\n\nexport const fraudReviewSchema = z.object({\n    decision: z.enum(['APPROVED', 'REJECTED', 'ESCALATED']),\n    notes: z.string().min(1, 'Notes are required').max(2000),\n});\n\nexport const fraudAssignSchema = z.object({\n    assignedTo: z.number().int().positive(),\n});\n\n// =============================================================================\n// Admin Validators\n// =============================================================================\n\nexport const createUserSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: z.string().min(8, 'Password must be at least 8 characters'),\n    firstName: z.string().min(1).max(100),\n    lastName: z.string().min(1).max(100),\n    roleId: z.number().int().positive(),\n});\n\nexport const updateUserSchema = z.object({\n    firstName: z.string().min(1).max(100).optional(),\n    lastName: z.string().min(1).max(100).optional(),\n    roleId: z.number().int().positive().optional(),\n    status: z.enum(['ACTIVE', 'INACTIVE', 'LOCKED', 'PENDING']).optional(),\n});\n\nexport const eodProcessSchema = z.object({\n    processDate: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Invalid date format (YYYY-MM-DD)'),\n});\n\nexport const interestPostingSchema = z.object({\n    year: z.number().int().min(2020).max(2100),\n    month: z.number().int().min(1).max(12),\n});\n\nexport const eventReplaySchema = z.object({\n    startEventId: z.number().int().positive().optional(),\n    endEventId: z.number().int().positive().optional(),\n    eventType: z.string().optional(),\n});\n\nexport const pseudonymizeSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\nexport const systemConfigSchema = z.object({\n    configKey: z.string().min(1).max(100),\n    configValue: z.string(),\n    valueType: z.enum(['STRING', 'NUMBER', 'BOOLEAN', 'JSON']).default('STRING'),\n    description: z.string().max(500).optional(),\n});\n\n// =============================================================================\n// Type Exports\n// =============================================================================\n\nexport type LoginInput = z.infer<typeof loginSchema>;\nexport type CreateCustomerInput = z.infer<typeof createCustomerSchema>;\nexport type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;\nexport type CreateAccountInput = z.infer<typeof createAccountSchema>;\nexport type TransferInput = z.infer<typeof transferSchema>;\nexport type DepositInput = z.infer<typeof depositSchema>;\nexport type WithdrawInput = z.infer<typeof withdrawSchema>;\nexport type CreateUserInput = z.infer<typeof createUserSchema>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1320, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/customer-service.ts"],"sourcesContent":["import { query, queryOne, execute } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    phone: string | null;\n    dateOfBirth: Date | null;\n    nationalId: string | null;\n    addressLine1: string | null;\n    addressLine2: string | null;\n    city: string | null;\n    postalCode: string | null;\n    country: string;\n    status: string;\n    kycStatus: string;\n    riskScore: number;\n    createdAt: Date;\n}\n\nexport interface CustomerWithAccounts extends Customer {\n    accountCount: number;\n    totalBalance: number;\n}\n\nexport interface CreateCustomerRequest {\n    email: string;\n    password: string;\n    firstName: string;\n    lastName: string;\n    phone?: string;\n    dateOfBirth?: Date;\n    nationalId?: string;\n    addressLine1?: string;\n    addressLine2?: string;\n    city?: string;\n    postalCode?: string;\n    createdBy: number;\n}\n\nexport interface UpdateCustomerRequest {\n    firstName?: string;\n    lastName?: string;\n    phone?: string;\n    addressLine1?: string;\n    addressLine2?: string;\n    city?: string;\n    postalCode?: string;\n}\n\n// =============================================================================\n// Customer Queries\n// =============================================================================\n\ninterface CustomerRow extends RowDataPacket {\n    id: number;\n    customer_number: string;\n    email: string;\n    first_name: string;\n    last_name: string;\n    phone: string | null;\n    date_of_birth: Date | null;\n    national_id: string | null;\n    address_line1: string | null;\n    address_line2: string | null;\n    city: string | null;\n    postal_code: string | null;\n    country: string;\n    status: string;\n    kyc_status: string;\n    risk_score: number;\n    created_at: Date;\n    account_count?: number;\n    total_balance?: string;\n}\n\nfunction mapCustomerRow(row: CustomerRow): Customer {\n    return {\n        id: row.id,\n        customerNumber: row.customer_number,\n        email: row.email,\n        firstName: row.first_name,\n        lastName: row.last_name,\n        phone: row.phone,\n        dateOfBirth: row.date_of_birth,\n        nationalId: row.national_id,\n        addressLine1: row.address_line1,\n        addressLine2: row.address_line2,\n        city: row.city,\n        postalCode: row.postal_code,\n        country: row.country,\n        status: row.status,\n        kycStatus: row.kyc_status,\n        riskScore: row.risk_score,\n        createdAt: row.created_at,\n    };\n}\n\nexport async function getCustomerById(customerId: number): Promise<Customer | null> {\n    const row = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, first_name, last_name, phone,\n            date_of_birth, national_id, address_line1, address_line2,\n            city, postal_code, country, status, kyc_status, risk_score, created_at\n     FROM customers\n     WHERE id = ?`,\n        [customerId]\n    );\n\n    if (!row) return null;\n    return mapCustomerRow(row);\n}\n\nexport async function getCustomerByNumber(customerNumber: string): Promise<Customer | null> {\n    const row = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, first_name, last_name, phone,\n            date_of_birth, national_id, address_line1, address_line2,\n            city, postal_code, country, status, kyc_status, risk_score, created_at\n     FROM customers\n     WHERE customer_number = ?`,\n        [customerNumber]\n    );\n\n    if (!row) return null;\n    return mapCustomerRow(row);\n}\n\nexport async function getCustomerByEmail(email: string): Promise<Customer | null> {\n    const row = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, first_name, last_name, phone,\n            date_of_birth, national_id, address_line1, address_line2,\n            city, postal_code, country, status, kyc_status, risk_score, created_at\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!row) return null;\n    return mapCustomerRow(row);\n}\n\nexport async function searchCustomers(options: {\n    search?: string;\n    status?: string;\n    kycStatus?: string;\n    limit?: number;\n    offset?: number;\n}): Promise<{ customers: CustomerWithAccounts[]; total: number }> {\n    const { search, status, kycStatus, limit = 50, offset = 0 } = options;\n\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (search) {\n        conditions.push(\n            `(c.customer_number LIKE ? OR c.email LIKE ? OR c.first_name LIKE ? OR c.last_name LIKE ? OR c.national_id LIKE ?)`\n        );\n        const searchPattern = `%${search}%`;\n        params.push(searchPattern, searchPattern, searchPattern, searchPattern, searchPattern);\n    }\n\n    if (status) {\n        conditions.push('c.status = ?');\n        params.push(status);\n    }\n\n    if (kycStatus) {\n        conditions.push('c.kyc_status = ?');\n        params.push(kycStatus);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count FROM customers c WHERE ${whereClause}`,\n        params\n    );\n\n    const rows = await query<CustomerRow[]>(\n        `SELECT c.id, c.customer_number, c.email, c.first_name, c.last_name, c.phone,\n            c.date_of_birth, c.national_id, c.address_line1, c.address_line2,\n            c.city, c.postal_code, c.country, c.status, c.kyc_status, c.risk_score, c.created_at,\n            COUNT(a.id) as account_count,\n            COALESCE(SUM(ab.available_balance), 0) as total_balance\n     FROM customers c\n     LEFT JOIN accounts a ON a.customer_id = c.id AND a.status = 'ACTIVE'\n     LEFT JOIN account_balances ab ON ab.account_id = a.id\n     WHERE ${whereClause}\n     GROUP BY c.id\n     ORDER BY c.created_at DESC\n     LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    const customers = rows.map((row) => ({\n        ...mapCustomerRow(row),\n        accountCount: row.account_count || 0,\n        totalBalance: parseFloat(row.total_balance || '0'),\n    }));\n\n    return { customers, total: countRow?.count || 0 };\n}\n\n// =============================================================================\n// Customer Creation\n// =============================================================================\n\nimport { hashPassword } from './auth-service';\n\nexport async function createCustomer(\n    request: CreateCustomerRequest\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    // Check if email already exists\n    const existing = await getCustomerByEmail(request.email);\n    if (existing) {\n        return { success: false, error: 'Email already exists' };\n    }\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n    const passwordHash = await hashPassword(request.password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (\n         customer_number, email, password_hash, first_name, last_name, phone,\n         date_of_birth, national_id, address_line1, address_line2,\n         city, postal_code, status, created_by\n       ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'PENDING', ?)`,\n            [\n                customerNumber,\n                request.email,\n                passwordHash,\n                request.firstName,\n                request.lastName,\n                request.phone || null,\n                request.dateOfBirth || null,\n                request.nationalId || null,\n                request.addressLine1 || null,\n                request.addressLine2 || null,\n                request.city || null,\n                request.postalCode || null,\n                request.createdBy,\n            ]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        console.error('Error creating customer:', error);\n        return { success: false, error: 'Failed to create customer' };\n    }\n}\n\n// =============================================================================\n// Customer Updates\n// =============================================================================\n\nexport async function updateCustomer(\n    customerId: number,\n    updates: UpdateCustomerRequest\n): Promise<{ success: boolean; error?: string }> {\n    const fields: string[] = [];\n    const values: unknown[] = [];\n\n    if (updates.firstName !== undefined) {\n        fields.push('first_name = ?');\n        values.push(updates.firstName);\n    }\n    if (updates.lastName !== undefined) {\n        fields.push('last_name = ?');\n        values.push(updates.lastName);\n    }\n    if (updates.phone !== undefined) {\n        fields.push('phone = ?');\n        values.push(updates.phone);\n    }\n    if (updates.addressLine1 !== undefined) {\n        fields.push('address_line1 = ?');\n        values.push(updates.addressLine1);\n    }\n    if (updates.addressLine2 !== undefined) {\n        fields.push('address_line2 = ?');\n        values.push(updates.addressLine2);\n    }\n    if (updates.city !== undefined) {\n        fields.push('city = ?');\n        values.push(updates.city);\n    }\n    if (updates.postalCode !== undefined) {\n        fields.push('postal_code = ?');\n        values.push(updates.postalCode);\n    }\n\n    if (fields.length === 0) {\n        return { success: false, error: 'No fields to update' };\n    }\n\n    fields.push('updated_at = NOW()');\n    values.push(customerId);\n\n    await execute(\n        `UPDATE customers SET ${fields.join(', ')} WHERE id = ?`,\n        values\n    );\n\n    return { success: true };\n}\n\n// =============================================================================\n// Customer Status Management\n// =============================================================================\n\nexport async function updateCustomerStatus(\n    customerId: number,\n    newStatus: 'PENDING' | 'ACTIVE' | 'SUSPENDED' | 'CLOSED'\n): Promise<{ success: boolean; error?: string }> {\n    const customer = await getCustomerById(customerId);\n    if (!customer) {\n        return { success: false, error: 'Customer not found' };\n    }\n\n    await execute(\n        `UPDATE customers SET status = ?, updated_at = NOW() WHERE id = ?`,\n        [newStatus, customerId]\n    );\n\n    return { success: true };\n}\n\n// =============================================================================\n// KYC Management\n// =============================================================================\n\nexport async function updateKycStatus(\n    customerId: number,\n    newStatus: 'NOT_STARTED' | 'PENDING' | 'VERIFIED' | 'REJECTED',\n    verifiedBy?: number\n): Promise<{ success: boolean; error?: string }> {\n    const customer = await getCustomerById(customerId);\n    if (!customer) {\n        return { success: false, error: 'Customer not found' };\n    }\n\n    if (newStatus === 'VERIFIED' && verifiedBy) {\n        await execute(\n            `UPDATE customers SET kyc_status = ?, kyc_verified_at = NOW(), kyc_verified_by = ?, updated_at = NOW() WHERE id = ?`,\n            [newStatus, verifiedBy, customerId]\n        );\n\n        // Also activate customer if pending\n        if (customer.status === 'PENDING') {\n            await updateCustomerStatus(customerId, 'ACTIVE');\n        }\n    } else {\n        await execute(\n            `UPDATE customers SET kyc_status = ?, updated_at = NOW() WHERE id = ?`,\n            [newStatus, customerId]\n        );\n    }\n\n    return { success: true };\n}\n\n// =============================================================================\n// GDPR - Pseudonymization\n// =============================================================================\n\nexport async function pseudonymizeCustomer(\n    customerId: number,\n    reason: string,\n    pseudonymizedBy: number\n): Promise<{ success: boolean; error?: string }> {\n    const customer = await getCustomerById(customerId);\n    if (!customer) {\n        return { success: false, error: 'Customer not found' };\n    }\n\n    // Store original email hash for audit\n    const crypto = await import('crypto');\n    const emailHash = crypto.createHash('sha256').update(customer.email).digest('hex');\n\n    // Pseudonymize customer data\n    const pseudoEmail = `deleted-${customerId}@anonymized.local`;\n\n    await execute(\n        `UPDATE customers SET\n       email = ?,\n       first_name = 'REDACTED',\n       last_name = 'USER',\n       phone = NULL,\n       date_of_birth = NULL,\n       national_id = NULL,\n       address_line1 = NULL,\n       address_line2 = NULL,\n       city = NULL,\n       postal_code = NULL,\n       status = 'CLOSED',\n       updated_at = NOW()\n     WHERE id = ?`,\n        [pseudoEmail, customerId]\n    );\n\n    // Record pseudonymization\n    await execute(\n        `INSERT INTO customer_pseudonymizations (customer_id, original_email_hash, pseudonymized_by, reason)\n     VALUES (?, ?, ?, ?)`,\n        [customerId, emailHash, pseudonymizedBy, reason]\n    );\n\n    return { success: true };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1627, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/account-service.ts"],"sourcesContent":["import { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket, ResultSetHeader } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type AccountType = 'SAVINGS' | 'CHECKING' | 'FIXED';\nexport type AccountStatus = 'ACTIVE' | 'SUSPENDED' | 'CLOSED' | 'PENDING';\n\nexport interface Account {\n    id: number;\n    accountNumber: string;\n    customerId: number;\n    accountType: AccountType;\n    currency: string;\n    status: AccountStatus;\n    openedAt: Date | null;\n    createdAt: Date;\n    customerName?: string;\n    balance?: {\n        availableBalance: number;\n    };\n}\n\n// =============================================================================\n// Account Queries\n// =============================================================================\n\nexport async function getAccountById(accountId: number): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.id = ?`,\n        [accountId]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountByNumber(accountNumber: string): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.account_number = ?`,\n        [accountNumber]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountsForCustomer(customerId: number): Promise<Account[]> {\n    const rows = await query<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                c.first_name, c.last_name,\n                COALESCE(ab.available_balance, 0) as available_balance,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN customers c ON c.id = a.customer_id\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.customer_id = ?\n         ORDER BY a.created_at DESC`,\n        [customerId]\n    );\n\n    return rows.map((row: any) => ({\n        id: row.id,\n        accountNumber: row.account_number,\n        customerId: row.customer_id,\n        accountType: row.account_type,\n        accountTypeName: row.account_type_name,\n        currency: row.currency,\n        status: row.status,\n        openedAt: row.created_at,\n        createdAt: row.created_at,\n        customerName: `${row.first_name} ${row.last_name}`,\n        balance: {\n            availableBalance: parseFloat(row.available_balance || '0')\n        }\n    }));\n}\n\n// =============================================================================\n// Lifecycle Management (Freeze/Unfreeze)\n// =============================================================================\n\nexport async function freezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"SUSPENDED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error freezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function unfreezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"ACTIVE\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error unfreezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function closeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        // 1. Check Balance (Must be 0)\n        const balanceRow = await queryOne<RowDataPacket>(\n            'SELECT available_balance FROM account_balances WHERE account_id = ?',\n            [accountId]\n        );\n\n        const balance = parseFloat(balanceRow?.available_balance || '0');\n        if (balance !== 0) {\n            return { success: false, error: `Cannot close account. Non-zero balance: ${balance}` };\n        }\n\n        // 2. Update Account Status\n        await query(\n            'UPDATE accounts SET status = \"CLOSED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n\n        return { success: true };\n    } catch (error) {\n        console.error('Error closing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\n// =============================================================================\n// Account Creation (Direct)\n// =============================================================================\n\nexport async function createAccount(\n    customerId: number,\n    accountTypeId: number,\n    createdBy?: number\n): Promise<{ success: boolean; accountId?: number; accountNumber?: string; error?: string }> {\n    try {\n        // 1. Verify Customer exists\n        const customer = await queryOne<RowDataPacket>(\n            'SELECT id FROM customers WHERE id = ?',\n            [customerId]\n        );\n\n        if (!customer) {\n            return { success: false, error: 'Customer not found' };\n        }\n\n        // 2. Generate Account Number (matches existing 1001-XXXX-XXXX format)\n        const segment1 = '1001';\n        const segment2 = String(customerId).padStart(4, '0');\n        const segment3 = String(Math.floor(1000 + Math.random() * 9000));\n        const accountNumber = `${segment1}-${segment2}-${segment3}`;\n\n        return await withTransaction(async (conn) => {\n            // 3. Insert Account record\n            const [accountResult] = await conn.execute<ResultSetHeader>(\n                `INSERT INTO accounts (account_number, customer_id, account_type_id, status, opened_at, created_at, created_by)\n                 VALUES (?, ?, ?, 'ACTIVE', NOW(), NOW(), ?)`,\n                [accountNumber, customerId, accountTypeId, createdBy || null]\n            );\n\n            const accountId = accountResult.insertId;\n\n            // 4. Initialize Balance record\n            await conn.execute(\n                `INSERT INTO account_balances (account_id, available_balance, currency, version)\n                 VALUES (?, 0.0000, 'BDT', 1)`,\n                [accountId]\n            );\n\n            return {\n                success: true,\n                accountId,\n                accountNumber\n            };\n        });\n    } catch (error) {\n        console.error('Error creating account:', error);\n        return { success: false, error: 'Database error during account creation' };\n    }\n}\n\n/**\n * Legacy wrapper for application flow.\n * Now directly creates the account.\n */\nexport async function applyForAccount(\n    customerId: number,\n    accountTypeCode: AccountType\n): Promise<{ success: boolean; applicationId?: number; error?: string }> {\n    // Lookup Account Type ID\n    const typeRow = await queryOne<RowDataPacket>(\n        'SELECT id FROM account_types WHERE code = ?',\n        [accountTypeCode]\n    );\n\n    if (!typeRow) {\n        return { success: false, error: 'Invalid account type' };\n    }\n\n    const result = await createAccount(customerId, typeRow.id);\n\n    if (result.success) {\n        return { success: true, applicationId: result.accountId };\n    }\n\n    return { success: false, error: result.error };\n}\n\nexport async function getPendingApplications(): Promise<any[]> {\n    // No longer applicable, returning empty array\n    return [];\n}\n\n/**\n * Creates a new customer record (without any accounts).\n * Banker will create accounts separately via the accounts endpoint.\n */\nexport async function onboardNewCustomer(\n    data: {\n        firstName: string;\n        lastName: string;\n        email: string;\n        dateOfBirth: string;\n        customerNumber: string;\n        createdBy: number;\n    }\n): Promise<{ success: boolean; customerId?: number; error?: string }> {\n    try {\n        // Generate a temporary password (they should change it later)\n        const tempPassword = 'Welcome!' + Math.floor(1000 + Math.random() * 9000);\n        const { hashPassword } = await import('./auth-service');\n        const passwordHash = await hashPassword(tempPassword);\n\n        // Create Customer (no automatic account)\n        const result = await execute(\n            `INSERT INTO customers \n             (customer_number, email, first_name, last_name, date_of_birth, status, kyc_status, created_at, created_by, password_hash)\n             VALUES (?, ?, ?, ?, ?, 'ACTIVE', 'VERIFIED', NOW(), ?, ?)`,\n            [data.customerNumber, data.email, data.firstName, data.lastName, data.dateOfBirth, data.createdBy, passwordHash]\n        );\n\n        return {\n            success: true,\n            customerId: result.insertId,\n        };\n    } catch (error) {\n        if ((error as any).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email or Customer Number already exists' };\n        }\n        console.error('Error during customer creation:', error);\n        return { success: false, error: 'Database error during customer creation' };\n    }\n}\n\nexport async function refreshAccountBalance(accountId: number): Promise<void> {\n    // Placeholder - in real system would trigger reconciliation\n    return;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1907, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/app/api/v1/customers/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport {\n    withErrorHandler,\n    withAuth,\n    validateBody,\n    successResponse,\n    notFoundResponse,\n    errorResponse,\n    AuthenticatedRequest,\n} from '@/lib/api-utils';\nimport {\n    updateCustomerSchema,\n    updateCustomerStatusSchema,\n    updateKycStatusSchema,\n} from '@/lib/validations/schemas';\nimport {\n    getCustomerById,\n    updateCustomer,\n    updateCustomerStatus,\n    updateKycStatus,\n} from '@/lib/services/customer-service';\nimport { getAccountsForCustomer } from '@/lib/services/account-service';\n\n// =============================================================================\n// GET /api/v1/customers/[id] - Get customer details\n// =============================================================================\n\nexport const GET = withErrorHandler(async (request: NextRequest, context) => {\n    const params = await context?.params;\n    const customerId = parseInt(params?.id || '0');\n\n    return withAuth(\n        request,\n        async (req: AuthenticatedRequest) => {\n            // Customers can only view their own profile\n            if (req.tokenPayload?.type === 'customer') {\n                if (req.customer?.id !== customerId) {\n                    return notFoundResponse('Customer not found');\n                }\n            }\n\n            const customer = await getCustomerById(customerId);\n            if (!customer) {\n                return notFoundResponse('Customer not found');\n            }\n\n            // Get accounts with balances\n            const accounts = await getAccountsForCustomer(customerId);\n\n            return successResponse({\n                ...customer,\n                accounts,\n            });\n        },\n        {\n            requiredType: 'any',\n        }\n    );\n});\n\n// =============================================================================\n// PATCH /api/v1/customers/[id] - Update customer\n// =============================================================================\n\nexport const PATCH = withErrorHandler(async (request: NextRequest, context) => {\n    const params = await context?.params;\n    const customerId = parseInt(params?.id || '0');\n\n    return withAuth(\n        request,\n        async (req: AuthenticatedRequest) => {\n            const validation = await validateBody(request, updateCustomerSchema);\n            if (!validation.success) {\n                return validation.response;\n            }\n\n            const customer = await getCustomerById(customerId);\n            if (!customer) {\n                return notFoundResponse('Customer not found');\n            }\n\n            const result = await updateCustomer(customerId, validation.data);\n            if (!result.success) {\n                return errorResponse(result.error || 'Failed to update customer');\n            }\n\n            const updated = await getCustomerById(customerId);\n            return successResponse(updated);\n        },\n        {\n            requiredType: 'user',\n            requiredPermissions: ['customers.write'],\n        }\n    );\n});\n"],"names":[],"mappings":";;;;;;AACA;AASA;AAKA;AAMA;;;;;AAMO,MAAM,MAAM,IAAA,gJAAgB,EAAC,OAAO,SAAsB;IAC7D,MAAM,SAAS,MAAM,SAAS;IAC9B,MAAM,aAAa,SAAS,QAAQ,MAAM;IAE1C,OAAO,IAAA,wIAAQ,EACX,SACA,OAAO;QACH,4CAA4C;QAC5C,IAAI,IAAI,YAAY,EAAE,SAAS,YAAY;YACvC,IAAI,IAAI,QAAQ,EAAE,OAAO,YAAY;gBACjC,OAAO,IAAA,gJAAgB,EAAC;YAC5B;QACJ;QAEA,MAAM,WAAW,MAAM,IAAA,kKAAe,EAAC;QACvC,IAAI,CAAC,UAAU;YACX,OAAO,IAAA,gJAAgB,EAAC;QAC5B;QAEA,6BAA6B;QAC7B,MAAM,WAAW,MAAM,IAAA,wKAAsB,EAAC;QAE9C,OAAO,IAAA,+IAAe,EAAC;YACnB,GAAG,QAAQ;YACX;QACJ;IACJ,GACA;QACI,cAAc;IAClB;AAER;AAMO,MAAM,QAAQ,IAAA,gJAAgB,EAAC,OAAO,SAAsB;IAC/D,MAAM,SAAS,MAAM,SAAS;IAC9B,MAAM,aAAa,SAAS,QAAQ,MAAM;IAE1C,OAAO,IAAA,wIAAQ,EACX,SACA,OAAO;QACH,MAAM,aAAa,MAAM,IAAA,4IAAY,EAAC,SAAS,8JAAoB;QACnE,IAAI,CAAC,WAAW,OAAO,EAAE;YACrB,OAAO,WAAW,QAAQ;QAC9B;QAEA,MAAM,WAAW,MAAM,IAAA,kKAAe,EAAC;QACvC,IAAI,CAAC,UAAU;YACX,OAAO,IAAA,gJAAgB,EAAC;QAC5B;QAEA,MAAM,SAAS,MAAM,IAAA,iKAAc,EAAC,YAAY,WAAW,IAAI;QAC/D,IAAI,CAAC,OAAO,OAAO,EAAE;YACjB,OAAO,IAAA,6IAAa,EAAC,OAAO,KAAK,IAAI;QACzC;QAEA,MAAM,UAAU,MAAM,IAAA,kKAAe,EAAC;QACtC,OAAO,IAAA,+IAAe,EAAC;IAC3B,GACA;QACI,cAAc;QACd,qBAAqB;YAAC;SAAkB;IAC5C;AAER"}}]
}