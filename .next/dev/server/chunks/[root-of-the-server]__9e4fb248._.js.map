{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/auth-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface User {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    roleId: number;\n    roleCode: string;\n    roleName: string;\n    permissions: string[];\n    status: string;\n    mfaEnabled: boolean;\n}\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    status: string;\n    kycStatus: string;\n}\n\nexport interface TokenPayload {\n    sub: string;\n    type: 'user' | 'customer';\n    email: string;\n    role?: string;\n    permissions?: string[];\n    tokenVersion: number;\n    iat: number;\n    exp: number;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User | Customer;\n    token?: string;\n    refreshToken?: string;\n    error?: string;\n}\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\nconst BCRYPT_ROUNDS = 12;\nconst MAX_FAILED_ATTEMPTS = 5;\n\n// =============================================================================\n// Password Management\n// =============================================================================\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// =============================================================================\n// JWT Token Management\n// =============================================================================\n\nexport function generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n}\n\nexport function generateRefreshToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)({ ...payload, refresh: true }, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n}\n\nexport function verifyToken(token: string): TokenPayload | null {\n    try {\n        return jwt.verify(token, JWT_SECRET) as TokenPayload;\n    } catch {\n        return null;\n    }\n}\n\n// =============================================================================\n// User Authentication\n// =============================================================================\n\nexport async function authenticateUser(email: string, password: string): Promise<AuthResult> {\n    interface UserRow extends RowDataPacket {\n        id: number;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        role_id: number;\n        role_code: string;\n        role_name: string;\n        permissions: string;\n        status: string;\n    }\n\n    const userRow = await queryOne<UserRow>(\n        `SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,\n            u.role_id, r.code as role_code, r.name as role_name, r.permissions,\n            u.status\n     FROM users u\n     INNER JOIN roles r ON r.id = u.role_id\n     WHERE u.email = ?`,\n        [email]\n    );\n\n    if (!userRow) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    if (userRow.status !== 'ACTIVE') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, userRow.password_hash);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    // Update last login\n    await execute(\n        'UPDATE users SET last_login_at = NOW() WHERE id = ?',\n        [userRow.id]\n    );\n\n    // Parse permissions (MySQL may return JSON as already-parsed array)\n    const permissions = Array.isArray(userRow.permissions)\n        ? userRow.permissions as string[]\n        : JSON.parse(userRow.permissions || '[]') as string[];\n\n    const user: User = {\n        id: userRow.id,\n        email: userRow.email,\n        firstName: userRow.first_name,\n        lastName: userRow.last_name,\n        roleId: userRow.role_id,\n        roleCode: userRow.role_code,\n        roleName: userRow.role_name,\n        permissions,\n        status: userRow.status,\n        mfaEnabled: false, // Simplified - no MFA\n    };\n\n    // Generate tokens\n    const token = generateToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        permissions,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user, token, refreshToken };\n}\n\n// =============================================================================\n// Customer Authentication\n// =============================================================================\n\nexport async function authenticateCustomer(email: string, password: string): Promise<AuthResult> {\n    interface CustomerRow extends RowDataPacket {\n        id: number;\n        customer_number: string;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        status: string;\n        kyc_status: string;\n    }\n\n    const customerRow = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, password_hash, first_name, last_name,\n            status, kyc_status\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!customerRow) {\n        console.log(`[Auth] Customer not found: ${email}`);\n        return { success: false, error: 'Invalid email or password' };\n    }\n    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);\n\n    if (customerRow.status === 'SUSPENDED') {\n        return { success: false, error: 'Account is suspended. Please contact support.' };\n    }\n\n    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, customerRow.password_hash);\n    console.log(`[Auth] Password valid: ${passwordValid}`);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    const customer: Customer = {\n        id: customerRow.id,\n        customerNumber: customerRow.customer_number,\n        email: customerRow.email,\n        firstName: customerRow.first_name,\n        lastName: customerRow.last_name,\n        status: customerRow.status,\n        kycStatus: customerRow.kyc_status,\n    };\n\n    const token = generateToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user: customer, token, refreshToken };\n}\n\n// =============================================================================\n// Token Refresh\n// =============================================================================\n\nexport async function refreshAccessToken(refreshToken: string): Promise<AuthResult> {\n    const payload = verifyToken(refreshToken);\n\n    if (!payload) {\n        return { success: false, error: 'Invalid refresh token' };\n    }\n\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            role_code: string;\n            permissions: string;\n        }\n\n        const userRow = await queryOne<UserRow>(\n            `SELECT u.id, u.email, r.code as role_code, r.permissions\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return { success: false, error: 'User not found or inactive' };\n        }\n\n        const permissions = Array.isArray(userRow.permissions)\n            ? userRow.permissions as string[]\n            : JSON.parse(userRow.permissions || '[]') as string[];\n\n        const newToken = generateToken({\n            sub: userRow.id.toString(),\n            type: 'user',\n            email: userRow.email,\n            role: userRow.role_code,\n            permissions,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            email: string;\n        }\n\n        const customerRow = await queryOne<CustomerRow>(\n            `SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return { success: false, error: 'Customer not found or inactive' };\n        }\n\n        const newToken = generateToken({\n            sub: customerRow.id.toString(),\n            type: 'customer',\n            email: customerRow.email,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    return { success: false, error: 'Invalid token type' };\n}\n\n// =============================================================================\n// User Management\n// =============================================================================\n\nexport async function createUser(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    roleId: number,\n    createdBy?: number\n): Promise<{ success: boolean; userId?: number; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`,\n            [email, passwordHash, firstName, lastName, roleId, createdBy ?? null]\n        );\n\n        return { success: true, userId: result.insertId };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\nexport async function createCustomer(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    createdBy?: number\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)\n       VALUES (?, ?, ?, ?, ?, 'PENDING', ?)`,\n            [customerNumber, email, passwordHash, firstName, lastName, createdBy ?? null]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\n// =============================================================================\n// Authorization Helpers\n// =============================================================================\n\nexport function hasPermission(user: User, permission: string): boolean {\n    return user.permissions.includes(permission);\n}\n\nexport function hasAnyPermission(user: User, permissions: string[]): boolean {\n    return permissions.some((p) => user.permissions.includes(p));\n}\n\nexport function hasAllPermissions(user: User, permissions: string[]): boolean {\n    return permissions.every((p) => user.permissions.includes(p));\n}\n\nexport function isRole(user: User, role: string): boolean {\n    return user.roleCode === role;\n}\n\nexport function isAnyRole(user: User, roles: string[]): boolean {\n    return roles.includes(user.roleCode);\n}\n\n// =============================================================================\n// Logout / Global Sign Out\n// =============================================================================\n\nexport async function logout(userId: number, type: 'user' | 'customer'): Promise<void> {\n    const table = type === 'user' ? 'users' : 'customers';\n\n    // Increment token version to invalidate all existing tokens\n    await execute(\n        `UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`,\n        [userId]\n    );\n\n    // Also remove any active sessions\n    if (type === 'user') {\n        await execute('DELETE FROM user_sessions WHERE user_id = ?', [userId]);\n    }\n}\n\n// =============================================================================\n// Signup Token Management\n// =============================================================================\n\nimport crypto from 'crypto';\n\ninterface SignupTokenResult {\n    success: boolean;\n    token?: string;\n    error?: string;\n}\n\nexport async function generateSignupToken(\n    customerId: number,\n    accountId: number,\n    createdBy: number\n): Promise<SignupTokenResult> {\n    // 1. Strict Validation\n    // Verify Customer exists AND Account belongs to them AND they are eligible for signup\n    interface ValidationRow extends RowDataPacket {\n        customer_id: number;\n        status: string;\n        kyc_status: string;\n        onboarding_status: string;\n        account_customer_id: number;\n        password_hash: string;\n    }\n\n    const validation = await queryOne<ValidationRow>(\n        `SELECT c.id as customer_id, c.status, c.kyc_status, c.onboarding_status, c.password_hash,\n                a.customer_id as account_customer_id\n         FROM customers c\n         LEFT JOIN accounts a ON a.id = ?\n         WHERE c.id = ?`,\n        [accountId, customerId]\n    );\n\n    if (!validation) {\n        return { success: false, error: 'Customer not found' };\n    }\n\n    // Check Account Ownership\n    if (validation.account_customer_id !== validation.customer_id) {\n        return { success: false, error: 'Account does not belong to this customer' };\n    }\n\n    // Check Customer Status\n    if (validation.status !== 'PENDING' && validation.status !== 'ACTIVE') {\n        return { success: false, error: 'Customer status invalid for onboarding' };\n    }\n\n    // Check KYC Status (Must be VERIFIED or PENDING, usually VERIFIED is preferred but strict mode might allow PENDING if reviewing)\n    // Requirement said: VERIFIED or PENDING\n    if (validation.kyc_status !== 'VERIFIED' && validation.kyc_status !== 'PENDING') {\n        return { success: false, error: 'Customer KYC must be Verified or Pending' };\n    }\n\n    // Check Onboarding Status (Must be PENDING_SIGNUP)\n    if (validation.onboarding_status !== 'PENDING_SIGNUP') {\n        return { success: false, error: 'Customer has already signed up or is not in signup phase' };\n    }\n\n    // Check for existing password (redundant but safe)\n    if (validation.password_hash) {\n        return { success: false, error: 'Customer already has credentials' };\n    }\n\n    // 2. Generate random token\n    const token = crypto.randomBytes(32).toString('hex');\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    // 3. Set expiry (e.g., 48 hours)\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 48);\n\n    try {\n        await execute(\n            `INSERT INTO customer_signup_tokens (token_hash, customer_id, account_id, created_by, expires_at)\n             VALUES (?, ?, ?, ?, ?)`,\n            [tokenHash, customerId, accountId, createdBy, expiresAt]\n        );\n\n        return { success: true, token };\n    } catch (error) {\n        return { success: false, error: 'Failed to generate signup token' };\n    }\n}\n\nexport async function verifySignupToken(token: string): Promise<{ success: boolean; data?: any; error?: string }> {\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    const tokenRow = await queryOne<RowDataPacket & {\n        customer_id: number;\n        account_id: number;\n        expires_at: Date;\n        used_at: Date | null\n    }>(\n        `SELECT customer_id, account_id, expires_at, used_at \n         FROM customer_signup_tokens \n         WHERE token_hash = ?`,\n        [tokenHash]\n    );\n\n    if (!tokenRow) {\n        return { success: false, error: 'Invalid signup link' };\n    }\n\n    if (tokenRow.used_at) {\n        return { success: false, error: 'This link has already been used' };\n    }\n\n    if (new Date() > tokenRow.expires_at) {\n        return { success: false, error: 'Signup link has expired' };\n    }\n\n    return {\n        success: true,\n        data: {\n            customerId: tokenRow.customer_id,\n            accountId: tokenRow.account_id\n        }\n    };\n}\n\nexport async function completeSignup(\n    token: string,\n    password: string\n): Promise<{ success: boolean; error?: string }> {\n    const verifyResult = await verifySignupToken(token);\n\n    if (!verifyResult.success || !verifyResult.data) {\n        return { success: false, error: verifyResult.error };\n    }\n\n    const { customerId } = verifyResult.data;\n    const passwordHash = await hashPassword(password);\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n\n    try {\n        // 1. Update customer password and status\n        await execute(\n            `UPDATE customers \n             SET password_hash = ?, \n                 onboarding_status = 'PENDING_APPROVAL',\n                 updated_at = NOW() \n             WHERE id = ?`,\n            [passwordHash, customerId]\n        );\n\n        // 2. Mark token as used\n        await execute(\n            `UPDATE customer_signup_tokens \n             SET used_at = NOW() \n             WHERE token_hash = ?`,\n            [tokenHash]\n        );\n\n        return { success: true };\n    } catch (error) {\n        return { success: false, error: 'Failed to complete signup' };\n    }\n}\n\n// =============================================================================\n// Session Helper for Next.js App Router\n// =============================================================================\n\nimport { cookies, headers } from 'next/headers';\n\nexport async function getSession(): Promise<{ user?: User | Customer; role?: string } | null> {\n    try {\n        const cookieStore = await cookies();\n        const headerList = await headers();\n\n        let token = cookieStore.get('token')?.value;\n\n        if (!token) {\n            const authHeader = headerList.get('Authorization');\n            if (authHeader?.startsWith('Bearer ')) {\n                token = authHeader.substring(7);\n            }\n        }\n\n        if (!token) return null;\n\n        const payload = verifyToken(token);\n        if (!payload) return null;\n\n        if (payload.type === 'user') {\n            const userRow = await queryOne<RowDataPacket & User>(\n                `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status\n             FROM users u\n             JOIN roles r ON r.id = u.role_id\n             WHERE u.id = ?`,\n                [payload.sub]\n            );\n            if (!userRow) return null;\n\n            const permissions = Array.isArray(userRow.permissions)\n                ? userRow.permissions as string[]\n                : JSON.parse((userRow.permissions as any) || '[]') as string[];\n\n            return {\n                user: { ...userRow, firstName: userRow.first_name, lastName: userRow.last_name, roleId: userRow.role_id, roleCode: userRow.role_code, roleName: userRow.role_name, permissions, mfaEnabled: false },\n                role: userRow.role_code\n            };\n        }\n\n        if (payload.type === 'customer') {\n            const customerRow = await queryOne<RowDataPacket & Customer>(\n                `SELECT id, customer_number, email, first_name, last_name, status, kyc_status\n             FROM customers WHERE id = ?`,\n                [payload.sub]\n            );\n            if (!customerRow) return null;\n\n            return {\n                user: { ...customerRow, customerNumber: customerRow.customer_number, firstName: customerRow.first_name, lastName: customerRow.last_name, kycStatus: customerRow.kyc_status },\n                role: 'CUSTOMER'\n            };\n        }\n\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AA8aA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAEhF;AA+JA,gFAAgF;AAChF,wCAAwC;AACxC,gFAAgF;AAEhF;;;;AApiBA,gFAAgF;AAChF,gBAAgB;AAChB,gFAAgF;AAEhF,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AACrD,MAAM,yBAAyB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACrE,MAAM,gBAAgB;AACtB,MAAM,sBAAsB;AAMrB,eAAe,aAAa,QAAgB;IAC/C,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AACjC;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IAC/D,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AACpC;AAMO,SAAS,cAAc,OAA0C;IACpE,8DAA8D;IAC9D,OAAO,AAAC,2MAAG,CAAC,IAAI,CAAS,SAAS,YAAY;QAAE,WAAW;IAAe;AAC9E;AAEO,SAAS,qBAAqB,OAA0C;IAC3E,8DAA8D;IAC9D,OAAO,AAAC,2MAAG,CAAC,IAAI,CAAS;QAAE,GAAG,OAAO;QAAE,SAAS;IAAK,GAAG,YAAY;QAAE,WAAW;IAAuB;AAC5G;AAEO,SAAS,YAAY,KAAa;IACrC,IAAI;QACA,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC7B,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAMO,eAAe,iBAAiB,KAAa,EAAE,QAAgB;IAclE,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;;;sBAKa,CAAC,EACf;QAAC;KAAM;IAGX,IAAI,CAAC,SAAS;QACV,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,IAAI,QAAQ,MAAM,KAAK,UAAU;QAC7B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,kBAAkB;IAClB,MAAM,gBAAgB,MAAM,eAAe,UAAU,QAAQ,aAAa;IAE1E,IAAI,CAAC,eAAe;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,oBAAoB;IACpB,MAAM,IAAA,6HAAO,EACT,uDACA;QAAC,QAAQ,EAAE;KAAC;IAGhB,oEAAoE;IACpE,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,QAAQ,WAAW,IAAI;IAExC,MAAM,OAAa;QACf,IAAI,QAAQ,EAAE;QACd,OAAO,QAAQ,KAAK;QACpB,WAAW,QAAQ,UAAU;QAC7B,UAAU,QAAQ,SAAS;QAC3B,QAAQ,QAAQ,OAAO;QACvB,UAAU,QAAQ,SAAS;QAC3B,UAAU,QAAQ,SAAS;QAC3B;QACA,QAAQ,QAAQ,MAAM;QACtB,YAAY;IAChB;IAEA,kBAAkB;IAClB,MAAM,QAAQ,cAAc;QACxB,KAAK,QAAQ,EAAE,CAAC,QAAQ;QACxB,MAAM;QACN,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,SAAS;QACvB;QACA,cAAc;IAClB;IAEA,MAAM,eAAe,qBAAqB;QACtC,KAAK,QAAQ,EAAE,CAAC,QAAQ;QACxB,MAAM;QACN,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,SAAS;QACvB,cAAc;IAClB;IAEA,OAAO;QAAE,SAAS;QAAM;QAAM;QAAO;IAAa;AACtD;AAMO,eAAe,qBAAqB,KAAa,EAAE,QAAgB;IAYtE,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC;;;oBAGW,CAAC,EACb;QAAC;KAAM;IAGX,IAAI,CAAC,aAAa;QACd,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,OAAO;QACjD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IACA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,YAAY,EAAE,CAAC,UAAU,EAAE,YAAY,MAAM,EAAE;IAErF,IAAI,YAAY,MAAM,KAAK,aAAa;QACpC,OAAO;YAAE,SAAS;YAAO,OAAO;QAAgD;IACpF;IAEA,IAAI,YAAY,MAAM,KAAK,YAAY,YAAY,MAAM,KAAK,WAAW;QACrE,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,kBAAkB;IAClB,MAAM,gBAAgB,MAAM,eAAe,UAAU,YAAY,aAAa;IAC9E,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,eAAe;IAErD,IAAI,CAAC,eAAe;QAChB,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;IAEA,MAAM,WAAqB;QACvB,IAAI,YAAY,EAAE;QAClB,gBAAgB,YAAY,eAAe;QAC3C,OAAO,YAAY,KAAK;QACxB,WAAW,YAAY,UAAU;QACjC,UAAU,YAAY,SAAS;QAC/B,QAAQ,YAAY,MAAM;QAC1B,WAAW,YAAY,UAAU;IACrC;IAEA,MAAM,QAAQ,cAAc;QACxB,KAAK,YAAY,EAAE,CAAC,QAAQ;QAC5B,MAAM;QACN,OAAO,YAAY,KAAK;QACxB,cAAc;IAClB;IAEA,MAAM,eAAe,qBAAqB;QACtC,KAAK,YAAY,EAAE,CAAC,QAAQ;QAC5B,MAAM;QACN,OAAO,YAAY,KAAK;QACxB,cAAc;IAClB;IAEA,OAAO;QAAE,SAAS;QAAM,MAAM;QAAU;QAAO;IAAa;AAChE;AAMO,eAAe,mBAAmB,YAAoB;IACzD,MAAM,UAAU,YAAY;IAE5B,IAAI,CAAC,SAAS;QACV,OAAO;YAAE,SAAS;YAAO,OAAO;QAAwB;IAC5D;IAEA,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAQzB,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;6CAGgC,CAAC,EAClC;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,SAAS;YACV,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA6B;QACjE;QAEA,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,QAAQ,WAAW,IAAI;QAExC,MAAM,WAAW,cAAc;YAC3B,KAAK,QAAQ,EAAE,CAAC,QAAQ;YACxB,MAAM;YACN,OAAO,QAAQ,KAAK;YACpB,MAAM,QAAQ,SAAS;YACvB;YACA,cAAc;QAClB;QAEA,OAAO;YAAE,SAAS;YAAM,OAAO;QAAS;IAC5C;IAEA,IAAI,QAAQ,IAAI,KAAK,YAAY;QAM7B,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC,kEAAkE,CAAC,EACpE;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,aAAa;YACd,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiC;QACrE;QAEA,MAAM,WAAW,cAAc;YAC3B,KAAK,YAAY,EAAE,CAAC,QAAQ;YAC5B,MAAM;YACN,OAAO,YAAY,KAAK;YACxB,cAAc;QAClB;QAEA,OAAO;YAAE,SAAS;YAAM,OAAO;QAAS;IAC5C;IAEA,OAAO;QAAE,SAAS;QAAO,OAAO;IAAqB;AACzD;AAMO,eAAe,WAClB,KAAa,EACb,QAAgB,EAChB,SAAiB,EACjB,QAAgB,EAChB,MAAc,EACd,SAAkB;IAElB,MAAM,eAAe,MAAM,aAAa;IAExC,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,6HAAO,EACxB,CAAC;iDACoC,CAAC,EACtC;YAAC;YAAO;YAAc;YAAW;YAAU;YAAQ,aAAa;SAAK;QAGzE,OAAO;YAAE,SAAS;YAAM,QAAQ,OAAO,QAAQ;QAAC;IACpD,EAAE,OAAO,OAAO;QACZ,IAAI,AAAC,MAA4B,IAAI,KAAK,gBAAgB;YACtD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuB;QAC3D;QACA,MAAM;IACV;AACJ;AAEO,eAAe,eAClB,KAAa,EACb,QAAgB,EAChB,SAAiB,EACjB,QAAgB,EAChB,SAAkB;IAElB,MAAM,eAAe,MAAM,aAAa;IAExC,2BAA2B;IAC3B,MAAM,iBAAiB,CAAC,CAAC,EAAE,KAAK,GAAG,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,KAAK;IAE7D,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,6HAAO,EACxB,CAAC;2CAC8B,CAAC,EAChC;YAAC;YAAgB;YAAO;YAAc;YAAW;YAAU,aAAa;SAAK;QAGjF,OAAO;YAAE,SAAS;YAAM,YAAY,OAAO,QAAQ;YAAE;QAAe;IACxE,EAAE,OAAO,OAAO;QACZ,IAAI,AAAC,MAA4B,IAAI,KAAK,gBAAgB;YACtD,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuB;QAC3D;QACA,MAAM;IACV;AACJ;AAMO,SAAS,cAAc,IAAU,EAAE,UAAkB;IACxD,OAAO,KAAK,WAAW,CAAC,QAAQ,CAAC;AACrC;AAEO,SAAS,iBAAiB,IAAU,EAAE,WAAqB;IAC9D,OAAO,YAAY,IAAI,CAAC,CAAC,IAAM,KAAK,WAAW,CAAC,QAAQ,CAAC;AAC7D;AAEO,SAAS,kBAAkB,IAAU,EAAE,WAAqB;IAC/D,OAAO,YAAY,KAAK,CAAC,CAAC,IAAM,KAAK,WAAW,CAAC,QAAQ,CAAC;AAC9D;AAEO,SAAS,OAAO,IAAU,EAAE,IAAY;IAC3C,OAAO,KAAK,QAAQ,KAAK;AAC7B;AAEO,SAAS,UAAU,IAAU,EAAE,KAAe;IACjD,OAAO,MAAM,QAAQ,CAAC,KAAK,QAAQ;AACvC;AAMO,eAAe,OAAO,MAAc,EAAE,IAAyB;IAClE,MAAM,QAAQ,SAAS,SAAS,UAAU;IAE1C,4DAA4D;IAC5D,MAAM,IAAA,6HAAO,EACT,CAAC,OAAO,EAAE,MAAM,mDAAmD,CAAC,EACpE;QAAC;KAAO;IAGZ,kCAAkC;IAClC,IAAI,SAAS,QAAQ;QACjB,MAAM,IAAA,6HAAO,EAAC,+CAA+C;YAAC;SAAO;IACzE;AACJ;;AAcO,eAAe,oBAClB,UAAkB,EAClB,SAAiB,EACjB,SAAiB;IAajB,MAAM,aAAa,MAAM,IAAA,8HAAQ,EAC7B,CAAC;;;;uBAIc,CAAC,EAChB;QAAC;QAAW;KAAW;IAG3B,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,SAAS;YAAO,OAAO;QAAqB;IACzD;IAEA,0BAA0B;IAC1B,IAAI,WAAW,mBAAmB,KAAK,WAAW,WAAW,EAAE;QAC3D,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2C;IAC/E;IAEA,wBAAwB;IACxB,IAAI,WAAW,MAAM,KAAK,aAAa,WAAW,MAAM,KAAK,UAAU;QACnE,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyC;IAC7E;IAEA,iIAAiI;IACjI,wCAAwC;IACxC,IAAI,WAAW,UAAU,KAAK,cAAc,WAAW,UAAU,KAAK,WAAW;QAC7E,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2C;IAC/E;IAEA,mDAAmD;IACnD,IAAI,WAAW,iBAAiB,KAAK,kBAAkB;QACnD,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2D;IAC/F;IAEA,mDAAmD;IACnD,IAAI,WAAW,aAAa,EAAE;QAC1B,OAAO;YAAE,SAAS;YAAO,OAAO;QAAmC;IACvE;IAEA,2BAA2B;IAC3B,MAAM,QAAQ,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;IAC9C,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,iCAAiC;IACjC,MAAM,YAAY,IAAI;IACtB,UAAU,QAAQ,CAAC,UAAU,QAAQ,KAAK;IAE1C,IAAI;QACA,MAAM,IAAA,6HAAO,EACT,CAAC;mCACsB,CAAC,EACxB;YAAC;YAAW;YAAY;YAAW;YAAW;SAAU;QAG5D,OAAO;YAAE,SAAS;YAAM;QAAM;IAClC,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkC;IACtE;AACJ;AAEO,eAAe,kBAAkB,KAAa;IACjD,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,MAAM,WAAW,MAAM,IAAA,8HAAQ,EAM3B,CAAC;;6BAEoB,CAAC,EACtB;QAAC;KAAU;IAGf,IAAI,CAAC,UAAU;QACX,OAAO;YAAE,SAAS;YAAO,OAAO;QAAsB;IAC1D;IAEA,IAAI,SAAS,OAAO,EAAE;QAClB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkC;IACtE;IAEA,IAAI,IAAI,SAAS,SAAS,UAAU,EAAE;QAClC,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0B;IAC9D;IAEA,OAAO;QACH,SAAS;QACT,MAAM;YACF,YAAY,SAAS,WAAW;YAChC,WAAW,SAAS,UAAU;QAClC;IACJ;AACJ;AAEO,eAAe,eAClB,KAAa,EACb,QAAgB;IAEhB,MAAM,eAAe,MAAM,kBAAkB;IAE7C,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,IAAI,EAAE;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO,aAAa,KAAK;QAAC;IACvD;IAEA,MAAM,EAAE,UAAU,EAAE,GAAG,aAAa,IAAI;IACxC,MAAM,eAAe,MAAM,aAAa;IACxC,MAAM,YAAY,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;IAEnE,IAAI;QACA,yCAAyC;QACzC,MAAM,IAAA,6HAAO,EACT,CAAC;;;;yBAIY,CAAC,EACd;YAAC;YAAc;SAAW;QAG9B,wBAAwB;QACxB,MAAM,IAAA,6HAAO,EACT,CAAC;;iCAEoB,CAAC,EACtB;YAAC;SAAU;QAGf,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAChE;AACJ;;AAQO,eAAe;IAClB,IAAI;QACA,MAAM,cAAc,MAAM,IAAA,2PAAO;QACjC,MAAM,aAAa,MAAM,IAAA,2PAAO;QAEhC,IAAI,QAAQ,YAAY,GAAG,CAAC,UAAU;QAEtC,IAAI,CAAC,OAAO;YACR,MAAM,aAAa,WAAW,GAAG,CAAC;YAClC,IAAI,YAAY,WAAW,YAAY;gBACnC,QAAQ,WAAW,SAAS,CAAC;YACjC;QACJ;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,UAAU,YAAY;QAC5B,IAAI,CAAC,SAAS,OAAO;QAErB,IAAI,QAAQ,IAAI,KAAK,QAAQ;YACzB,MAAM,UAAU,MAAM,IAAA,8HAAQ,EAC1B,CAAC;;;2BAGU,CAAC,EACZ;gBAAC,QAAQ,GAAG;aAAC;YAEjB,IAAI,CAAC,SAAS,OAAO;YAErB,MAAM,cAAc,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/C,QAAQ,WAAW,GACnB,KAAK,KAAK,CAAC,AAAC,QAAQ,WAAW,IAAY;YAEjD,OAAO;gBACH,MAAM;oBAAE,GAAG,OAAO;oBAAE,WAAW,QAAQ,UAAU;oBAAE,UAAU,QAAQ,SAAS;oBAAE,QAAQ,QAAQ,OAAO;oBAAE,UAAU,QAAQ,SAAS;oBAAE,UAAU,QAAQ,SAAS;oBAAE;oBAAa,YAAY;gBAAM;gBAClM,MAAM,QAAQ,SAAS;YAC3B;QACJ;QAEA,IAAI,QAAQ,IAAI,KAAK,YAAY;YAC7B,MAAM,cAAc,MAAM,IAAA,8HAAQ,EAC9B,CAAC;wCACuB,CAAC,EACzB;gBAAC,QAAQ,GAAG;aAAC;YAEjB,IAAI,CAAC,aAAa,OAAO;YAEzB,OAAO;gBACH,MAAM;oBAAE,GAAG,WAAW;oBAAE,gBAAgB,YAAY,eAAe;oBAAE,WAAW,YAAY,UAAU;oBAAE,UAAU,YAAY,SAAS;oBAAE,WAAW,YAAY,UAAU;gBAAC;gBAC3K,MAAM;YACV;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,GAAG;QACR,OAAO;IACX;AACJ"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/api-utils.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { verifyToken, TokenPayload, User } from '@/lib/services/auth-service';\nimport { query } from '@/lib/db';\nimport { RowDataPacket } from 'mysql2/promise';\nimport { ZodSchema, ZodError } from 'zod';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface AuthenticatedRequest extends NextRequest {\n    user?: User;\n    customer?: {\n        id: number;\n        customerNumber: string;\n        email: string;\n    };\n    tokenPayload?: TokenPayload;\n}\n\nexport interface ApiResponse<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: string;\n    errors?: Array<{ field: string; message: string }>;\n    meta?: {\n        page?: number;\n        limit?: number;\n        total?: number;\n        totalPages?: number;\n    };\n}\n\n// =============================================================================\n// Response Helpers\n// =============================================================================\n\nexport function successResponse<T>(data: T, meta?: ApiResponse['meta']): NextResponse {\n    return NextResponse.json({ success: true, data, meta }, { status: 200 });\n}\n\nexport function createdResponse<T>(data: T): NextResponse {\n    return NextResponse.json({ success: true, data }, { status: 201 });\n}\n\nexport function errorResponse(error: string, status: number = 400): NextResponse {\n    return NextResponse.json({ success: false, error }, { status });\n}\n\nexport function validationErrorResponse(errors: Array<{ field: string; message: string }>): NextResponse {\n    return NextResponse.json({ success: false, error: 'Validation failed', errors }, { status: 400 });\n}\n\nexport function unauthorizedResponse(error: string = 'Unauthorized'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 401 });\n}\n\nexport function forbiddenResponse(error: string = 'Forbidden'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 403 });\n}\n\nexport function notFoundResponse(error: string = 'Not found'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 404 });\n}\n\nexport function serverErrorResponse(error: string = 'Internal server error'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 500 });\n}\n\n// =============================================================================\n// Authentication Middleware\n// =============================================================================\n\nexport async function withAuth(\n    request: NextRequest,\n    handler: (req: AuthenticatedRequest) => Promise<NextResponse>,\n    options: {\n        requiredType?: 'user' | 'customer' | 'any';\n        requiredRoles?: string[];\n        requiredPermissions?: string[];\n        hideFailure?: boolean; // If true, returns 404 instead of 401/403 to hide existence\n    } = {}\n): Promise<NextResponse> {\n    const { requiredType = 'any', requiredRoles, requiredPermissions, hideFailure = false } = options;\n\n    // Helper to return 404 if hideFailure is on, otherwise the actual error\n    const getErrorResponse = (actualResponse: NextResponse) => {\n        return hideFailure ? notFoundResponse() : actualResponse;\n    };\n\n    // Get token from header\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return getErrorResponse(unauthorizedResponse('No token provided'));\n    }\n\n    const token = authHeader.substring(7);\n    const payload = verifyToken(token);\n\n    if (!payload) {\n        return getErrorResponse(unauthorizedResponse('Invalid or expired token'));\n    }\n\n    // Check required type\n    if (requiredType !== 'any' && payload.type !== requiredType) {\n        return getErrorResponse(forbiddenResponse(`Access restricted to ${requiredType}s`));\n    }\n\n    const authenticatedRequest = request as AuthenticatedRequest;\n    authenticatedRequest.tokenPayload = payload;\n\n    // For user tokens, load full user info\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            first_name: string;\n            last_name: string;\n            role_id: number;\n            role_code: string;\n            role_name: string;\n            permissions: string;\n            status: string;\n        }\n\n        const [userRow] = await query<UserRow[]>(\n            `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id,\n              r.code as role_code, r.name as role_name, r.permissions,\n              u.status\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return getErrorResponse(unauthorizedResponse('User not found or inactive'));\n        }\n\n        // Safely parse permissions - handle invalid JSON gracefully\n        let permissions: string[] = [];\n        try {\n            const rawPerms = userRow.permissions;\n            if (rawPerms && typeof rawPerms === 'string' && rawPerms.startsWith('[')) {\n                permissions = JSON.parse(rawPerms);\n            } else if (Array.isArray(rawPerms)) {\n                permissions = rawPerms;\n            }\n        } catch (e) {\n            console.warn('Invalid permissions JSON, defaulting to empty array');\n            permissions = [];\n        }\n\n        authenticatedRequest.user = {\n            id: userRow.id,\n            email: userRow.email,\n            firstName: userRow.first_name,\n            lastName: userRow.last_name,\n            roleId: userRow.role_id,\n            roleCode: userRow.role_code,\n            roleName: userRow.role_name,\n            permissions,\n            status: userRow.status,\n            mfaEnabled: false, // Simplified - no MFA\n        };\n\n        // Check required roles\n        if (requiredRoles && requiredRoles.length > 0) {\n            if (!requiredRoles.includes(userRow.role_code)) {\n                return getErrorResponse(forbiddenResponse('Insufficient role privileges'));\n            }\n        }\n\n        // Check required permissions\n        if (requiredPermissions && requiredPermissions.length > 0) {\n            const hasPermission = requiredPermissions.some((p) => permissions.includes(p));\n            if (!hasPermission) {\n                return getErrorResponse(forbiddenResponse('Insufficient permissions'));\n            }\n        }\n    }\n\n    // For customer tokens\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            customer_number: string;\n            email: string;\n            status: string;\n        }\n\n        const [customerRow] = await query<CustomerRow[]>(\n            `SELECT id, customer_number, email, status\n       FROM customers\n       WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return unauthorizedResponse('Customer not found or inactive');\n        }\n\n        authenticatedRequest.customer = {\n            id: customerRow.id,\n            customerNumber: customerRow.customer_number,\n            email: customerRow.email,\n        };\n    }\n\n    return handler(authenticatedRequest);\n}\n\n// =============================================================================\n// Validation Middleware\n// =============================================================================\n\nexport async function validateBody<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): Promise<{ success: true; data: T } | { success: false; response: NextResponse }> {\n    try {\n        const body = await request.json();\n        const data = schema.parse(body);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid request body') };\n    }\n}\n\nexport function validateQuery<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): { success: true; data: T } | { success: false; response: NextResponse } {\n    try {\n        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());\n        const data = schema.parse(searchParams);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid query parameters') };\n    }\n}\n\n// =============================================================================\n// Idempotency Middleware\n// =============================================================================\n\nexport function getIdempotencyKey(request: NextRequest): string | null {\n    return request.headers.get('Idempotency-Key') ||\n        request.headers.get('idempotency-key') ||\n        null;\n}\n\nexport function requireIdempotencyKey(request: NextRequest): { success: true; key: string } | { success: false; response: NextResponse } {\n    const key = getIdempotencyKey(request);\n    if (!key) {\n        return {\n            success: false,\n            response: errorResponse('Idempotency-Key header is required for this operation', 400)\n        };\n    }\n    // Validate UUID format\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(key)) {\n        return {\n            success: false,\n            response: errorResponse('Invalid Idempotency-Key format. Must be a valid UUID.', 400)\n        };\n    }\n    return { success: true, key };\n}\n\nexport async function checkIdempotency(\n    idempotencyKey: string | undefined\n): Promise<{ cached: true; response: NextResponse } | { cached: false }> {\n    if (!idempotencyKey) {\n        return { cached: false };\n    }\n\n    interface CachedRow extends RowDataPacket {\n        response_status: number;\n        response_body: string;\n    }\n\n    const [cached] = await query<CachedRow[]>(\n        `SELECT response_status, response_body\n     FROM idempotency_keys\n     WHERE idempotency_key = ? AND expires_at > NOW()`,\n        [idempotencyKey]\n    );\n\n    if (cached) {\n        const body = JSON.parse(cached.response_body);\n        return {\n            cached: true,\n            response: NextResponse.json(body, { status: cached.response_status }),\n        };\n    }\n\n    return { cached: false };\n}\n\n// =============================================================================\n// Error Handler Wrapper\n// =============================================================================\n\nexport function withErrorHandler<T = { id?: string }>(\n    handler: (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse>\n): (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse> {\n    return async (request: NextRequest, context?: { params: Promise<T> }) => {\n        try {\n            // Context is optional - routes without dynamic params won't have it\n            return await handler(request, context);\n        } catch (error) {\n            console.error('API Error:', error);\n\n            if (error instanceof Error) {\n                // Don't expose internal error messages in production\n                const message = process.env.NODE_ENV === 'development'\n                    ? error.message\n                    : 'An unexpected error occurred';\n                return serverErrorResponse(message);\n            }\n\n            return serverErrorResponse();\n        }\n    };\n}\n\n// =============================================================================\n// Pagination Helper\n// =============================================================================\n\nexport function getPaginationMeta(page: number, limit: number, total: number) {\n    return {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n    };\n}\n\nexport function getOffset(page: number, limit: number): number {\n    return (page - 1) * limit;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/app/api/v1/banker/accounts/search/route.ts"],"sourcesContent":["\nimport { NextRequest } from 'next/server';\nimport { withAuth, AuthenticatedRequest } from '@/lib/api-utils';\nimport { withErrorHandler, successResponse, errorResponse } from '@/lib/api-utils';\nimport { query } from '@/lib/db';\nimport { RowDataPacket } from 'mysql2/promise';\n\ninterface AccountSearchResult extends RowDataPacket {\n    id: number;\n    account_number: string;\n    account_type: string;\n    status: string;\n    currency: string;\n    customer_id: number;\n    customer_number: string;\n    customer_name: string;\n    available_balance: string;\n}\n\n/**\n * GET /api/v1/banker/accounts/search?q=<account_number_or_customer_name>\n * Search for accounts by account number or customer name\n */\nexport const GET = withErrorHandler(async (request: NextRequest) => {\n    return withAuth(request, async (req: AuthenticatedRequest) => {\n        const { user } = req;\n        if (!user || (user.roleCode !== 'BANKER' && user.roleCode !== 'ADMIN')) {\n            return errorResponse('Unauthorized', 403);\n        }\n\n        const searchParams = request.nextUrl.searchParams;\n        const q = searchParams.get('q') || '';\n\n        if (q.length < 2) {\n            return successResponse({ accounts: [] });\n        }\n\n        // Search by account number or customer name\n        // Exclude system/internal accounts\n        // Trim query and ensure robust partial matching\n        const cleanQuery = q.trim();\n\n        const accounts: AccountSearchResult[] = await query<AccountSearchResult[]>(`\n            SELECT \n                a.id,\n                a.account_number,\n                at.code as account_type,\n                a.status,\n                COALESCE(ab.currency, 'BDT') as currency,\n                c.id as customer_id,\n                c.customer_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                COALESCE(ab.available_balance, 0) as available_balance\n            FROM accounts a\n            JOIN customers c ON a.customer_id = c.id\n            JOIN account_types at ON at.id = a.account_type_id\n            LEFT JOIN account_balances ab ON a.id = ab.account_id\n            WHERE \n                at.code != 'INTERNAL'\n                AND c.customer_number != 'SYSTEM-BANK'\n                AND (\n                    a.account_number LIKE ?\n                    OR c.first_name LIKE ?\n                    OR c.last_name LIKE ?\n                    OR c.customer_number LIKE ?\n                )\n            ORDER BY a.account_number\n            LIMIT 50\n        `, [`%${cleanQuery}%`, `%${cleanQuery}%`, `%${cleanQuery}%`, `%${cleanQuery}%`]);\n\n        return successResponse({\n            accounts: accounts.map(a => ({\n                id: a.id,\n                accountNumber: a.account_number,\n                accountType: a.account_type,\n                status: a.status,\n                currency: a.currency,\n                customerId: a.customer_id,\n                customerNumber: a.customer_number,\n                customerName: a.customer_name,\n                availableBalance: parseFloat(a.available_balance)\n            }))\n        });\n\n    }, { requiredRoles: ['BANKER', 'ADMIN'], hideFailure: true });\n});\n"],"names":[],"mappings":";;;;AAEA;AAEA;;;;AAmBO,MAAM,MAAM,IAAA,gJAAgB,EAAC,OAAO;IACvC,OAAO,IAAA,wIAAQ,EAAC,SAAS,OAAO;QAC5B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,IAAI,CAAC,QAAS,KAAK,QAAQ,KAAK,YAAY,KAAK,QAAQ,KAAK,SAAU;YACpE,OAAO,IAAA,6IAAa,EAAC,gBAAgB;QACzC;QAEA,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,IAAI,aAAa,GAAG,CAAC,QAAQ;QAEnC,IAAI,EAAE,MAAM,GAAG,GAAG;YACd,OAAO,IAAA,+IAAe,EAAC;gBAAE,UAAU,EAAE;YAAC;QAC1C;QAEA,4CAA4C;QAC5C,mCAAmC;QACnC,gDAAgD;QAChD,MAAM,aAAa,EAAE,IAAI;QAEzB,MAAM,WAAkC,MAAM,IAAA,2HAAK,EAAwB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;QA0B5E,CAAC,EAAE;YAAC,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;YAAE,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;YAAE,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;YAAE,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;SAAC;QAE/E,OAAO,IAAA,+IAAe,EAAC;YACnB,UAAU,SAAS,GAAG,CAAC,CAAA,IAAK,CAAC;oBACzB,IAAI,EAAE,EAAE;oBACR,eAAe,EAAE,cAAc;oBAC/B,aAAa,EAAE,YAAY;oBAC3B,QAAQ,EAAE,MAAM;oBAChB,UAAU,EAAE,QAAQ;oBACpB,YAAY,EAAE,WAAW;oBACzB,gBAAgB,EAAE,eAAe;oBACjC,cAAc,EAAE,aAAa;oBAC7B,kBAAkB,WAAW,EAAE,iBAAiB;gBACpD,CAAC;QACL;IAEJ,GAAG;QAAE,eAAe;YAAC;YAAU;SAAQ;QAAE,aAAa;IAAK;AAC/D"}}]
}