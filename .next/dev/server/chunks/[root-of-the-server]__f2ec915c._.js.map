{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/lib/services/auth-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface User {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    roleId: number;\n    roleCode: string;\n    roleName: string;\n    permissions: string[];\n    status: string;\n    mfaEnabled: boolean;\n}\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    status: string;\n    kycStatus: string;\n}\n\nexport interface TokenPayload {\n    sub: string;\n    type: 'user' | 'customer';\n    email: string;\n    role?: string;\n    permissions?: string[];\n    tokenVersion: number;\n    iat: number;\n    exp: number;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User | Customer;\n    token?: string;\n    refreshToken?: string;\n    error?: string;\n}\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\nconst BCRYPT_ROUNDS = 12;\nconst MAX_FAILED_ATTEMPTS = 5;\n\n// =============================================================================\n// Password Management\n// =============================================================================\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// =============================================================================\n// JWT Token Management\n// =============================================================================\n\nexport function generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n}\n\nexport function generateRefreshToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)({ ...payload, refresh: true }, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n}\n\nexport function verifyToken(token: string): TokenPayload | null {\n    try {\n        return jwt.verify(token, JWT_SECRET) as TokenPayload;\n    } catch {\n        return null;\n    }\n}\n\n// =============================================================================\n// User Authentication\n// =============================================================================\n\nexport async function authenticateUser(email: string, password: string): Promise<AuthResult> {\n    interface UserRow extends RowDataPacket {\n        id: number;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        role_id: number;\n        role_code: string;\n        role_name: string;\n        permissions: string;\n        status: string;\n    }\n\n    const userRow = await queryOne<UserRow>(\n        `SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,\n            u.role_id, r.code as role_code, r.name as role_name, r.permissions,\n            u.status\n     FROM users u\n     INNER JOIN roles r ON r.id = u.role_id\n     WHERE u.email = ?`,\n        [email]\n    );\n\n    if (!userRow) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    if (userRow.status !== 'ACTIVE') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, userRow.password_hash);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    // Update last login\n    await execute(\n        'UPDATE users SET last_login_at = NOW() WHERE id = ?',\n        [userRow.id]\n    );\n\n    // Parse permissions (MySQL may return JSON as already-parsed array)\n    const permissions = Array.isArray(userRow.permissions)\n        ? userRow.permissions as string[]\n        : JSON.parse(userRow.permissions || '[]') as string[];\n\n    const user: User = {\n        id: userRow.id,\n        email: userRow.email,\n        firstName: userRow.first_name,\n        lastName: userRow.last_name,\n        roleId: userRow.role_id,\n        roleCode: userRow.role_code,\n        roleName: userRow.role_name,\n        permissions,\n        status: userRow.status,\n        mfaEnabled: false, // Simplified - no MFA\n    };\n\n    // Generate tokens\n    const token = generateToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        permissions,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user, token, refreshToken };\n}\n\n// =============================================================================\n// Customer Authentication\n// =============================================================================\n\nexport async function authenticateCustomer(email: string, password: string): Promise<AuthResult> {\n    interface CustomerRow extends RowDataPacket {\n        id: number;\n        customer_number: string;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        status: string;\n        kyc_status: string;\n    }\n\n    const customerRow = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, password_hash, first_name, last_name,\n            status, kyc_status\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!customerRow) {\n        console.log(`[Auth] Customer not found: ${email}`);\n        return { success: false, error: 'Invalid email or password' };\n    }\n    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);\n\n    if (customerRow.status === 'SUSPENDED') {\n        return { success: false, error: 'Account is suspended. Please contact support.' };\n    }\n\n    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, customerRow.password_hash);\n    console.log(`[Auth] Password valid: ${passwordValid}`);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    const customer: Customer = {\n        id: customerRow.id,\n        customerNumber: customerRow.customer_number,\n        email: customerRow.email,\n        firstName: customerRow.first_name,\n        lastName: customerRow.last_name,\n        status: customerRow.status,\n        kycStatus: customerRow.kyc_status,\n    };\n\n    const token = generateToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user: customer, token, refreshToken };\n}\n\n// =============================================================================\n// Token Refresh\n// =============================================================================\n\nexport async function refreshAccessToken(refreshToken: string): Promise<AuthResult> {\n    const payload = verifyToken(refreshToken);\n\n    if (!payload) {\n        return { success: false, error: 'Invalid refresh token' };\n    }\n\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            role_code: string;\n            permissions: string;\n        }\n\n        const userRow = await queryOne<UserRow>(\n            `SELECT u.id, u.email, r.code as role_code, r.permissions\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return { success: false, error: 'User not found or inactive' };\n        }\n\n        const permissions = Array.isArray(userRow.permissions)\n            ? userRow.permissions as string[]\n            : JSON.parse(userRow.permissions || '[]') as string[];\n\n        const newToken = generateToken({\n            sub: userRow.id.toString(),\n            type: 'user',\n            email: userRow.email,\n            role: userRow.role_code,\n            permissions,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            email: string;\n        }\n\n        const customerRow = await queryOne<CustomerRow>(\n            `SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return { success: false, error: 'Customer not found or inactive' };\n        }\n\n        const newToken = generateToken({\n            sub: customerRow.id.toString(),\n            type: 'customer',\n            email: customerRow.email,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    return { success: false, error: 'Invalid token type' };\n}\n\n// =============================================================================\n// User Management\n// =============================================================================\n\nexport async function createUser(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    roleId: number,\n    createdBy?: number\n): Promise<{ success: boolean; userId?: number; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`,\n            [email, passwordHash, firstName, lastName, roleId, createdBy ?? null]\n        );\n\n        return { success: true, userId: result.insertId };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\nexport async function createCustomer(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    createdBy?: number\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?)`,\n            [customerNumber, email, passwordHash, firstName, lastName, createdBy ?? null]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\n// =============================================================================\n// Authorization Helpers\n// =============================================================================\n\nexport function hasPermission(user: User, permission: string): boolean {\n    return user.permissions.includes(permission);\n}\n\nexport function hasAnyPermission(user: User, permissions: string[]): boolean {\n    return permissions.some((p) => user.permissions.includes(p));\n}\n\nexport function hasAllPermissions(user: User, permissions: string[]): boolean {\n    return permissions.every((p) => user.permissions.includes(p));\n}\n\nexport function isRole(user: User, role: string): boolean {\n    return user.roleCode === role;\n}\n\nexport function isAnyRole(user: User, roles: string[]): boolean {\n    return roles.includes(user.roleCode);\n}\n\n// =============================================================================\n// Logout / Global Sign Out\n// =============================================================================\n\nexport async function logout(userId: number, type: 'user' | 'customer'): Promise<void> {\n    const table = type === 'user' ? 'users' : 'customers';\n    // Increment token version to invalidate all existing tokens\n    await execute(\n        `UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`,\n        [userId]\n    );\n\n    // Also remove any active sessions\n    if (type === 'user') {\n        await execute('DELETE FROM user_sessions WHERE user_id = ?', [userId]);\n    }\n}\n\n// =============================================================================\n// Session Helper for Next.js App Router\n// =============================================================================\n\nimport { cookies, headers } from 'next/headers';\n\nexport async function getSession(): Promise<{ user?: User | Customer; role?: string } | null> {\n    try {\n        const cookieStore = await cookies();\n        const headerList = await headers();\n\n        let token = cookieStore.get('token')?.value;\n\n        if (!token) {\n            const authHeader = headerList.get('Authorization');\n            if (authHeader?.startsWith('Bearer ')) {\n                token = authHeader.substring(7);\n            }\n        }\n\n        if (!token) return null;\n\n        const payload = verifyToken(token);\n        if (!payload) return null;\n\n        if (payload.type === 'user') {\n            const userRow = await queryOne<RowDataPacket & User>(\n                `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status\n             FROM users u\n             JOIN roles r ON r.id = u.role_id\n             WHERE u.id = ?`,\n                [payload.sub]\n            );\n            if (!userRow) return null;\n\n            const permissions = Array.isArray(userRow.permissions)\n                ? userRow.permissions as string[]\n                : JSON.parse((userRow.permissions as any) || '[]') as string[];\n\n            return {\n                user: { ...userRow, firstName: userRow.first_name, lastName: userRow.last_name, roleId: userRow.role_id, roleCode: userRow.role_code, roleName: userRow.role_name, permissions, mfaEnabled: false },\n                role: userRow.role_code\n            };\n        }\n\n        if (payload.type === 'customer') {\n            const customerRow = await queryOne<RowDataPacket & Customer>(\n                `SELECT id, customer_number, email, first_name, last_name, status, kyc_status\n             FROM customers WHERE id = ?`,\n                [payload.sub]\n            );\n            if (!customerRow) return null;\n\n            return {\n                user: { ...customerRow, customerNumber: customerRow.customer_number, firstName: customerRow.first_name, lastName: customerRow.last_name, kycStatus: customerRow.kyc_status },\n                role: 'CUSTOMER'\n            };\n        }\n\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/lib/api-utils.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { verifyToken, TokenPayload, User } from '@/lib/services/auth-service';\nimport { query } from '@/lib/db';\nimport { RowDataPacket } from 'mysql2/promise';\nimport { ZodSchema, ZodError } from 'zod';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface AuthenticatedRequest extends NextRequest {\n    user?: User;\n    customer?: {\n        id: number;\n        customerNumber: string;\n        email: string;\n    };\n    tokenPayload?: TokenPayload;\n}\n\nexport interface ApiResponse<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: string;\n    errors?: Array<{ field: string; message: string }>;\n    meta?: {\n        page?: number;\n        limit?: number;\n        total?: number;\n        totalPages?: number;\n    };\n}\n\n// =============================================================================\n// Response Helpers\n// =============================================================================\n\nexport function successResponse<T>(data: T, meta?: ApiResponse['meta']): NextResponse {\n    return NextResponse.json({ success: true, data, meta }, { status: 200 });\n}\n\nexport function createdResponse<T>(data: T): NextResponse {\n    return NextResponse.json({ success: true, data }, { status: 201 });\n}\n\nexport function errorResponse(error: string, status: number = 400): NextResponse {\n    return NextResponse.json({ success: false, error }, { status });\n}\n\nexport function validationErrorResponse(errors: Array<{ field: string; message: string }>): NextResponse {\n    return NextResponse.json({ success: false, error: 'Validation failed', errors }, { status: 400 });\n}\n\nexport function unauthorizedResponse(error: string = 'Unauthorized'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 401 });\n}\n\nexport function forbiddenResponse(error: string = 'Forbidden'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 403 });\n}\n\nexport function notFoundResponse(error: string = 'Not found'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 404 });\n}\n\nexport function serverErrorResponse(error: string = 'Internal server error'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 500 });\n}\n\n// =============================================================================\n// Authentication Middleware\n// =============================================================================\n\nexport async function withAuth(\n    request: NextRequest,\n    handler: (req: AuthenticatedRequest) => Promise<NextResponse>,\n    options: {\n        requiredType?: 'user' | 'customer' | 'any';\n        requiredRoles?: string[];\n        requiredPermissions?: string[];\n        hideFailure?: boolean; // If true, returns 404 instead of 401/403 to hide existence\n    } = {}\n): Promise<NextResponse> {\n    const { requiredType = 'any', requiredRoles, requiredPermissions, hideFailure = false } = options;\n\n    // Helper to return 404 if hideFailure is on, otherwise the actual error\n    const getErrorResponse = (actualResponse: NextResponse) => {\n        return hideFailure ? notFoundResponse() : actualResponse;\n    };\n\n    // Get token from header\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return getErrorResponse(unauthorizedResponse('No token provided'));\n    }\n\n    const token = authHeader.substring(7);\n    const payload = verifyToken(token);\n\n    if (!payload) {\n        return getErrorResponse(unauthorizedResponse('Invalid or expired token'));\n    }\n\n    // Check required type\n    if (requiredType !== 'any' && payload.type !== requiredType) {\n        return getErrorResponse(forbiddenResponse(`Access restricted to ${requiredType}s`));\n    }\n\n    const authenticatedRequest = request as AuthenticatedRequest;\n    authenticatedRequest.tokenPayload = payload;\n\n    // For user tokens, load full user info\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            first_name: string;\n            last_name: string;\n            role_id: number;\n            role_code: string;\n            role_name: string;\n            permissions: string;\n            status: string;\n        }\n\n        const [userRow] = await query<UserRow[]>(\n            `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id,\n              r.code as role_code, r.name as role_name, r.permissions,\n              u.status\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return getErrorResponse(unauthorizedResponse('User not found or inactive'));\n        }\n\n        // Safely parse permissions - handle invalid JSON gracefully\n        let permissions: string[] = [];\n        try {\n            const rawPerms = userRow.permissions;\n            if (rawPerms && typeof rawPerms === 'string' && rawPerms.startsWith('[')) {\n                permissions = JSON.parse(rawPerms);\n            } else if (Array.isArray(rawPerms)) {\n                permissions = rawPerms;\n            }\n        } catch (e) {\n            console.warn('Invalid permissions JSON, defaulting to empty array');\n            permissions = [];\n        }\n\n        authenticatedRequest.user = {\n            id: userRow.id,\n            email: userRow.email,\n            firstName: userRow.first_name,\n            lastName: userRow.last_name,\n            roleId: userRow.role_id,\n            roleCode: userRow.role_code,\n            roleName: userRow.role_name,\n            permissions,\n            status: userRow.status,\n            mfaEnabled: false, // Simplified - no MFA\n        };\n\n        // Check required roles\n        if (requiredRoles && requiredRoles.length > 0) {\n            if (!requiredRoles.includes(userRow.role_code)) {\n                return getErrorResponse(forbiddenResponse('Insufficient role privileges'));\n            }\n        }\n\n        // Check required permissions\n        if (requiredPermissions && requiredPermissions.length > 0) {\n            const hasPermission = requiredPermissions.some((p) => permissions.includes(p));\n            if (!hasPermission) {\n                return getErrorResponse(forbiddenResponse('Insufficient permissions'));\n            }\n        }\n    }\n\n    // For customer tokens\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            customer_number: string;\n            email: string;\n            status: string;\n        }\n\n        const [customerRow] = await query<CustomerRow[]>(\n            `SELECT id, customer_number, email, status\n       FROM customers\n       WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return unauthorizedResponse('Customer not found or inactive');\n        }\n\n        authenticatedRequest.customer = {\n            id: customerRow.id,\n            customerNumber: customerRow.customer_number,\n            email: customerRow.email,\n        };\n    }\n\n    return handler(authenticatedRequest);\n}\n\n// =============================================================================\n// Validation Middleware\n// =============================================================================\n\nexport async function validateBody<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): Promise<{ success: true; data: T } | { success: false; response: NextResponse }> {\n    try {\n        const body = await request.json();\n        const data = schema.parse(body);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid request body') };\n    }\n}\n\nexport function validateQuery<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): { success: true; data: T } | { success: false; response: NextResponse } {\n    try {\n        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());\n        const data = schema.parse(searchParams);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid query parameters') };\n    }\n}\n\n// =============================================================================\n// Idempotency Middleware\n// =============================================================================\n\nexport function getIdempotencyKey(request: NextRequest): string | null {\n    return request.headers.get('Idempotency-Key') ||\n        request.headers.get('idempotency-key') ||\n        null;\n}\n\nexport function requireIdempotencyKey(request: NextRequest): { success: true; key: string } | { success: false; response: NextResponse } {\n    const key = getIdempotencyKey(request);\n    if (!key) {\n        return {\n            success: false,\n            response: errorResponse('Idempotency-Key header is required for this operation', 400)\n        };\n    }\n    // Validate UUID format\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(key)) {\n        return {\n            success: false,\n            response: errorResponse('Invalid Idempotency-Key format. Must be a valid UUID.', 400)\n        };\n    }\n    return { success: true, key };\n}\n\nexport async function checkIdempotency(\n    idempotencyKey: string | undefined\n): Promise<{ cached: true; response: NextResponse } | { cached: false }> {\n    if (!idempotencyKey) {\n        return { cached: false };\n    }\n\n    interface CachedRow extends RowDataPacket {\n        response_status: number;\n        response_body: string;\n    }\n\n    const [cached] = await query<CachedRow[]>(\n        `SELECT response_status, response_body\n     FROM idempotency_keys\n     WHERE idempotency_key = ? AND expires_at > NOW()`,\n        [idempotencyKey]\n    );\n\n    if (cached) {\n        const body = JSON.parse(cached.response_body);\n        return {\n            cached: true,\n            response: NextResponse.json(body, { status: cached.response_status }),\n        };\n    }\n\n    return { cached: false };\n}\n\n// =============================================================================\n// Error Handler Wrapper\n// =============================================================================\n\nexport function withErrorHandler<T = { id?: string }>(\n    handler: (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse>\n): (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse> {\n    return async (request: NextRequest, context?: { params: Promise<T> }) => {\n        try {\n            // Context is optional - routes without dynamic params won't have it\n            return await handler(request, context);\n        } catch (error) {\n            console.error('API Error:', error);\n\n            if (error instanceof Error) {\n                // Don't expose internal error messages in production\n                const message = process.env.NODE_ENV === 'development'\n                    ? error.message\n                    : 'An unexpected error occurred';\n                return serverErrorResponse(message);\n            }\n\n            return serverErrorResponse();\n        }\n    };\n}\n\n// =============================================================================\n// Pagination Helper\n// =============================================================================\n\nexport function getPaginationMeta(page: number, limit: number, total: number) {\n    return {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n    };\n}\n\nexport function getOffset(page: number, limit: number): number {\n    return (page - 1) * limit;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/lib/services/statement-service.ts"],"sourcesContent":["import { query, queryOne } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\nimport { PDFDocument, StandardFonts, rgb } from 'pdf-lib';\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface StatementEntry {\n    id: number;\n    date: Date;\n    description: string | null;\n    debit: number | null;\n    credit: number | null;\n    runningBalance: number;\n    transactionReference: string;\n    transactionType: string;\n}\n\nexport interface AccountStatement {\n    account: {\n        id: number;\n        accountNumber: string;\n        accountType: string;\n        customerName: string;\n    };\n    period: {\n        from: string;\n        to: string;\n    };\n    openingBalance: number;\n    closingBalance: number;\n    totalDebits: number;\n    totalCredits: number;\n    entries: StatementEntry[];\n}\n\nexport interface StatementOptions {\n    from: string; // YYYY-MM-DD\n    to: string;   // YYYY-MM-DD\n    page?: number;\n    size?: number;\n}\n\nexport interface TransactionSearchFilters {\n    from?: string;\n    to?: string;\n    amountMin?: number;\n    amountMax?: number;\n    entryType?: 'DEBIT' | 'CREDIT';\n    transactionType?: string;\n    reference?: string;\n    accountId?: number;\n    includeReversals?: boolean;\n    page?: number;\n    size?: number;\n}\n\nexport interface SearchResult {\n    id: number;\n    transactionReference: string;\n    transactionType: string;\n    accountId: number;\n    accountNumber: string;\n    entryType: 'DEBIT' | 'CREDIT';\n    amount: number;\n    balanceAfter: number;\n    description: string | null;\n    entryDate: Date;\n    createdAt: Date;\n    isReversal: boolean;\n}\n\n// =============================================================================\n// Statement Generation\n// =============================================================================\n\ninterface LedgerRow extends RowDataPacket {\n    id: number;\n    transaction_id: number;\n    account_id: number;\n    entry_type: 'DEBIT' | 'CREDIT';\n    amount: string;\n    currency: string;\n    balance_after: string;\n    description: string | null;\n    entry_date: Date;\n    created_at: Date;\n    transaction_reference: string;\n    transaction_type: string;\n}\n\ninterface AccountRow extends RowDataPacket {\n    id: number;\n    account_number: string;\n    account_type_name: string;\n    customer_name: string;\n}\n\ninterface BalanceRow extends RowDataPacket {\n    total_credits: string;\n    total_debits: string;\n}\n\nexport async function getAccountStatement(\n    accountId: number,\n    options: StatementOptions\n): Promise<{ statement: AccountStatement; total: number }> {\n    const { from, to, page = 1, size = 50 } = options;\n    const offset = (page - 1) * size;\n\n    // Get account info\n    const account = await queryOne<AccountRow>(\n        `SELECT a.id, a.account_number, at.name as account_type_name,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name\n         FROM accounts a\n         JOIN customers c ON a.customer_id = c.id\n         JOIN account_types at ON at.id = a.account_type_id\n         WHERE a.id = ?`,\n        [accountId]\n    );\n\n    if (!account) {\n        throw new Error('Account not found');\n    }\n\n    // Calculate opening balance (sum of all entries before the period start)\n    const openingBalanceRow = await queryOne<BalanceRow>(\n        `SELECT \n            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,\n            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits\n         FROM ledger_entries\n         WHERE account_id = ? AND entry_date < ?`,\n        [accountId, from]\n    );\n\n    const openingBalance =\n        parseFloat(openingBalanceRow?.total_credits || '0') -\n        parseFloat(openingBalanceRow?.total_debits || '0');\n\n    // Get total count of entries in period\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count\n         FROM ledger_entries le\n         WHERE le.account_id = ? AND le.entry_date >= ? AND le.entry_date <= ?`,\n        [accountId, from, to]\n    );\n    const total = countRow?.count || 0;\n\n    // Get period totals for closing balance calculation\n    const periodTotals = await queryOne<BalanceRow>(\n        `SELECT \n            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,\n            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits\n         FROM ledger_entries\n         WHERE account_id = ? AND entry_date >= ? AND entry_date <= ?`,\n        [accountId, from, to]\n    );\n\n    const totalCredits = parseFloat(periodTotals?.total_credits || '0');\n    const totalDebits = parseFloat(periodTotals?.total_debits || '0');\n    const closingBalance = openingBalance + totalCredits - totalDebits;\n\n    // Get ledger entries for period (ordered by created_at ASC for running balance)\n    const rows = await query<LedgerRow[]>(\n        `SELECT le.id, le.transaction_id, le.account_id, le.entry_type, \n                le.amount, le.currency, le.balance_after, le.description,\n                le.entry_date, le.created_at, t.transaction_reference,\n                tt.code as transaction_type\n         FROM ledger_entries le\n         JOIN transactions t ON le.transaction_id = t.id\n         JOIN transaction_types tt ON t.transaction_type_id = tt.id\n         WHERE le.account_id = ? AND le.entry_date >= ? AND le.entry_date <= ?\n         ORDER BY le.created_at ASC, le.id ASC\n         LIMIT ? OFFSET ?`,\n        [accountId, from, to, size, offset]\n    );\n\n    // Compute running balance for paginated entries\n    // For running balance, we need to know the balance at the start of this page\n    let runningBalance = openingBalance;\n\n    // If we're not on page 1, calculate the balance up to this page\n    if (page > 1) {\n        const previousTotals = await queryOne<BalanceRow>(\n            `SELECT \n                COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,\n                COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits\n             FROM (\n                SELECT entry_type, amount\n                FROM ledger_entries\n                WHERE account_id = ? AND entry_date >= ? AND entry_date <= ?\n                ORDER BY created_at ASC, id ASC\n                LIMIT ?\n             ) as previous_entries`,\n            [accountId, from, to, offset]\n        );\n        runningBalance = openingBalance +\n            parseFloat(previousTotals?.total_credits || '0') -\n            parseFloat(previousTotals?.total_debits || '0');\n    }\n\n    const entries: StatementEntry[] = rows.map((row) => {\n        const amount = parseFloat(row.amount);\n        if (row.entry_type === 'CREDIT') {\n            runningBalance += amount;\n        } else {\n            runningBalance -= amount;\n        }\n\n        return {\n            id: row.id,\n            date: row.entry_date,\n            description: row.description,\n            debit: row.entry_type === 'DEBIT' ? amount : null,\n            credit: row.entry_type === 'CREDIT' ? amount : null,\n            runningBalance: Math.round(runningBalance * 100) / 100, // Round to 2 decimal places\n            transactionReference: row.transaction_reference,\n            transactionType: row.transaction_type,\n        };\n    });\n\n    return {\n        statement: {\n            account: {\n                id: account.id,\n                accountNumber: account.account_number,\n                accountType: account.account_type_name,\n                customerName: account.customer_name,\n            },\n            period: { from, to },\n            openingBalance: Math.round(openingBalance * 100) / 100,\n            closingBalance: Math.round(closingBalance * 100) / 100,\n            totalDebits: Math.round(totalDebits * 100) / 100,\n            totalCredits: Math.round(totalCredits * 100) / 100,\n            entries,\n        },\n        total,\n    };\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction maskAccountNumber(accountNumber: string): string {\n    if (accountNumber.length <= 4) return accountNumber;\n    return '****' + accountNumber.slice(-4);\n}\n\nfunction formatCurrency(amount: number): string {\n    return new Intl.NumberFormat('en-BD', {\n        style: 'currency',\n        currency: 'BDT',\n        minimumFractionDigits: 2,\n    }).format(amount);\n}\n\nfunction formatDate(date: Date): string {\n    return new Intl.DateTimeFormat('en-GB', {\n        day: '2-digit',\n        month: 'short',\n        year: 'numeric',\n    }).format(new Date(date));\n}\n\n// =============================================================================\n// PDF Generation\n// =============================================================================\n\nexport async function generateStatementPdf(\n    accountId: number,\n    from: string, // YYYY-MM-DD\n    to: string     // YYYY-MM-DD\n): Promise<Buffer> {\n    // Get all entries for the date range\n    const { statement } = await getAccountStatement(accountId, {\n        from,\n        to,\n        page: 1,\n        size: 10000,\n    });\n\n    // Create a new PDFDocument\n    const pdfDoc = await PDFDocument.create();\n    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n    const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\n\n    let page = pdfDoc.addPage([595.28, 841.89]); // A4\n    const { width, height } = page.getSize();\n    const margin = 50;\n\n    let y = height - margin;\n\n    // Helper to add new page\n    const addNewPage = () => {\n        page = pdfDoc.addPage([595.28, 841.89]);\n        y = height - margin;\n        return page;\n    };\n\n    // Helper to draw text\n    const drawText = (text: string, x: number, currentY: number, size = 10, f = font, color = rgb(0, 0, 0)) => {\n        page.drawText(text, {\n            x,\n            y: currentY,\n            size,\n            font: f,\n            color,\n        });\n    };\n\n    // Simple Black & White Design\n    const primaryColor = rgb(0, 0, 0);\n    const secondaryColor = rgb(0.3, 0.3, 0.3);\n\n    // Header\n    const title = 'BNKCORE';\n    const titleWidth = fontBold.widthOfTextAtSize(title, 22);\n    drawText(title, (width - titleWidth) / 2, y, 22, fontBold);\n    y -= 25;\n\n    const subtitle = 'Core Banking System';\n    const subtitleWidth = font.widthOfTextAtSize(subtitle, 10);\n    drawText(subtitle, (width - subtitleWidth) / 2, y, 10, font);\n    y -= 35;\n\n    const reportTitle = 'Account Statement';\n    const reportTitleWidth = fontBold.widthOfTextAtSize(reportTitle, 16);\n    drawText(reportTitle, (width - reportTitleWidth) / 2, y, 16, fontBold);\n    y -= 45;\n\n    // Account Information\n    const infoY = y;\n    drawText('Account Holder:', margin, y, 10, fontBold);\n    drawText(statement.account.customerName, margin + 90, y, 10, font);\n    y -= 18;\n    drawText('Account Number:', margin, y, 10, fontBold);\n    // Display full account number\n    drawText(statement.account.accountNumber, margin + 90, y, 10, font);\n    y -= 18;\n    drawText('Account Type:', margin, y, 10, fontBold);\n    drawText(statement.account.accountType, margin + 90, y, 10, font);\n\n    drawText('Statement Period:', 320, infoY, 10, fontBold);\n    drawText(`${formatDate(new Date(from))} - ${formatDate(new Date(to))}`, 410, infoY, 10, font);\n    drawText('Generated:', 320, infoY - 18, 10, fontBold);\n    drawText(formatDate(new Date()), 410, infoY - 18, 10, font);\n\n    y -= 50;\n\n    // Summary Box\n    page.drawRectangle({\n        x: margin,\n        y: y - 55,\n        width: width - 2 * margin,\n        height: 65,\n        borderColor: rgb(0, 0, 0),\n        borderWidth: 1,\n    });\n\n    const summaryY1 = y - 20;\n    const summaryY2 = y - 45;\n\n    drawText('Opening Balance:', margin + 15, summaryY1, 10, fontBold);\n    drawText(formatCurrency(statement.openingBalance), margin + 110, summaryY1, 10, fontBold);\n\n    drawText('Total Credits:', margin + 260, summaryY1, 10, fontBold);\n    drawText(formatCurrency(statement.totalCredits), margin + 350, summaryY1, 10, fontBold);\n\n    drawText('Closing Balance:', margin + 15, summaryY2, 10, fontBold);\n    drawText(formatCurrency(statement.closingBalance), margin + 110, summaryY2, 10, fontBold);\n\n    drawText('Total Debits:', margin + 260, summaryY2, 10, fontBold);\n    drawText(formatCurrency(statement.totalDebits), margin + 350, summaryY2, 10, fontBold);\n\n    y -= 90;\n\n    // Table Column Definitions\n    const colDate = margin;\n    const colDesc = margin + 75;\n    const colDebit = margin + 250;\n    const colCredit = margin + 330;\n    const colBalance = margin + 415;\n    const colWidths = { debit: 70, credit: 70, balance: 80 };\n\n    const drawTableHeader = (currentY: number) => {\n        page.drawRectangle({\n            x: margin,\n            y: currentY - 18,\n            width: width - 2 * margin,\n            height: 25,\n            color: rgb(0.9, 0.9, 0.9),\n        });\n        const headerTextY = currentY - 3;\n        drawText('Date', colDate + 5, headerTextY, 9, fontBold);\n        drawText('Description', colDesc, headerTextY, 9, fontBold);\n\n        const drawRightText = (text: string, x: number, targetWidth: number, currentYInner: number, size = 9, f = fontBold) => {\n            const textWidth = f.widthOfTextAtSize(text, size);\n            drawText(text, x + targetWidth - textWidth - 5, currentYInner, size, f);\n        };\n\n        drawRightText('Debit', colDebit, colWidths.debit, headerTextY);\n        drawRightText('Credit', colCredit, colWidths.credit, headerTextY);\n        drawRightText('Balance', colBalance, colWidths.balance, headerTextY);\n    };\n\n    drawTableHeader(y);\n    y -= 30;\n\n    const drawRowRightText = (text: string, x: number, targetWidth: number, currentY: number, size = 8, f = font) => {\n        const textWidth = f.widthOfTextAtSize(text, size);\n        drawText(text, x + targetWidth - textWidth - 5, currentY, size, f);\n    };\n\n    // Opening Balance Row\n    drawText(formatDate(new Date(from)), colDate + 5, y, 8, fontBold);\n    drawText('Opening Balance', colDesc, y, 8, fontBold);\n    drawRowRightText(formatCurrency(statement.openingBalance), colBalance, colWidths.balance, y, 8, fontBold);\n    y -= 18;\n\n    // Transaction rows\n    for (const entry of statement.entries) {\n        if (y < margin + 60) {\n            addNewPage();\n            drawTableHeader(y);\n            y -= 30;\n        }\n\n        const index = statement.entries.indexOf(entry);\n        if (index % 2 === 1) {\n            page.drawRectangle({\n                x: margin,\n                y: y - 5,\n                width: width - 2 * margin,\n                height: 18,\n                color: rgb(0.98, 0.98, 0.98),\n            });\n        }\n\n        drawText(formatDate(entry.date), colDate + 5, y, 8, font, secondaryColor);\n        const desc = entry.description || entry.transactionType;\n        drawText(desc.length > 35 ? desc.substring(0, 32) + '...' : desc, colDesc, y, 8, font);\n\n        if (entry.debit) {\n            drawRowRightText(formatCurrency(entry.debit), colDebit, colWidths.debit, y, 8, font);\n        }\n        if (entry.credit) {\n            drawRowRightText(formatCurrency(entry.credit), colCredit, colWidths.credit, y, 8, font);\n        }\n\n        drawRowRightText(formatCurrency(entry.runningBalance), colBalance, colWidths.balance, y, 8, font);\n\n        y -= 18;\n    }\n\n    // Closing Balance Row\n    if (y < margin + 40) {\n        addNewPage();\n        drawTableHeader(y);\n        y -= 30;\n    }\n    y -= 5;\n    drawText(formatDate(new Date(to)), colDate + 5, y, 8, fontBold);\n    drawText('Closing Balance', colDesc, y, 8, fontBold);\n    drawRowRightText(formatCurrency(statement.closingBalance), colBalance, colWidths.balance, y, 8, fontBold);\n\n    // Footer\n    const pages = pdfDoc.getPages();\n    for (let i = 0; i < pages.length; i++) {\n        const p = pages[i];\n        const footerText = `Page ${i + 1} of ${pages.length} | This is a computer-generated document and does not require signature.`;\n        const footerWidth = font.widthOfTextAtSize(footerText, 8);\n        p.drawText(footerText, {\n            x: (width - footerWidth) / 2,\n            y: 30,\n            size: 8,\n            font: font,\n            color: rgb(0, 0, 0),\n        });\n    }\n\n    const pdfBytes = await pdfDoc.save();\n    return Buffer.from(pdfBytes);\n}\n\n// =============================================================================\n// Transaction Search (Banker/Admin)\n// =============================================================================\n\ninterface SearchRow extends RowDataPacket {\n    id: number;\n    transaction_reference: string;\n    transaction_type: string;\n    account_id: number;\n    account_number: string;\n    entry_type: 'DEBIT' | 'CREDIT';\n    amount: string;\n    balance_after: string;\n    description: string | null;\n    entry_date: Date;\n    created_at: Date;\n    is_reversal: boolean;\n}\n\nexport async function searchTransactions(\n    filters: TransactionSearchFilters\n): Promise<{ results: SearchResult[]; total: number }> {\n    const {\n        from,\n        to,\n        amountMin,\n        amountMax,\n        entryType,\n        transactionType,\n        reference,\n        accountId,\n        includeReversals = true,\n        page = 1,\n        size = 50,\n    } = filters;\n\n    const offset = (page - 1) * size;\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (from) {\n        conditions.push('le.entry_date >= ?');\n        params.push(from);\n    }\n\n    if (to) {\n        conditions.push('le.entry_date <= ?');\n        params.push(to);\n    }\n\n    if (amountMin !== undefined) {\n        conditions.push('le.amount >= ?');\n        params.push(amountMin);\n    }\n\n    if (amountMax !== undefined) {\n        conditions.push('le.amount <= ?');\n        params.push(amountMax);\n    }\n\n    if (entryType) {\n        conditions.push('le.entry_type = ?');\n        params.push(entryType);\n    }\n\n    if (transactionType) {\n        conditions.push('tt.code = ?');\n        params.push(transactionType);\n    }\n\n    if (reference) {\n        conditions.push('(t.transaction_reference LIKE ? OR le.description LIKE ?)');\n        params.push(`%${reference}%`, `%${reference}%`);\n    }\n\n    if (accountId) {\n        conditions.push('le.account_id = ?');\n        params.push(accountId);\n    }\n\n    if (!includeReversals) {\n        conditions.push(\"t.status != 'REVERSED'\");\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    // Get total count\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count\n         FROM ledger_entries le\n         JOIN transactions t ON le.transaction_id = t.id\n         JOIN transaction_types tt ON t.transaction_type_id = tt.id\n         JOIN accounts a ON le.account_id = a.id\n         WHERE ${whereClause}`,\n        params\n    );\n\n    // Get results\n    const rows = await query<SearchRow[]>(\n        `SELECT le.id, t.transaction_reference, tt.code as transaction_type,\n                le.account_id, a.account_number, le.entry_type, le.amount,\n                le.balance_after, le.description, le.entry_date, le.created_at,\n                (t.status = 'REVERSED') as is_reversal\n         FROM ledger_entries le\n         JOIN transactions t ON le.transaction_id = t.id\n         JOIN transaction_types tt ON t.transaction_type_id = tt.id\n         JOIN accounts a ON le.account_id = a.id\n         WHERE ${whereClause}\n         ORDER BY le.created_at DESC, le.id DESC\n         LIMIT ? OFFSET ?`,\n        [...params, size, offset]\n    );\n\n    const results: SearchResult[] = rows.map((row) => ({\n        id: row.id,\n        transactionReference: row.transaction_reference,\n        transactionType: row.transaction_type,\n        accountId: row.account_id,\n        accountNumber: row.account_number,\n        entryType: row.entry_type,\n        amount: parseFloat(row.amount),\n        balanceAfter: parseFloat(row.balance_after),\n        description: row.description,\n        entryDate: row.entry_date,\n        createdAt: row.created_at,\n        isReversal: Boolean(row.is_reversal),\n    }));\n\n    return { results, total: countRow?.count || 0 };\n}\n\n// =============================================================================\n// CSV Export Helper\n// =============================================================================\n\nexport function generateCsvFromResults(results: SearchResult[]): string {\n    const headers = [\n        'ID',\n        'Date',\n        'Transaction Ref',\n        'Type',\n        'Account Number',\n        'Entry Type',\n        'Amount',\n        'Balance After',\n        'Description',\n        'Is Reversal',\n    ];\n\n    const rows = results.map((r) => [\n        r.id,\n        formatDate(r.entryDate),\n        r.transactionReference,\n        r.transactionType,\n        r.accountNumber,\n        r.entryType,\n        r.amount.toFixed(2),\n        r.balanceAfter.toFixed(2),\n        `\"${(r.description || '').replace(/\"/g, '\"\"')}\"`,\n        r.isReversal ? 'Yes' : 'No',\n    ]);\n\n    return [headers.join(','), ...rows.map((r) => r.join(','))].join('\\n');\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1516, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/lib/services/account-service.ts"],"sourcesContent":["import { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket, ResultSetHeader } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type AccountType = 'SAVINGS' | 'CHECKING' | 'FIXED';\nexport type AccountStatus = 'ACTIVE' | 'SUSPENDED' | 'CLOSED' | 'PENDING';\n\nexport interface Account {\n    id: number;\n    accountNumber: string;\n    customerId: number;\n    accountType: AccountType;\n    currency: string;\n    status: AccountStatus;\n    openedAt: Date | null;\n    createdAt: Date;\n    customerName?: string;\n    balance?: {\n        availableBalance: number;\n    };\n}\n\n// =============================================================================\n// Account Queries\n// =============================================================================\n\nexport async function getAccountById(accountId: number): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.id = ?`,\n        [accountId]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountByNumber(accountNumber: string): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.account_number = ?`,\n        [accountNumber]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountsForCustomer(customerId: number): Promise<Account[]> {\n    const rows = await query<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                c.first_name, c.last_name,\n                COALESCE(ab.available_balance, 0) as available_balance,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN customers c ON c.id = a.customer_id\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.customer_id = ?\n         ORDER BY a.created_at DESC`,\n        [customerId]\n    );\n\n    return rows.map((row: any) => ({\n        id: row.id,\n        accountNumber: row.account_number,\n        customerId: row.customer_id,\n        accountType: row.account_type,\n        accountTypeName: row.account_type_name,\n        currency: row.currency,\n        status: row.status,\n        openedAt: row.created_at,\n        createdAt: row.created_at,\n        customerName: `${row.first_name} ${row.last_name}`,\n        balance: {\n            availableBalance: parseFloat(row.available_balance || '0')\n        }\n    }));\n}\n\n// =============================================================================\n// Lifecycle Management (Freeze/Unfreeze)\n// =============================================================================\n\nexport async function freezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"SUSPENDED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error freezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function unfreezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"ACTIVE\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error unfreezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function closeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        // 1. Check Balance (Must be 0)\n        const balanceRow = await queryOne<RowDataPacket>(\n            'SELECT available_balance FROM account_balances WHERE account_id = ?',\n            [accountId]\n        );\n\n        const balance = parseFloat(balanceRow?.available_balance || '0');\n        if (balance !== 0) {\n            return { success: false, error: `Cannot close account. Non-zero balance: ${balance}` };\n        }\n\n        // 2. Update Account Status\n        await query(\n            'UPDATE accounts SET status = \"CLOSED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n\n        return { success: true };\n    } catch (error) {\n        console.error('Error closing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\n// =============================================================================\n// Account Creation (Direct)\n// =============================================================================\n\nexport async function createAccount(\n    customerId: number,\n    accountTypeId: number,\n    createdBy?: number\n): Promise<{ success: boolean; accountId?: number; accountNumber?: string; error?: string }> {\n    try {\n        // 1. Verify Customer exists\n        const customer = await queryOne<RowDataPacket>(\n            'SELECT id FROM customers WHERE id = ?',\n            [customerId]\n        );\n\n        if (!customer) {\n            return { success: false, error: 'Customer not found' };\n        }\n\n        // 2. Generate Account Number (matches existing 1001-XXXX-XXXX format)\n        const segment1 = '1001';\n        const segment2 = String(customerId).padStart(4, '0');\n        const segment3 = String(Math.floor(1000 + Math.random() * 9000));\n        const accountNumber = `${segment1}-${segment2}-${segment3}`;\n\n        return await withTransaction(async (conn) => {\n            // 3. Insert Account record\n            const [accountResult] = await conn.execute<ResultSetHeader>(\n                `INSERT INTO accounts (account_number, customer_id, account_type_id, status, opened_at, created_at, created_by)\n                 VALUES (?, ?, ?, 'ACTIVE', NOW(), NOW(), ?)`,\n                [accountNumber, customerId, accountTypeId, createdBy || null]\n            );\n\n            const accountId = accountResult.insertId;\n\n            // 4. Initialize Balance record\n            await conn.execute(\n                `INSERT INTO account_balances (account_id, available_balance, currency, version)\n                 VALUES (?, 0.0000, 'BDT', 1)`,\n                [accountId]\n            );\n\n            return {\n                success: true,\n                accountId,\n                accountNumber\n            };\n        });\n    } catch (error) {\n        console.error('Error creating account:', error);\n        return { success: false, error: 'Database error during account creation' };\n    }\n}\n\n/**\n * Legacy wrapper for application flow.\n * Now directly creates the account.\n */\nexport async function applyForAccount(\n    customerId: number,\n    accountTypeCode: AccountType\n): Promise<{ success: boolean; applicationId?: number; error?: string }> {\n    // Lookup Account Type ID\n    const typeRow = await queryOne<RowDataPacket>(\n        'SELECT id FROM account_types WHERE code = ?',\n        [accountTypeCode]\n    );\n\n    if (!typeRow) {\n        return { success: false, error: 'Invalid account type' };\n    }\n\n    const result = await createAccount(customerId, typeRow.id);\n\n    if (result.success) {\n        return { success: true, applicationId: result.accountId };\n    }\n\n    return { success: false, error: result.error };\n}\n\n\n\n/**\n * Creates a new customer record (without any accounts).\n * Banker will create accounts separately via the accounts endpoint.\n */\nexport async function onboardNewCustomer(\n    data: {\n        firstName: string;\n        lastName: string;\n        email: string;\n        dateOfBirth: string;\n        customerNumber: string;\n        createdBy: number;\n    }\n): Promise<{ success: boolean; customerId?: number; tempPassword?: string; error?: string }> {\n    try {\n        // Generate a temporary password (they should change it later)\n        const tempPassword = 'Welcome!' + Math.floor(1000 + Math.random() * 9000);\n        const { hashPassword } = await import('./auth-service');\n        const passwordHash = await hashPassword(tempPassword);\n\n        // Create Customer (no automatic account)\n        const result = await execute(\n            `INSERT INTO customers \n             (customer_number, email, first_name, last_name, date_of_birth, status, kyc_status, created_at, created_by, password_hash)\n             VALUES (?, ?, ?, ?, ?, 'ACTIVE', 'VERIFIED', NOW(), ?, ?)`,\n            [data.customerNumber, data.email, data.firstName, data.lastName, data.dateOfBirth, data.createdBy, passwordHash]\n        );\n\n        return {\n            success: true,\n            customerId: result.insertId,\n            tempPassword, // Return temp password for banker to share\n        };\n    } catch (error) {\n        if ((error as any).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email or Customer Number already exists' };\n        }\n        console.error('Error during customer creation:', error);\n        return { success: false, error: 'Database error during customer creation' };\n    }\n}\n\nexport async function refreshAccountBalance(accountId: number): Promise<void> {\n    // Placeholder - in real system would trigger reconciliation\n    return;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1791, "column": 0}, "map": {"version":3,"sources":["file:///home/mohammadirfan/bclatest/src/app/api/v1/accounts/%5Bid%5D/statement/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport {\n    withErrorHandler,\n    withAuth,\n    successResponse,\n    notFoundResponse,\n    errorResponse,\n    getPaginationMeta,\n    AuthenticatedRequest,\n} from '@/lib/api-utils';\nimport { getAccountStatement } from '@/lib/services/statement-service';\nimport { getAccountById } from '@/lib/services/account-service';\n\n// =============================================================================\n// GET /api/v1/accounts/[id]/statement - Get account statement\n// =============================================================================\n\nexport const GET = withErrorHandler(async (request: NextRequest, context) => {\n    const params = await context?.params;\n    const accountId = parseInt(params?.id || '0');\n\n    return withAuth(\n        request,\n        async (req: AuthenticatedRequest) => {\n            // Validate account exists\n            const account = await getAccountById(accountId);\n            if (!account) {\n                return notFoundResponse('Account not found');\n            }\n\n            // Customers can only view their own accounts\n            if (req.tokenPayload?.type === 'customer') {\n                if (account.customerId !== req.customer?.id) {\n                    return notFoundResponse('Account not found');\n                }\n            }\n\n            // Get query parameters\n            const { searchParams } = new URL(request.url);\n            const from = searchParams.get('from');\n            const to = searchParams.get('to');\n            const page = parseInt(searchParams.get('page') || '1');\n            const size = parseInt(searchParams.get('size') || '50');\n\n            // Validate required parameters\n            if (!from || !to) {\n                return errorResponse('Missing required parameters: from and to dates are required');\n            }\n\n            // Validate date format\n            const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n            if (!dateRegex.test(from) || !dateRegex.test(to)) {\n                return errorResponse('Invalid date format. Use YYYY-MM-DD');\n            }\n\n            // Validate date range\n            if (new Date(from) > new Date(to)) {\n                return errorResponse('Invalid date range: from date must be before to date');\n            }\n\n            try {\n                const { statement, total } = await getAccountStatement(accountId, {\n                    from,\n                    to,\n                    page,\n                    size,\n                });\n\n                return successResponse(statement, getPaginationMeta(page, size, total));\n            } catch (error) {\n                console.error('Statement generation error:', error);\n                return errorResponse('Failed to generate statement');\n            }\n        },\n        {\n            requiredType: 'any',\n        }\n    );\n});\n"],"names":[],"mappings":";;;;AACA;AASA;AACA;;;;AAMO,MAAM,MAAM,IAAA,gJAAgB,EAAC,OAAO,SAAsB;IAC7D,MAAM,SAAS,MAAM,SAAS;IAC9B,MAAM,YAAY,SAAS,QAAQ,MAAM;IAEzC,OAAO,IAAA,wIAAQ,EACX,SACA,OAAO;QACH,0BAA0B;QAC1B,MAAM,UAAU,MAAM,IAAA,gKAAc,EAAC;QACrC,IAAI,CAAC,SAAS;YACV,OAAO,IAAA,gJAAgB,EAAC;QAC5B;QAEA,6CAA6C;QAC7C,IAAI,IAAI,YAAY,EAAE,SAAS,YAAY;YACvC,IAAI,QAAQ,UAAU,KAAK,IAAI,QAAQ,EAAE,IAAI;gBACzC,OAAO,IAAA,gJAAgB,EAAC;YAC5B;QACJ;QAEA,uBAAuB;QACvB,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,OAAO,aAAa,GAAG,CAAC;QAC9B,MAAM,KAAK,aAAa,GAAG,CAAC;QAC5B,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAClD,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAElD,+BAA+B;QAC/B,IAAI,CAAC,QAAQ,CAAC,IAAI;YACd,OAAO,IAAA,6IAAa,EAAC;QACzB;QAEA,uBAAuB;QACvB,MAAM,YAAY;QAClB,IAAI,CAAC,UAAU,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,CAAC,KAAK;YAC9C,OAAO,IAAA,6IAAa,EAAC;QACzB;QAEA,sBAAsB;QACtB,IAAI,IAAI,KAAK,QAAQ,IAAI,KAAK,KAAK;YAC/B,OAAO,IAAA,6IAAa,EAAC;QACzB;QAEA,IAAI;YACA,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,MAAM,IAAA,uKAAmB,EAAC,WAAW;gBAC9D;gBACA;gBACA;gBACA;YACJ;YAEA,OAAO,IAAA,+IAAe,EAAC,WAAW,IAAA,iJAAiB,EAAC,MAAM,MAAM;QACpE,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO,IAAA,6IAAa,EAAC;QACzB;IACJ,GACA;QACI,cAAc;IAClB;AAER"}}]
}