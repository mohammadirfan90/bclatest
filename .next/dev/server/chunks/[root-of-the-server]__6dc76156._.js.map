{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/auth-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface User {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    roleId: number;\n    roleCode: string;\n    roleName: string;\n    permissions: string[];\n    status: string;\n    mfaEnabled: boolean;\n}\n\nexport interface Customer {\n    id: number;\n    customerNumber: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    status: string;\n    kycStatus: string;\n}\n\nexport interface TokenPayload {\n    sub: string;\n    type: 'user' | 'customer';\n    email: string;\n    role?: string;\n    permissions?: string[];\n    tokenVersion: number;\n    iat: number;\n    exp: number;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User | Customer;\n    token?: string;\n    refreshToken?: string;\n    error?: string;\n}\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\nconst BCRYPT_ROUNDS = 12;\nconst MAX_FAILED_ATTEMPTS = 5;\n\n// =============================================================================\n// Password Management\n// =============================================================================\n\nexport async function hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// =============================================================================\n// JWT Token Management\n// =============================================================================\n\nexport function generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n}\n\nexport function generateRefreshToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (jwt.sign as any)({ ...payload, refresh: true }, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n}\n\nexport function verifyToken(token: string): TokenPayload | null {\n    try {\n        return jwt.verify(token, JWT_SECRET) as TokenPayload;\n    } catch {\n        return null;\n    }\n}\n\n// =============================================================================\n// User Authentication\n// =============================================================================\n\nexport async function authenticateUser(email: string, password: string): Promise<AuthResult> {\n    interface UserRow extends RowDataPacket {\n        id: number;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        role_id: number;\n        role_code: string;\n        role_name: string;\n        permissions: string;\n        status: string;\n    }\n\n    const userRow = await queryOne<UserRow>(\n        `SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,\n            u.role_id, r.code as role_code, r.name as role_name, r.permissions,\n            u.status\n     FROM users u\n     INNER JOIN roles r ON r.id = u.role_id\n     WHERE u.email = ?`,\n        [email]\n    );\n\n    if (!userRow) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    if (userRow.status !== 'ACTIVE') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, userRow.password_hash);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    // Update last login\n    await execute(\n        'UPDATE users SET last_login_at = NOW() WHERE id = ?',\n        [userRow.id]\n    );\n\n    // Parse permissions (MySQL may return JSON as already-parsed array)\n    const permissions = Array.isArray(userRow.permissions)\n        ? userRow.permissions as string[]\n        : JSON.parse(userRow.permissions || '[]') as string[];\n\n    const user: User = {\n        id: userRow.id,\n        email: userRow.email,\n        firstName: userRow.first_name,\n        lastName: userRow.last_name,\n        roleId: userRow.role_id,\n        roleCode: userRow.role_code,\n        roleName: userRow.role_name,\n        permissions,\n        status: userRow.status,\n        mfaEnabled: false, // Simplified - no MFA\n    };\n\n    // Generate tokens\n    const token = generateToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        permissions,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: userRow.id.toString(),\n        type: 'user',\n        email: userRow.email,\n        role: userRow.role_code,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user, token, refreshToken };\n}\n\n// =============================================================================\n// Customer Authentication\n// =============================================================================\n\nexport async function authenticateCustomer(email: string, password: string): Promise<AuthResult> {\n    interface CustomerRow extends RowDataPacket {\n        id: number;\n        customer_number: string;\n        email: string;\n        password_hash: string;\n        first_name: string;\n        last_name: string;\n        status: string;\n        kyc_status: string;\n    }\n\n    const customerRow = await queryOne<CustomerRow>(\n        `SELECT id, customer_number, email, password_hash, first_name, last_name,\n            status, kyc_status\n     FROM customers\n     WHERE email = ?`,\n        [email]\n    );\n\n    if (!customerRow) {\n        console.log(`[Auth] Customer not found: ${email}`);\n        return { success: false, error: 'Invalid email or password' };\n    }\n    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);\n\n    if (customerRow.status === 'SUSPENDED') {\n        return { success: false, error: 'Account is suspended. Please contact support.' };\n    }\n\n    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {\n        return { success: false, error: 'Account is not active' };\n    }\n\n    // Verify password\n    const passwordValid = await verifyPassword(password, customerRow.password_hash);\n    console.log(`[Auth] Password valid: ${passwordValid}`);\n\n    if (!passwordValid) {\n        return { success: false, error: 'Invalid email or password' };\n    }\n\n    const customer: Customer = {\n        id: customerRow.id,\n        customerNumber: customerRow.customer_number,\n        email: customerRow.email,\n        firstName: customerRow.first_name,\n        lastName: customerRow.last_name,\n        status: customerRow.status,\n        kycStatus: customerRow.kyc_status,\n    };\n\n    const token = generateToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1, // Simplified - no version tracking\n    });\n\n    const refreshToken = generateRefreshToken({\n        sub: customerRow.id.toString(),\n        type: 'customer',\n        email: customerRow.email,\n        tokenVersion: 1,\n    });\n\n    return { success: true, user: customer, token, refreshToken };\n}\n\n// =============================================================================\n// Token Refresh\n// =============================================================================\n\nexport async function refreshAccessToken(refreshToken: string): Promise<AuthResult> {\n    const payload = verifyToken(refreshToken);\n\n    if (!payload) {\n        return { success: false, error: 'Invalid refresh token' };\n    }\n\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            role_code: string;\n            permissions: string;\n        }\n\n        const userRow = await queryOne<UserRow>(\n            `SELECT u.id, u.email, r.code as role_code, r.permissions\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return { success: false, error: 'User not found or inactive' };\n        }\n\n        const permissions = Array.isArray(userRow.permissions)\n            ? userRow.permissions as string[]\n            : JSON.parse(userRow.permissions || '[]') as string[];\n\n        const newToken = generateToken({\n            sub: userRow.id.toString(),\n            type: 'user',\n            email: userRow.email,\n            role: userRow.role_code,\n            permissions,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            email: string;\n        }\n\n        const customerRow = await queryOne<CustomerRow>(\n            `SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return { success: false, error: 'Customer not found or inactive' };\n        }\n\n        const newToken = generateToken({\n            sub: customerRow.id.toString(),\n            type: 'customer',\n            email: customerRow.email,\n            tokenVersion: 1, // Simplified\n        });\n\n        return { success: true, token: newToken };\n    }\n\n    return { success: false, error: 'Invalid token type' };\n}\n\n// =============================================================================\n// User Management\n// =============================================================================\n\nexport async function createUser(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    roleId: number,\n    createdBy?: number\n): Promise<{ success: boolean; userId?: number; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    try {\n        const result = await execute(\n            `INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`,\n            [email, passwordHash, firstName, lastName, roleId, createdBy ?? null]\n        );\n\n        return { success: true, userId: result.insertId };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\nexport async function createCustomer(\n    email: string,\n    password: string,\n    firstName: string,\n    lastName: string,\n    createdBy?: number\n): Promise<{ success: boolean; customerId?: number; customerNumber?: string; error?: string }> {\n    const passwordHash = await hashPassword(password);\n\n    // Generate customer number\n    const customerNumber = `C${Date.now().toString().slice(-10)}`;\n\n    try {\n        const result = await execute(\n            `INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)\n       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?)`,\n            [customerNumber, email, passwordHash, firstName, lastName, createdBy ?? null]\n        );\n\n        return { success: true, customerId: result.insertId, customerNumber };\n    } catch (error) {\n        if ((error as { code?: string }).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email already exists' };\n        }\n        throw error;\n    }\n}\n\n// =============================================================================\n// Authorization Helpers\n// =============================================================================\n\nexport function hasPermission(user: User, permission: string): boolean {\n    return user.permissions.includes(permission);\n}\n\nexport function hasAnyPermission(user: User, permissions: string[]): boolean {\n    return permissions.some((p) => user.permissions.includes(p));\n}\n\nexport function hasAllPermissions(user: User, permissions: string[]): boolean {\n    return permissions.every((p) => user.permissions.includes(p));\n}\n\nexport function isRole(user: User, role: string): boolean {\n    return user.roleCode === role;\n}\n\nexport function isAnyRole(user: User, roles: string[]): boolean {\n    return roles.includes(user.roleCode);\n}\n\n// =============================================================================\n// Logout / Global Sign Out\n// =============================================================================\n\nexport async function logout(userId: number, type: 'user' | 'customer'): Promise<void> {\n    const table = type === 'user' ? 'users' : 'customers';\n    // Increment token version to invalidate all existing tokens\n    await execute(\n        `UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`,\n        [userId]\n    );\n\n    // Also remove any active sessions\n    if (type === 'user') {\n        await execute('DELETE FROM user_sessions WHERE user_id = ?', [userId]);\n    }\n}\n\n// =============================================================================\n// Session Helper for Next.js App Router\n// =============================================================================\n\nimport { cookies, headers } from 'next/headers';\n\nexport async function getSession(): Promise<{ user?: User | Customer; role?: string } | null> {\n    try {\n        const cookieStore = await cookies();\n        const headerList = await headers();\n\n        let token = cookieStore.get('token')?.value;\n\n        if (!token) {\n            const authHeader = headerList.get('Authorization');\n            if (authHeader?.startsWith('Bearer ')) {\n                token = authHeader.substring(7);\n            }\n        }\n\n        if (!token) return null;\n\n        const payload = verifyToken(token);\n        if (!payload) return null;\n\n        if (payload.type === 'user') {\n            const userRow = await queryOne<RowDataPacket & User>(\n                `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status\n             FROM users u\n             JOIN roles r ON r.id = u.role_id\n             WHERE u.id = ?`,\n                [payload.sub]\n            );\n            if (!userRow) return null;\n\n            const permissions = Array.isArray(userRow.permissions)\n                ? userRow.permissions as string[]\n                : JSON.parse((userRow.permissions as any) || '[]') as string[];\n\n            return {\n                user: { ...userRow, firstName: userRow.first_name, lastName: userRow.last_name, roleId: userRow.role_id, roleCode: userRow.role_code, roleName: userRow.role_name, permissions, mfaEnabled: false },\n                role: userRow.role_code\n            };\n        }\n\n        if (payload.type === 'customer') {\n            const customerRow = await queryOne<RowDataPacket & Customer>(\n                `SELECT id, customer_number, email, first_name, last_name, status, kyc_status\n             FROM customers WHERE id = ?`,\n                [payload.sub]\n            );\n            if (!customerRow) return null;\n\n            return {\n                user: { ...customerRow, customerNumber: customerRow.customer_number, firstName: customerRow.first_name, lastName: customerRow.last_name, kycStatus: customerRow.kyc_status },\n                role: 'CUSTOMER'\n            };\n        }\n\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/api-utils.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { verifyToken, TokenPayload, User } from '@/lib/services/auth-service';\nimport { query } from '@/lib/db';\nimport { RowDataPacket } from 'mysql2/promise';\nimport { ZodSchema, ZodError } from 'zod';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface AuthenticatedRequest extends NextRequest {\n    user?: User;\n    customer?: {\n        id: number;\n        customerNumber: string;\n        email: string;\n    };\n    tokenPayload?: TokenPayload;\n}\n\nexport interface ApiResponse<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: string;\n    errors?: Array<{ field: string; message: string }>;\n    meta?: {\n        page?: number;\n        limit?: number;\n        total?: number;\n        totalPages?: number;\n    };\n}\n\n// =============================================================================\n// Response Helpers\n// =============================================================================\n\nexport function successResponse<T>(data: T, meta?: ApiResponse['meta']): NextResponse {\n    return NextResponse.json({ success: true, data, meta }, { status: 200 });\n}\n\nexport function createdResponse<T>(data: T): NextResponse {\n    return NextResponse.json({ success: true, data }, { status: 201 });\n}\n\nexport function errorResponse(error: string, status: number = 400): NextResponse {\n    return NextResponse.json({ success: false, error }, { status });\n}\n\nexport function validationErrorResponse(errors: Array<{ field: string; message: string }>): NextResponse {\n    return NextResponse.json({ success: false, error: 'Validation failed', errors }, { status: 400 });\n}\n\nexport function unauthorizedResponse(error: string = 'Unauthorized'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 401 });\n}\n\nexport function forbiddenResponse(error: string = 'Forbidden'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 403 });\n}\n\nexport function notFoundResponse(error: string = 'Not found'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 404 });\n}\n\nexport function serverErrorResponse(error: string = 'Internal server error'): NextResponse {\n    return NextResponse.json({ success: false, error }, { status: 500 });\n}\n\n// =============================================================================\n// Authentication Middleware\n// =============================================================================\n\nexport async function withAuth(\n    request: NextRequest,\n    handler: (req: AuthenticatedRequest) => Promise<NextResponse>,\n    options: {\n        requiredType?: 'user' | 'customer' | 'any';\n        requiredRoles?: string[];\n        requiredPermissions?: string[];\n        hideFailure?: boolean; // If true, returns 404 instead of 401/403 to hide existence\n    } = {}\n): Promise<NextResponse> {\n    const { requiredType = 'any', requiredRoles, requiredPermissions, hideFailure = false } = options;\n\n    // Helper to return 404 if hideFailure is on, otherwise the actual error\n    const getErrorResponse = (actualResponse: NextResponse) => {\n        return hideFailure ? notFoundResponse() : actualResponse;\n    };\n\n    // Get token from header\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return getErrorResponse(unauthorizedResponse('No token provided'));\n    }\n\n    const token = authHeader.substring(7);\n    const payload = verifyToken(token);\n\n    if (!payload) {\n        return getErrorResponse(unauthorizedResponse('Invalid or expired token'));\n    }\n\n    // Check required type\n    if (requiredType !== 'any' && payload.type !== requiredType) {\n        return getErrorResponse(forbiddenResponse(`Access restricted to ${requiredType}s`));\n    }\n\n    const authenticatedRequest = request as AuthenticatedRequest;\n    authenticatedRequest.tokenPayload = payload;\n\n    // For user tokens, load full user info\n    if (payload.type === 'user') {\n        interface UserRow extends RowDataPacket {\n            id: number;\n            email: string;\n            first_name: string;\n            last_name: string;\n            role_id: number;\n            role_code: string;\n            role_name: string;\n            permissions: string;\n            status: string;\n        }\n\n        const [userRow] = await query<UserRow[]>(\n            `SELECT u.id, u.email, u.first_name, u.last_name, u.role_id,\n              r.code as role_code, r.name as role_name, r.permissions,\n              u.status\n       FROM users u\n       INNER JOIN roles r ON r.id = u.role_id\n       WHERE u.id = ? AND u.status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!userRow) {\n            return getErrorResponse(unauthorizedResponse('User not found or inactive'));\n        }\n\n        // Safely parse permissions - handle invalid JSON gracefully\n        let permissions: string[] = [];\n        try {\n            const rawPerms = userRow.permissions;\n            if (rawPerms && typeof rawPerms === 'string' && rawPerms.startsWith('[')) {\n                permissions = JSON.parse(rawPerms);\n            } else if (Array.isArray(rawPerms)) {\n                permissions = rawPerms;\n            }\n        } catch (e) {\n            console.warn('Invalid permissions JSON, defaulting to empty array');\n            permissions = [];\n        }\n\n        authenticatedRequest.user = {\n            id: userRow.id,\n            email: userRow.email,\n            firstName: userRow.first_name,\n            lastName: userRow.last_name,\n            roleId: userRow.role_id,\n            roleCode: userRow.role_code,\n            roleName: userRow.role_name,\n            permissions,\n            status: userRow.status,\n            mfaEnabled: false, // Simplified - no MFA\n        };\n\n        // Check required roles\n        if (requiredRoles && requiredRoles.length > 0) {\n            if (!requiredRoles.includes(userRow.role_code)) {\n                return getErrorResponse(forbiddenResponse('Insufficient role privileges'));\n            }\n        }\n\n        // Check required permissions\n        if (requiredPermissions && requiredPermissions.length > 0) {\n            const hasPermission = requiredPermissions.some((p) => permissions.includes(p));\n            if (!hasPermission) {\n                return getErrorResponse(forbiddenResponse('Insufficient permissions'));\n            }\n        }\n    }\n\n    // For customer tokens\n    if (payload.type === 'customer') {\n        interface CustomerRow extends RowDataPacket {\n            id: number;\n            customer_number: string;\n            email: string;\n            status: string;\n        }\n\n        const [customerRow] = await query<CustomerRow[]>(\n            `SELECT id, customer_number, email, status\n       FROM customers\n       WHERE id = ? AND status = 'ACTIVE'`,\n            [payload.sub]\n        );\n\n        if (!customerRow) {\n            return unauthorizedResponse('Customer not found or inactive');\n        }\n\n        authenticatedRequest.customer = {\n            id: customerRow.id,\n            customerNumber: customerRow.customer_number,\n            email: customerRow.email,\n        };\n    }\n\n    return handler(authenticatedRequest);\n}\n\n// =============================================================================\n// Validation Middleware\n// =============================================================================\n\nexport async function validateBody<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): Promise<{ success: true; data: T } | { success: false; response: NextResponse }> {\n    try {\n        const body = await request.json();\n        const data = schema.parse(body);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid request body') };\n    }\n}\n\nexport function validateQuery<T>(\n    request: NextRequest,\n    schema: ZodSchema<T>\n): { success: true; data: T } | { success: false; response: NextResponse } {\n    try {\n        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());\n        const data = schema.parse(searchParams);\n        return { success: true, data };\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errors = error.issues.map((e) => ({\n                field: e.path.join('.'),\n                message: e.message,\n            }));\n            return { success: false, response: validationErrorResponse(errors) };\n        }\n        return { success: false, response: errorResponse('Invalid query parameters') };\n    }\n}\n\n// =============================================================================\n// Idempotency Middleware\n// =============================================================================\n\nexport function getIdempotencyKey(request: NextRequest): string | null {\n    return request.headers.get('Idempotency-Key') ||\n        request.headers.get('idempotency-key') ||\n        null;\n}\n\nexport function requireIdempotencyKey(request: NextRequest): { success: true; key: string } | { success: false; response: NextResponse } {\n    const key = getIdempotencyKey(request);\n    if (!key) {\n        return {\n            success: false,\n            response: errorResponse('Idempotency-Key header is required for this operation', 400)\n        };\n    }\n    // Validate UUID format\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    if (!uuidRegex.test(key)) {\n        return {\n            success: false,\n            response: errorResponse('Invalid Idempotency-Key format. Must be a valid UUID.', 400)\n        };\n    }\n    return { success: true, key };\n}\n\nexport async function checkIdempotency(\n    idempotencyKey: string | undefined\n): Promise<{ cached: true; response: NextResponse } | { cached: false }> {\n    if (!idempotencyKey) {\n        return { cached: false };\n    }\n\n    interface CachedRow extends RowDataPacket {\n        response_status: number;\n        response_body: string;\n    }\n\n    const [cached] = await query<CachedRow[]>(\n        `SELECT response_status, response_body\n     FROM idempotency_keys\n     WHERE idempotency_key = ? AND expires_at > NOW()`,\n        [idempotencyKey]\n    );\n\n    if (cached) {\n        const body = JSON.parse(cached.response_body);\n        return {\n            cached: true,\n            response: NextResponse.json(body, { status: cached.response_status }),\n        };\n    }\n\n    return { cached: false };\n}\n\n// =============================================================================\n// Error Handler Wrapper\n// =============================================================================\n\nexport function withErrorHandler<T = { id?: string }>(\n    handler: (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse>\n): (request: NextRequest, context?: { params: Promise<T> }) => Promise<NextResponse> {\n    return async (request: NextRequest, context?: { params: Promise<T> }) => {\n        try {\n            // Context is optional - routes without dynamic params won't have it\n            return await handler(request, context);\n        } catch (error) {\n            console.error('API Error:', error);\n\n            if (error instanceof Error) {\n                // Don't expose internal error messages in production\n                const message = process.env.NODE_ENV === 'development'\n                    ? error.message\n                    : 'An unexpected error occurred';\n                return serverErrorResponse(message);\n            }\n\n            return serverErrorResponse();\n        }\n    };\n}\n\n// =============================================================================\n// Pagination Helper\n// =============================================================================\n\nexport function getPaginationMeta(page: number, limit: number, total: number) {\n    return {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n    };\n}\n\nexport function getOffset(page: number, limit: number): number {\n    return (page - 1) * limit;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;;;;;AAiCO,SAAS,gBAAmB,IAAO,EAAE,IAA0B;IAClE,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAM;QAAM;IAAK,GAAG;QAAE,QAAQ;IAAI;AAC1E;AAEO,SAAS,gBAAmB,IAAO;IACtC,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAM;IAAK,GAAG;QAAE,QAAQ;IAAI;AACpE;AAEO,SAAS,cAAc,KAAa,EAAE,SAAiB,GAAG;IAC7D,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO;IAAM,GAAG;QAAE;IAAO;AACjE;AAEO,SAAS,wBAAwB,MAAiD;IACrF,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO,OAAO;QAAqB;IAAO,GAAG;QAAE,QAAQ;IAAI;AACnG;AAEO,SAAS,qBAAqB,QAAgB,cAAc;IAC/D,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO;IAAM,GAAG;QAAE,QAAQ;IAAI;AACtE;AAEO,SAAS,kBAAkB,QAAgB,WAAW;IACzD,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO;IAAM,GAAG;QAAE,QAAQ;IAAI;AACtE;AAEO,SAAS,iBAAiB,QAAgB,WAAW;IACxD,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO;IAAM,GAAG;QAAE,QAAQ;IAAI;AACtE;AAEO,SAAS,oBAAoB,QAAgB,uBAAuB;IACvE,OAAO,+PAAY,CAAC,IAAI,CAAC;QAAE,SAAS;QAAO;IAAM,GAAG;QAAE,QAAQ;IAAI;AACtE;AAMO,eAAe,SAClB,OAAoB,EACpB,OAA6D,EAC7D,UAKI,CAAC,CAAC;IAEN,MAAM,EAAE,eAAe,KAAK,EAAE,aAAa,EAAE,mBAAmB,EAAE,cAAc,KAAK,EAAE,GAAG;IAE1F,wEAAwE;IACxE,MAAM,mBAAmB,CAAC;QACtB,OAAO,cAAc,qBAAqB;IAC9C;IAEA,wBAAwB;IACxB,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,cAAc,CAAC,WAAW,UAAU,CAAC,YAAY;QAClD,OAAO,iBAAiB,qBAAqB;IACjD;IAEA,MAAM,QAAQ,WAAW,SAAS,CAAC;IACnC,MAAM,UAAU,IAAA,0JAAW,EAAC;IAE5B,IAAI,CAAC,SAAS;QACV,OAAO,iBAAiB,qBAAqB;IACjD;IAEA,sBAAsB;IACtB,IAAI,iBAAiB,SAAS,QAAQ,IAAI,KAAK,cAAc;QACzD,OAAO,iBAAiB,kBAAkB,CAAC,qBAAqB,EAAE,aAAa,CAAC,CAAC;IACrF;IAEA,MAAM,uBAAuB;IAC7B,qBAAqB,YAAY,GAAG;IAEpC,uCAAuC;IACvC,IAAI,QAAQ,IAAI,KAAK,QAAQ;QAazB,MAAM,CAAC,QAAQ,GAAG,MAAM,IAAA,2HAAK,EACzB,CAAC;;;;;6CAKgC,CAAC,EAClC;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,SAAS;YACV,OAAO,iBAAiB,qBAAqB;QACjD;QAEA,4DAA4D;QAC5D,IAAI,cAAwB,EAAE;QAC9B,IAAI;YACA,MAAM,WAAW,QAAQ,WAAW;YACpC,IAAI,YAAY,OAAO,aAAa,YAAY,SAAS,UAAU,CAAC,MAAM;gBACtE,cAAc,KAAK,KAAK,CAAC;YAC7B,OAAO,IAAI,MAAM,OAAO,CAAC,WAAW;gBAChC,cAAc;YAClB;QACJ,EAAE,OAAO,GAAG;YACR,QAAQ,IAAI,CAAC;YACb,cAAc,EAAE;QACpB;QAEA,qBAAqB,IAAI,GAAG;YACxB,IAAI,QAAQ,EAAE;YACd,OAAO,QAAQ,KAAK;YACpB,WAAW,QAAQ,UAAU;YAC7B,UAAU,QAAQ,SAAS;YAC3B,QAAQ,QAAQ,OAAO;YACvB,UAAU,QAAQ,SAAS;YAC3B,UAAU,QAAQ,SAAS;YAC3B;YACA,QAAQ,QAAQ,MAAM;YACtB,YAAY;QAChB;QAEA,uBAAuB;QACvB,IAAI,iBAAiB,cAAc,MAAM,GAAG,GAAG;YAC3C,IAAI,CAAC,cAAc,QAAQ,CAAC,QAAQ,SAAS,GAAG;gBAC5C,OAAO,iBAAiB,kBAAkB;YAC9C;QACJ;QAEA,6BAA6B;QAC7B,IAAI,uBAAuB,oBAAoB,MAAM,GAAG,GAAG;YACvD,MAAM,gBAAgB,oBAAoB,IAAI,CAAC,CAAC,IAAM,YAAY,QAAQ,CAAC;YAC3E,IAAI,CAAC,eAAe;gBAChB,OAAO,iBAAiB,kBAAkB;YAC9C;QACJ;IACJ;IAEA,sBAAsB;IACtB,IAAI,QAAQ,IAAI,KAAK,YAAY;QAQ7B,MAAM,CAAC,YAAY,GAAG,MAAM,IAAA,2HAAK,EAC7B,CAAC;;yCAE4B,CAAC,EAC9B;YAAC,QAAQ,GAAG;SAAC;QAGjB,IAAI,CAAC,aAAa;YACd,OAAO,qBAAqB;QAChC;QAEA,qBAAqB,QAAQ,GAAG;YAC5B,IAAI,YAAY,EAAE;YAClB,gBAAgB,YAAY,eAAe;YAC3C,OAAO,YAAY,KAAK;QAC5B;IACJ;IAEA,OAAO,QAAQ;AACnB;AAMO,eAAe,aAClB,OAAoB,EACpB,MAAoB;IAEpB,IAAI;QACA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,OAAO,OAAO,KAAK,CAAC;QAC1B,OAAO;YAAE,SAAS;YAAM;QAAK;IACjC,EAAE,OAAO,OAAO;QACZ,IAAI,iBAAiB,4MAAQ,EAAE;YAC3B,MAAM,SAAS,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;oBACpC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC;oBACnB,SAAS,EAAE,OAAO;gBACtB,CAAC;YACD,OAAO;gBAAE,SAAS;gBAAO,UAAU,wBAAwB;YAAQ;QACvE;QACA,OAAO;YAAE,SAAS;YAAO,UAAU,cAAc;QAAwB;IAC7E;AACJ;AAEO,SAAS,cACZ,OAAoB,EACpB,MAAoB;IAEpB,IAAI;QACA,MAAM,eAAe,OAAO,WAAW,CAAC,QAAQ,OAAO,CAAC,YAAY,CAAC,OAAO;QAC5E,MAAM,OAAO,OAAO,KAAK,CAAC;QAC1B,OAAO;YAAE,SAAS;YAAM;QAAK;IACjC,EAAE,OAAO,OAAO;QACZ,IAAI,iBAAiB,4MAAQ,EAAE;YAC3B,MAAM,SAAS,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;oBACpC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC;oBACnB,SAAS,EAAE,OAAO;gBACtB,CAAC;YACD,OAAO;gBAAE,SAAS;gBAAO,UAAU,wBAAwB;YAAQ;QACvE;QACA,OAAO;YAAE,SAAS;YAAO,UAAU,cAAc;QAA4B;IACjF;AACJ;AAMO,SAAS,kBAAkB,OAAoB;IAClD,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,sBACvB,QAAQ,OAAO,CAAC,GAAG,CAAC,sBACpB;AACR;AAEO,SAAS,sBAAsB,OAAoB;IACtD,MAAM,MAAM,kBAAkB;IAC9B,IAAI,CAAC,KAAK;QACN,OAAO;YACH,SAAS;YACT,UAAU,cAAc,yDAAyD;QACrF;IACJ;IACA,uBAAuB;IACvB,MAAM,YAAY;IAClB,IAAI,CAAC,UAAU,IAAI,CAAC,MAAM;QACtB,OAAO;YACH,SAAS;YACT,UAAU,cAAc,yDAAyD;QACrF;IACJ;IACA,OAAO;QAAE,SAAS;QAAM;IAAI;AAChC;AAEO,eAAe,iBAClB,cAAkC;IAElC,IAAI,CAAC,gBAAgB;QACjB,OAAO;YAAE,QAAQ;QAAM;IAC3B;IAOA,MAAM,CAAC,OAAO,GAAG,MAAM,IAAA,2HAAK,EACxB,CAAC;;qDAE4C,CAAC,EAC9C;QAAC;KAAe;IAGpB,IAAI,QAAQ;QACR,MAAM,OAAO,KAAK,KAAK,CAAC,OAAO,aAAa;QAC5C,OAAO;YACH,QAAQ;YACR,UAAU,+PAAY,CAAC,IAAI,CAAC,MAAM;gBAAE,QAAQ,OAAO,eAAe;YAAC;QACvE;IACJ;IAEA,OAAO;QAAE,QAAQ;IAAM;AAC3B;AAMO,SAAS,iBACZ,OAA0F;IAE1F,OAAO,OAAO,SAAsB;QAChC,IAAI;YACA,oEAAoE;YACpE,OAAO,MAAM,QAAQ,SAAS;QAClC,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,cAAc;YAE5B,IAAI,iBAAiB,OAAO;gBACxB,qDAAqD;gBACrD,MAAM,UAAU,uCACV,MAAM,OAAO,GACb;gBACN,OAAO,oBAAoB;YAC/B;YAEA,OAAO;QACX;IACJ;AACJ;AAMO,SAAS,kBAAkB,IAAY,EAAE,KAAa,EAAE,KAAa;IACxE,OAAO;QACH;QACA;QACA;QACA,YAAY,KAAK,IAAI,CAAC,QAAQ;IAClC;AACJ;AAEO,SAAS,UAAU,IAAY,EAAE,KAAa;IACjD,OAAO,CAAC,OAAO,CAAC,IAAI;AACxB"}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/validations/schemas.ts"],"sourcesContent":["import { z } from 'zod';\n\n// =============================================================================\n// Common Validators\n// =============================================================================\n\nexport const paginationSchema = z.object({\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\nexport const idParamSchema = z.object({\n    id: z.coerce.number().int().positive(),\n});\n\n// =============================================================================\n// Auth Validators\n// =============================================================================\n\nexport const loginSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: z.string().min(1, 'Password is required'),\n    type: z.enum(['user', 'customer']).default('user'),\n});\n\nexport const refreshTokenSchema = z.object({\n    refreshToken: z.string().min(1, 'Refresh token is required'),\n});\n\n// =============================================================================\n// Customer Validators\n// =============================================================================\n\n// =============================================================================\n// Common Validators\n// =============================================================================\n\nexport const strongPasswordSchema = z.string()\n    .min(8, 'Password must be at least 8 characters')\n    // Regex: At least one uppercase, one lowercase, one number, one special char\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\n    .regex(/[0-9]/, 'Password must contain at least one number')\n    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character');\n\nexport const createCustomerSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: strongPasswordSchema,\n    firstName: z.string().min(1, 'First name is required').max(100),\n    lastName: z.string().min(1, 'Last name is required').max(100),\n    phone: z.string().max(20).optional(),\n    dateOfBirth: z.string().datetime().optional().transform((val) => val ? new Date(val) : undefined),\n    nationalId: z.string().max(50).optional(),\n    addressLine1: z.string().max(255).optional(),\n    addressLine2: z.string().max(255).optional(),\n    city: z.string().max(100).optional(),\n    postalCode: z.string().max(20).optional(),\n});\n\nexport const updateCustomerSchema = z.object({\n    firstName: z.string().min(1).max(100).optional(),\n    lastName: z.string().min(1).max(100).optional(),\n    phone: z.string().max(20).optional(),\n    addressLine1: z.string().max(255).optional(),\n    addressLine2: z.string().max(255).optional(),\n    city: z.string().max(100).optional(),\n    postalCode: z.string().max(20).optional(),\n});\n\nexport const customerSearchSchema = z.object({\n    search: z.string().optional(),\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']).optional(),\n    kycStatus: z.enum(['NOT_STARTED', 'PENDING', 'VERIFIED', 'REJECTED']).optional(),\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\nexport const updateCustomerStatusSchema = z.object({\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']),\n});\n\nexport const updateKycStatusSchema = z.object({\n    status: z.enum(['NOT_STARTED', 'PENDING', 'VERIFIED', 'REJECTED']),\n});\n\n// =============================================================================\n// Account Validators\n// =============================================================================\n\nexport const createAccountSchema = z.object({\n    customerId: z.number().int().positive(),\n    accountType: z.enum(['SAVINGS', 'CHECKING', 'FIXED']),\n});\n\nexport const updateAccountStatusSchema = z.object({\n    status: z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'CLOSED']),\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\n// =============================================================================\n// Transaction Validators\n// =============================================================================\n\n// BDT amount validator - max 10 million, min 1\nconst bdtAmount = z.number()\n    .positive('Amount must be positive')\n    .max(10000000, 'Amount exceeds maximum limit of 10,000,000')\n    .transform((val) => Math.round(val * 100) / 100); // Round to 2 decimal places\n\nexport const transferSchema = z.object({\n    fromAccountId: z.number().int().positive('Source account is required'),\n    toAccountNumber: z.string().min(1, 'Destination account number is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    idempotencyKey: z.string().uuid().optional(),\n});\n\nexport const depositSchema = z.object({\n    accountId: z.number().int().positive('Account is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    externalReference: z.string().max(100).optional(),\n    idempotencyKey: z.string().uuid('Invalid idempotency key format').optional(),\n});\n\nexport const withdrawSchema = z.object({\n    accountId: z.number().int().positive('Account is required'),\n    amount: bdtAmount,\n    description: z.string().max(500).optional(),\n    externalReference: z.string().max(100).optional(),\n    idempotencyKey: z.string().uuid('Invalid idempotency key format').optional(),\n});\n\nexport const reversalSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\nexport const transactionSearchSchema = z.object({\n    accountId: z.coerce.number().int().positive().optional(),\n    startDate: z.string().datetime().optional(),\n    endDate: z.string().datetime().optional(),\n    status: z.enum(['PENDING', 'COMPLETED', 'FAILED', 'REVERSED', 'CANCELLED']).optional(),\n    type: z.string().optional(),\n    page: z.coerce.number().int().min(1).default(1),\n    limit: z.coerce.number().int().min(1).max(100).default(50),\n});\n\n// =============================================================================\n// Reconciliation Validators\n// =============================================================================\n\nexport const createReconciliationSchema = z.object({\n    name: z.string().min(1, 'Name is required').max(255),\n    sourceType: z.enum(['BANK_STATEMENT', 'PAYMENT_GATEWAY', 'MANUAL']),\n});\n\nexport const matchReconciliationItemSchema = z.object({\n    transactionId: z.number().int().positive(),\n    matchReason: z.string().max(500).optional(),\n});\n\nexport const unmatchReconciliationItemSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\n// =============================================================================\n// Fraud Validators\n// =============================================================================\n\nexport const fraudReviewSchema = z.object({\n    decision: z.enum(['APPROVED', 'REJECTED', 'ESCALATED']),\n    notes: z.string().min(1, 'Notes are required').max(2000),\n});\n\nexport const fraudAssignSchema = z.object({\n    assignedTo: z.number().int().positive(),\n});\n\n// =============================================================================\n// Admin Validators\n// =============================================================================\n\nexport const createUserSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    password: z.string().min(8, 'Password must be at least 8 characters'),\n    firstName: z.string().min(1).max(100),\n    lastName: z.string().min(1).max(100),\n    roleId: z.number().int().positive(),\n});\n\nexport const updateUserSchema = z.object({\n    firstName: z.string().min(1).max(100).optional(),\n    lastName: z.string().min(1).max(100).optional(),\n    roleId: z.number().int().positive().optional(),\n    status: z.enum(['ACTIVE', 'INACTIVE', 'LOCKED', 'PENDING']).optional(),\n});\n\nexport const eodProcessSchema = z.object({\n    processDate: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Invalid date format (YYYY-MM-DD)'),\n});\n\nexport const interestPostingSchema = z.object({\n    year: z.number().int().min(2020).max(2100),\n    month: z.number().int().min(1).max(12),\n});\n\nexport const eventReplaySchema = z.object({\n    startEventId: z.number().int().positive().optional(),\n    endEventId: z.number().int().positive().optional(),\n    eventType: z.string().optional(),\n});\n\nexport const pseudonymizeSchema = z.object({\n    reason: z.string().min(1, 'Reason is required').max(500),\n});\n\nexport const systemConfigSchema = z.object({\n    configKey: z.string().min(1).max(100),\n    configValue: z.string(),\n    valueType: z.enum(['STRING', 'NUMBER', 'BOOLEAN', 'JSON']).default('STRING'),\n    description: z.string().max(500).optional(),\n});\n\n// =============================================================================\n// Type Exports\n// =============================================================================\n\nexport type LoginInput = z.infer<typeof loginSchema>;\nexport type CreateCustomerInput = z.infer<typeof createCustomerSchema>;\nexport type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;\nexport type CreateAccountInput = z.infer<typeof createAccountSchema>;\nexport type TransferInput = z.infer<typeof transferSchema>;\nexport type DepositInput = z.infer<typeof depositSchema>;\nexport type WithdrawInput = z.infer<typeof withdrawSchema>;\nexport type CreateUserInput = z.infer<typeof createUserSchema>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1320, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/transaction-service.ts"],"sourcesContent":["/**\n * Banking Core - Transaction Service v1.0\n * Simplified service layer for stored procedure calls\n * \n * Version: 1.0.0\n * Date: 2026-01-14\n * \n * This service provides thin wrappers around stored procedures.\n * All business logic is in the database, not JavaScript.\n */\n\nimport { callProcedure, query, queryOne } from '../db';\nimport { RowDataPacket } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface TransferRequest {\n    fromAccountId: number;\n    toAccountId: number;\n    amount: number;\n    description?: string;\n    performedBy: number;\n}\n\nexport interface DepositRequest {\n    accountId: number;\n    amount: number;\n    description?: string;\n    bankerId: number;\n}\n\nexport interface WithdrawRequest {\n    accountId: number;\n    amount: number;\n    description?: string;\n    bankerId: number;\n}\n\nexport interface TransactionResult {\n    success: boolean;\n    transactionId?: number;\n    status: string;\n    message: string;\n}\n\nexport interface Transaction {\n    id: number;\n    transactionReference: string;\n    transactionType: string;\n    amount: number;\n    currency: string;\n    description: string | null;\n    status: string;\n    sourceAccountId: number | null;\n    destinationAccountId: number | null;\n    processedAt: Date | null;\n    createdAt: Date;\n}\n\nexport interface SearchTransactionResult {\n    id: number;\n    transactionReference: string;\n    amount: number;\n    currency: string;\n    status: string;\n    description: string | null;\n    createdAt: Date;\n    type: string;\n    typeName: string;\n    sourceAccount: string | null;\n    destAccount: string | null;\n    sourceOwner: string | null;\n    destOwner: string | null;\n    entryType: 'DEBIT' | 'CREDIT' | null;\n}\n\nexport interface LedgerEntry {\n    id: number;\n    transactionId: number;\n    accountId: number;\n    entryType: 'DEBIT' | 'CREDIT';\n    amount: number;\n    currency: string;\n    balanceAfter: number;\n    description: string | null;\n    entryDate: Date;\n    createdAt: Date;\n}\n\n// =============================================================================\n// Transfer (Customer or Banker)\n// Calls sp_transfer stored procedure\n// =============================================================================\n\nexport async function transfer(request: TransferRequest): Promise<TransactionResult> {\n    const { outParams } = await callProcedure(\n        'sp_transfer',\n        [\n            request.fromAccountId,\n            request.toAccountId,\n            request.amount,\n            request.description || 'Fund Transfer',\n            request.performedBy,\n        ],\n        ['p_transaction_id', 'p_status', 'p_message']\n    );\n\n    return {\n        success: outParams.p_status === 'COMPLETED',\n        transactionId: outParams.p_transaction_id as number | undefined,\n        status: outParams.p_status as string,\n        message: outParams.p_message as string,\n    };\n}\n\n// =============================================================================\n// Deposit (Banker only)\n// Calls sp_deposit stored procedure\n// =============================================================================\n\nexport async function deposit(request: DepositRequest): Promise<TransactionResult> {\n    const { outParams } = await callProcedure(\n        'sp_deposit',\n        [\n            request.accountId,\n            request.amount,\n            request.description || 'Cash Deposit',\n            request.bankerId,\n        ],\n        ['p_transaction_id', 'p_status', 'p_message']\n    );\n\n    return {\n        success: outParams.p_status === 'COMPLETED',\n        transactionId: outParams.p_transaction_id as number | undefined,\n        status: outParams.p_status as string,\n        message: outParams.p_message as string,\n    };\n}\n\n// =============================================================================\n// Withdraw (Banker only)\n// Calls sp_withdraw stored procedure\n// =============================================================================\n\nexport async function withdraw(request: WithdrawRequest): Promise<TransactionResult> {\n    const { outParams } = await callProcedure(\n        'sp_withdraw',\n        [\n            request.accountId,\n            request.amount,\n            request.description || 'Cash Withdrawal',\n            request.bankerId,\n        ],\n        ['p_transaction_id', 'p_status', 'p_message']\n    );\n\n    return {\n        success: outParams.p_status === 'COMPLETED',\n        transactionId: outParams.p_transaction_id as number | undefined,\n        status: outParams.p_status as string,\n        message: outParams.p_message as string,\n    };\n}\n\n// =============================================================================\n// Rebuild Balance (Admin only)\n// Calls sp_rebuild_balance stored procedure\n// =============================================================================\n\nexport async function rebuildBalance(accountId: number): Promise<{\n    success: boolean;\n    oldBalance: number;\n    newBalance: number;\n    status: string;\n    message: string;\n}> {\n    const { outParams } = await callProcedure(\n        'sp_rebuild_balance',\n        [accountId],\n        ['p_old_balance', 'p_new_balance', 'p_status', 'p_message']\n    );\n\n    return {\n        success: outParams.p_status === 'COMPLETED',\n        oldBalance: parseFloat(outParams.p_old_balance as string) || 0,\n        newBalance: parseFloat(outParams.p_new_balance as string) || 0,\n        status: outParams.p_status as string,\n        message: outParams.p_message as string,\n    };\n}\n\n// =============================================================================\n// Query Transactions\n// =============================================================================\n\ninterface TransactionRow extends RowDataPacket {\n    id: number;\n    transaction_reference: string;\n    transaction_type: string;\n    amount: string;\n    currency: string;\n    description: string | null;\n    status: string;\n    source_account_id: number | null;\n    destination_account_id: number | null;\n    processed_at: Date | null;\n    created_at: Date;\n}\n\nexport async function getTransactionById(transactionId: number): Promise<Transaction | null> {\n    const row = await queryOne<TransactionRow>(\n        `SELECT t.id, t.transaction_reference, tt.code as transaction_type,\n            t.amount, t.currency, t.description, t.status,\n            t.source_account_id, t.destination_account_id,\n            t.processed_at, t.created_at\n         FROM transactions t\n         INNER JOIN transaction_types tt ON tt.id = t.transaction_type_id\n         WHERE t.id = ?`,\n        [transactionId]\n    );\n\n    if (!row) return null;\n\n    return mapTransactionRow(row);\n}\n\nexport async function getTransactionsForAccount(\n    accountId: number,\n    options: {\n        limit?: number;\n        offset?: number;\n        startDate?: Date;\n        endDate?: Date;\n    } = {}\n): Promise<{ transactions: Transaction[]; total: number }> {\n    const { limit = 50, offset = 0, startDate, endDate } = options;\n\n    const conditions: string[] = ['(t.source_account_id = ? OR t.destination_account_id = ?)'];\n    const params: unknown[] = [accountId, accountId];\n\n    if (startDate) {\n        conditions.push('t.created_at >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('t.created_at <= ?');\n        params.push(endDate);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    // Get total count\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count\n         FROM transactions t\n         WHERE ${whereClause}`,\n        params\n    );\n\n    // Get transactions\n    const rows = await query<TransactionRow[]>(\n        `SELECT t.id, t.transaction_reference, tt.code as transaction_type,\n            t.amount, t.currency, t.description, t.status,\n            t.source_account_id, t.destination_account_id,\n            t.processed_at, t.created_at\n         FROM transactions t\n         INNER JOIN transaction_types tt ON tt.id = t.transaction_type_id\n         WHERE ${whereClause}\n         ORDER BY t.created_at DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        transactions: rows.map(mapTransactionRow),\n        total: countRow?.count || 0,\n    };\n}\n\n// Get all transactions (for auditor/admin)\nexport async function getAllTransactions(\n    options: {\n        limit?: number;\n        offset?: number;\n        startDate?: Date;\n        endDate?: Date;\n        status?: string;\n        transactionType?: string;\n    } = {}\n): Promise<{ transactions: Transaction[]; total: number }> {\n    const { limit = 50, offset = 0, startDate, endDate, status, transactionType } = options;\n\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (startDate) {\n        conditions.push('t.created_at >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('t.created_at <= ?');\n        params.push(endDate);\n    }\n\n    if (status) {\n        conditions.push('t.status = ?');\n        params.push(status);\n    }\n\n    if (transactionType) {\n        conditions.push('tt.code = ?');\n        params.push(transactionType);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count\n         FROM transactions t\n         INNER JOIN transaction_types tt ON tt.id = t.transaction_type_id\n         WHERE ${whereClause}`,\n        params\n    );\n\n    const rows = await query<TransactionRow[]>(\n        `SELECT t.id, t.transaction_reference, tt.code as transaction_type,\n            t.amount, t.currency, t.description, t.status,\n            t.source_account_id, t.destination_account_id,\n            t.processed_at, t.created_at\n         FROM transactions t\n         INNER JOIN transaction_types tt ON tt.id = t.transaction_type_id\n         WHERE ${whereClause}\n         ORDER BY t.created_at DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        transactions: rows.map(mapTransactionRow),\n        total: countRow?.count || 0,\n    };\n}\n\nexport async function searchTransactions(\n    options: {\n        limit?: number;\n        offset?: number;\n        accountId?: number;\n        accountNumber?: string;\n        transactionReference?: string;\n        entryType?: 'DEBIT' | 'CREDIT';\n        startDate?: string;\n        endDate?: string;\n        status?: string;\n        type?: string;\n    } = {}\n): Promise<{ transactions: SearchTransactionResult[]; total: number }> {\n    const {\n        limit = 50,\n        offset = 0,\n        accountId,\n        accountNumber,\n        transactionReference,\n        entryType,\n        startDate,\n        endDate,\n        status,\n        type\n    } = options;\n\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (accountId) {\n        conditions.push('(t.source_account_id = ? OR t.destination_account_id = ?)');\n        params.push(accountId, accountId);\n    }\n\n    if (accountNumber) {\n        conditions.push('(sa.account_number = ? OR da.account_number = ?)');\n        params.push(accountNumber, accountNumber);\n    }\n\n    if (transactionReference) {\n        conditions.push('t.transaction_reference = ?');\n        params.push(transactionReference);\n    }\n\n    if (entryType) {\n        conditions.push('le.entry_type = ?');\n        params.push(entryType);\n    }\n\n    if (startDate) {\n        conditions.push('t.created_at >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('t.created_at <= ?');\n        params.push(endDate + ' 23:59:59');\n    }\n\n    if (status) {\n        conditions.push('t.status = ?');\n        params.push(status);\n    }\n\n    if (type) {\n        conditions.push('tt.code = ?');\n        params.push(type);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    let joinClause = `\n        INNER JOIN transaction_types tt ON t.transaction_type_id = tt.id\n        LEFT JOIN accounts sa ON t.source_account_id = sa.id\n        LEFT JOIN accounts da ON t.destination_account_id = da.id\n        LEFT JOIN customers c_source ON sa.customer_id = c_source.id\n        LEFT JOIN customers c_dest ON da.customer_id = c_dest.id\n    `;\n\n    if (entryType) {\n        joinClause += ` INNER JOIN ledger_entries le ON le.transaction_id = t.id `;\n    } else {\n        joinClause += ` LEFT JOIN ledger_entries le ON le.transaction_id = t.id `;\n    }\n\n    const countRow = await queryOne<{ total: number } & RowDataPacket>(\n        `SELECT COUNT(DISTINCT t.id) as total \n         FROM transactions t\n         ${joinClause}\n         WHERE ${whereClause}`,\n        params\n    );\n\n    const rows = await query<RowDataPacket[]>(\n        `SELECT DISTINCT t.id, t.transaction_reference, t.amount, t.currency, t.status, t.description, t.created_at,\n                tt.code as type, tt.name as type_name,\n                sa.account_number as source_account,\n                da.account_number as dest_account,\n                CONCAT(c_source.first_name, ' ', c_source.last_name) as source_owner,\n                CONCAT(c_dest.first_name, ' ', c_dest.last_name) as dest_owner\n         FROM transactions t\n         ${joinClause}\n         WHERE ${whereClause}\n         ORDER BY t.created_at DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        transactions: rows.map(row => ({\n            id: row.id,\n            transactionReference: row.transaction_reference,\n            amount: parseFloat(row.amount),\n            currency: row.currency,\n            status: row.status,\n            description: row.description,\n            createdAt: row.created_at,\n            type: row.type,\n            typeName: row.type_name,\n            sourceAccount: row.source_account,\n            destAccount: row.dest_account,\n            sourceOwner: row.source_owner,\n            destOwner: row.dest_owner,\n            entryType: entryType || null\n        })),\n        total: countRow?.total || 0,\n    };\n}\n\n// =============================================================================\n// Ledger Entries\n// =============================================================================\n\ninterface LedgerRow extends RowDataPacket {\n    id: number;\n    transaction_id: number;\n    account_id: number;\n    entry_type: 'DEBIT' | 'CREDIT';\n    amount: string;\n    currency: string;\n    balance_after: string;\n    description: string | null;\n    entry_date: Date;\n    created_at: Date;\n}\n\nexport async function getLedgerEntriesForAccount(\n    accountId: number,\n    options: {\n        limit?: number;\n        offset?: number;\n        startDate?: Date;\n        endDate?: Date;\n    } = {}\n): Promise<{ entries: LedgerEntry[]; total: number }> {\n    const { limit = 50, offset = 0, startDate, endDate } = options;\n\n    const conditions: string[] = ['account_id = ?'];\n    const params: unknown[] = [accountId];\n\n    if (startDate) {\n        conditions.push('entry_date >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('entry_date <= ?');\n        params.push(endDate);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count FROM ledger_entries WHERE ${whereClause}`,\n        params\n    );\n\n    const rows = await query<LedgerRow[]>(\n        `SELECT id, transaction_id, account_id, entry_type, amount, currency,\n            balance_after, description, entry_date, created_at\n         FROM ledger_entries\n         WHERE ${whereClause}\n         ORDER BY created_at DESC, id DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        entries: rows.map(mapLedgerRow),\n        total: countRow?.count || 0,\n    };\n}\n\n// Get all ledger entries (for banker/auditor)\nexport async function getAllLedgerEntries(\n    options: {\n        limit?: number;\n        offset?: number;\n        accountId?: number;\n        entryType?: 'DEBIT' | 'CREDIT';\n        startDate?: Date;\n        endDate?: Date;\n    } = {}\n): Promise<{ entries: (LedgerEntry & { accountNumber: string; transactionReference: string })[]; total: number }> {\n    const { limit = 50, offset = 0, accountId, entryType, startDate, endDate } = options;\n\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (accountId) {\n        conditions.push('le.account_id = ?');\n        params.push(accountId);\n    }\n\n    if (entryType) {\n        conditions.push('le.entry_type = ?');\n        params.push(entryType);\n    }\n\n    if (startDate) {\n        conditions.push('le.entry_date >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('le.entry_date <= ?');\n        params.push(endDate);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count FROM ledger_entries le WHERE ${whereClause}`,\n        params\n    );\n\n    interface EnrichedLedgerRow extends LedgerRow {\n        account_number: string;\n        transaction_reference: string;\n    }\n\n    const rows = await query<EnrichedLedgerRow[]>(\n        `SELECT le.id, le.transaction_id, le.account_id, le.entry_type, le.amount, le.currency,\n                le.balance_after, le.description, le.entry_date, le.created_at,\n                a.account_number, t.transaction_reference\n         FROM ledger_entries le\n         JOIN accounts a ON le.account_id = a.id\n         JOIN transactions t ON le.transaction_id = t.id\n         WHERE ${whereClause}\n         ORDER BY le.created_at DESC, le.id DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        entries: rows.map((row) => ({\n            ...mapLedgerRow(row),\n            accountNumber: row.account_number,\n            transactionReference: row.transaction_reference,\n        })),\n        total: countRow?.count || 0,\n    };\n}\n\n// =============================================================================\n// Audit Trail\n// =============================================================================\n\ninterface AuditRow extends RowDataPacket {\n    id: number;\n    ledger_entry_id: number;\n    transaction_id: number;\n    account_id: number;\n    entry_type: 'DEBIT' | 'CREDIT';\n    amount: string;\n    balance_after: string;\n    audit_timestamp: Date;\n}\n\nexport interface AuditEntry {\n    id: number;\n    ledgerEntryId: number;\n    transactionId: number;\n    accountId: number;\n    entryType: 'DEBIT' | 'CREDIT';\n    amount: number;\n    balanceAfter: number;\n    auditTimestamp: Date;\n}\n\nexport async function getAuditTrail(\n    options: {\n        limit?: number;\n        offset?: number;\n        accountId?: number;\n        startDate?: Date;\n        endDate?: Date;\n    } = {}\n): Promise<{ entries: AuditEntry[]; total: number }> {\n    const { limit = 50, offset = 0, accountId, startDate, endDate } = options;\n\n    const conditions: string[] = ['1=1'];\n    const params: unknown[] = [];\n\n    if (accountId) {\n        conditions.push('account_id = ?');\n        params.push(accountId);\n    }\n\n    if (startDate) {\n        conditions.push('audit_timestamp >= ?');\n        params.push(startDate);\n    }\n\n    if (endDate) {\n        conditions.push('audit_timestamp <= ?');\n        params.push(endDate);\n    }\n\n    const whereClause = conditions.join(' AND ');\n\n    interface CountRow extends RowDataPacket {\n        count: number;\n    }\n    const countRow = await queryOne<CountRow>(\n        `SELECT COUNT(*) as count FROM transaction_audit WHERE ${whereClause}`,\n        params\n    );\n\n    const rows = await query<AuditRow[]>(\n        `SELECT id, ledger_entry_id, transaction_id, account_id, entry_type, \n                amount, balance_after, audit_timestamp\n         FROM transaction_audit\n         WHERE ${whereClause}\n         ORDER BY audit_timestamp DESC, id DESC\n         LIMIT ? OFFSET ?`,\n        [...params, limit, offset]\n    );\n\n    return {\n        entries: rows.map((row) => ({\n            id: row.id,\n            ledgerEntryId: row.ledger_entry_id,\n            transactionId: row.transaction_id,\n            accountId: row.account_id,\n            entryType: row.entry_type,\n            amount: parseFloat(row.amount),\n            balanceAfter: parseFloat(row.balance_after),\n            auditTimestamp: row.audit_timestamp,\n        })),\n        total: countRow?.count || 0,\n    };\n}\n\n// =============================================================================\n// Verification Queries (for Admin/Auditor)\n// =============================================================================\n\nexport async function verifyDoubleEntry(): Promise<{\n    valid: boolean;\n    discrepancy: number;\n}> {\n    interface SumRow extends RowDataPacket {\n        total_debits: string;\n        total_credits: string;\n    }\n\n    const row = await queryOne<SumRow>(\n        `SELECT \n           COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits,\n           COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits\n         FROM ledger_entries`\n    );\n\n    const totalDebits = parseFloat(row?.total_debits || '0');\n    const totalCredits = parseFloat(row?.total_credits || '0');\n    const discrepancy = Math.abs(totalDebits - totalCredits);\n\n    return {\n        valid: discrepancy < 0.0001,\n        discrepancy,\n    };\n}\n\nexport async function verifyBalanceIntegrity(): Promise<{\n    valid: boolean;\n    discrepancies: { accountId: number; materialized: number; calculated: number }[];\n}> {\n    interface DiscrepancyRow extends RowDataPacket {\n        account_id: number;\n        materialized: string;\n        calculated: string;\n    }\n\n    const rows = await query<DiscrepancyRow[]>(\n        `SELECT \n           ab.account_id,\n           ab.available_balance AS materialized,\n           COALESCE(\n             (SELECT SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE -amount END)\n              FROM ledger_entries WHERE account_id = ab.account_id), 0\n           ) AS calculated\n         FROM account_balances ab\n         HAVING ABS(materialized - calculated) > 0.0001`\n    );\n\n    return {\n        valid: rows.length === 0,\n        discrepancies: rows.map((row) => ({\n            accountId: row.account_id,\n            materialized: parseFloat(row.materialized),\n            calculated: parseFloat(row.calculated),\n        })),\n    };\n}\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\nfunction mapTransactionRow(row: TransactionRow): Transaction {\n    return {\n        id: row.id,\n        transactionReference: row.transaction_reference,\n        transactionType: row.transaction_type,\n        amount: parseFloat(row.amount),\n        currency: row.currency,\n        description: row.description,\n        status: row.status,\n        sourceAccountId: row.source_account_id,\n        destinationAccountId: row.destination_account_id,\n        processedAt: row.processed_at,\n        createdAt: row.created_at,\n    };\n}\n\nfunction mapLedgerRow(row: LedgerRow): LedgerEntry {\n    return {\n        id: row.id,\n        transactionId: row.transaction_id,\n        accountId: row.account_id,\n        entryType: row.entry_type,\n        amount: parseFloat(row.amount),\n        currency: row.currency,\n        balanceAfter: parseFloat(row.balance_after),\n        description: row.description,\n        entryDate: row.entry_date,\n        createdAt: row.created_at,\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/account-service.ts"],"sourcesContent":["import { query, queryOne, execute, withTransaction } from '../db';\nimport { RowDataPacket, ResultSetHeader } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type AccountType = 'SAVINGS' | 'CHECKING' | 'FIXED';\nexport type AccountStatus = 'ACTIVE' | 'SUSPENDED' | 'CLOSED' | 'PENDING';\n\nexport interface Account {\n    id: number;\n    accountNumber: string;\n    customerId: number;\n    accountType: AccountType;\n    currency: string;\n    status: AccountStatus;\n    openedAt: Date | null;\n    createdAt: Date;\n    customerName?: string;\n    balance?: {\n        availableBalance: number;\n    };\n}\n\n// =============================================================================\n// Account Queries\n// =============================================================================\n\nexport async function getAccountById(accountId: number): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.id = ?`,\n        [accountId]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountByNumber(accountNumber: string): Promise<Account | null> {\n    const account = await queryOne<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.account_number = ?`,\n        [accountNumber]\n    );\n\n    if (!account) return null;\n\n    return {\n        id: account.id,\n        accountNumber: account.account_number,\n        customerId: account.customer_id,\n        accountType: account.account_type,\n        currency: account.currency,\n        status: account.status,\n        openedAt: account.created_at,\n        createdAt: account.created_at\n    };\n}\n\nexport async function getAccountsForCustomer(customerId: number): Promise<Account[]> {\n    const rows = await query<any>(\n        `SELECT a.id, a.account_number, a.customer_id, a.account_type_id,\n                at.code as account_type, at.name as account_type_name,\n                a.status, a.created_at,\n                c.first_name, c.last_name,\n                COALESCE(ab.available_balance, 0) as available_balance,\n                COALESCE(ab.currency, 'BDT') as currency\n         FROM accounts a\n         JOIN customers c ON c.id = a.customer_id\n         JOIN account_types at ON at.id = a.account_type_id\n         LEFT JOIN account_balances ab ON ab.account_id = a.id\n         WHERE a.customer_id = ?\n         ORDER BY a.created_at DESC`,\n        [customerId]\n    );\n\n    return rows.map((row: any) => ({\n        id: row.id,\n        accountNumber: row.account_number,\n        customerId: row.customer_id,\n        accountType: row.account_type,\n        accountTypeName: row.account_type_name,\n        currency: row.currency,\n        status: row.status,\n        openedAt: row.created_at,\n        createdAt: row.created_at,\n        customerName: `${row.first_name} ${row.last_name}`,\n        balance: {\n            availableBalance: parseFloat(row.available_balance || '0')\n        }\n    }));\n}\n\n// =============================================================================\n// Lifecycle Management (Freeze/Unfreeze)\n// =============================================================================\n\nexport async function freezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"SUSPENDED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error freezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function unfreezeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        await query(\n            'UPDATE accounts SET status = \"ACTIVE\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n        return { success: true };\n    } catch (error) {\n        console.error('Error unfreezing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\nexport async function closeAccount(\n    accountId: number,\n    bankerId: number,\n    reason: string\n): Promise<{ success: boolean; error?: string }> {\n    try {\n        // 1. Check Balance (Must be 0)\n        const balanceRow = await queryOne<RowDataPacket>(\n            'SELECT available_balance FROM account_balances WHERE account_id = ?',\n            [accountId]\n        );\n\n        const balance = parseFloat(balanceRow?.available_balance || '0');\n        if (balance !== 0) {\n            return { success: false, error: `Cannot close account. Non-zero balance: ${balance}` };\n        }\n\n        // 2. Update Account Status\n        await query(\n            'UPDATE accounts SET status = \"CLOSED\", updated_at = NOW() WHERE id = ?',\n            [accountId]\n        );\n\n        return { success: true };\n    } catch (error) {\n        console.error('Error closing account:', error);\n        return { success: false, error: 'Failed' };\n    }\n}\n\n// =============================================================================\n// Account Creation (Direct)\n// =============================================================================\n\nexport async function createAccount(\n    customerId: number,\n    accountTypeId: number,\n    createdBy?: number\n): Promise<{ success: boolean; accountId?: number; accountNumber?: string; error?: string }> {\n    try {\n        // 1. Verify Customer exists\n        const customer = await queryOne<RowDataPacket>(\n            'SELECT id FROM customers WHERE id = ?',\n            [customerId]\n        );\n\n        if (!customer) {\n            return { success: false, error: 'Customer not found' };\n        }\n\n        // 2. Generate Account Number (matches existing 1001-XXXX-XXXX format)\n        const segment1 = '1001';\n        const segment2 = String(customerId).padStart(4, '0');\n        const segment3 = String(Math.floor(1000 + Math.random() * 9000));\n        const accountNumber = `${segment1}-${segment2}-${segment3}`;\n\n        return await withTransaction(async (conn) => {\n            // 3. Insert Account record\n            const [accountResult] = await conn.execute<ResultSetHeader>(\n                `INSERT INTO accounts (account_number, customer_id, account_type_id, status, opened_at, created_at, created_by)\n                 VALUES (?, ?, ?, 'ACTIVE', NOW(), NOW(), ?)`,\n                [accountNumber, customerId, accountTypeId, createdBy || null]\n            );\n\n            const accountId = accountResult.insertId;\n\n            // 4. Initialize Balance record\n            await conn.execute(\n                `INSERT INTO account_balances (account_id, available_balance, currency, version)\n                 VALUES (?, 0.0000, 'BDT', 1)`,\n                [accountId]\n            );\n\n            return {\n                success: true,\n                accountId,\n                accountNumber\n            };\n        });\n    } catch (error) {\n        console.error('Error creating account:', error);\n        return { success: false, error: 'Database error during account creation' };\n    }\n}\n\n/**\n * Legacy wrapper for application flow.\n * Now directly creates the account.\n */\nexport async function applyForAccount(\n    customerId: number,\n    accountTypeCode: AccountType\n): Promise<{ success: boolean; applicationId?: number; error?: string }> {\n    // Lookup Account Type ID\n    const typeRow = await queryOne<RowDataPacket>(\n        'SELECT id FROM account_types WHERE code = ?',\n        [accountTypeCode]\n    );\n\n    if (!typeRow) {\n        return { success: false, error: 'Invalid account type' };\n    }\n\n    const result = await createAccount(customerId, typeRow.id);\n\n    if (result.success) {\n        return { success: true, applicationId: result.accountId };\n    }\n\n    return { success: false, error: result.error };\n}\n\nexport async function getPendingApplications(): Promise<any[]> {\n    // No longer applicable, returning empty array\n    return [];\n}\n\n/**\n * Creates a new customer record (without any accounts).\n * Banker will create accounts separately via the accounts endpoint.\n */\nexport async function onboardNewCustomer(\n    data: {\n        firstName: string;\n        lastName: string;\n        email: string;\n        dateOfBirth: string;\n        customerNumber: string;\n        createdBy: number;\n    }\n): Promise<{ success: boolean; customerId?: number; tempPassword?: string; error?: string }> {\n    try {\n        // Generate a temporary password (they should change it later)\n        const tempPassword = 'Welcome!' + Math.floor(1000 + Math.random() * 9000);\n        const { hashPassword } = await import('./auth-service');\n        const passwordHash = await hashPassword(tempPassword);\n\n        // Create Customer (no automatic account)\n        const result = await execute(\n            `INSERT INTO customers \n             (customer_number, email, first_name, last_name, date_of_birth, status, kyc_status, created_at, created_by, password_hash)\n             VALUES (?, ?, ?, ?, ?, 'ACTIVE', 'VERIFIED', NOW(), ?, ?)`,\n            [data.customerNumber, data.email, data.firstName, data.lastName, data.dateOfBirth, data.createdBy, passwordHash]\n        );\n\n        return {\n            success: true,\n            customerId: result.insertId,\n            tempPassword, // Return temp password for banker to share\n        };\n    } catch (error) {\n        if ((error as any).code === 'ER_DUP_ENTRY') {\n            return { success: false, error: 'Email or Customer Number already exists' };\n        }\n        console.error('Error during customer creation:', error);\n        return { success: false, error: 'Database error during customer creation' };\n    }\n}\n\nexport async function refreshAccountBalance(accountId: number): Promise<void> {\n    // Placeholder - in real system would trigger reconciliation\n    return;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2091, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/app/api/v1/transactions/transfer/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport {\n    withErrorHandler,\n    withAuth,\n    validateBody,\n    successResponse,\n    errorResponse,\n    checkIdempotency,\n    AuthenticatedRequest,\n} from '@/lib/api-utils';\nimport { transferSchema } from '@/lib/validations/schemas';\nimport { transfer } from '@/lib/services/transaction-service';\nimport { getAccountById, getAccountByNumber } from '@/lib/services/account-service';\n\n// =============================================================================\n// POST /api/v1/transactions/transfer - Transfer money\n// =============================================================================\n\nexport const POST = withErrorHandler(async (request: NextRequest) => {\n    return withAuth(\n        request,\n        async (req: AuthenticatedRequest) => {\n            const validation = await validateBody(request, transferSchema);\n            if (!validation.success) {\n                return validation.response;\n            }\n\n            const { fromAccountId, toAccountNumber, amount, description, idempotencyKey } = validation.data;\n\n            // Check idempotency\n            if (idempotencyKey) {\n                const cached = await checkIdempotency(idempotencyKey);\n                if (cached.cached) {\n                    return cached.response;\n                }\n            }\n\n            // Look up destination account by account number\n            const destAccount = await getAccountByNumber(toAccountNumber);\n            if (!destAccount) {\n                return errorResponse('Destination account not found');\n            }\n\n            // Prevent self-transfer\n            if (fromAccountId === destAccount.id) {\n                return errorResponse('Cannot transfer to the same account');\n            }\n\n            // For customers, verify they own the source account\n            if (req.tokenPayload?.type === 'customer') {\n                const sourceAccount = await getAccountById(fromAccountId);\n                if (!sourceAccount || sourceAccount.customerId !== req.customer?.id) {\n                    return errorResponse('Source account not found');\n                }\n            }\n\n            // Execute transfer via stored procedure\n            const result = await transfer({\n                fromAccountId,\n                toAccountId: destAccount.id,\n                amount,\n                description,\n                performedBy: (req.user?.id || req.customer?.id) as number,\n            });\n\n            if (!result.success) {\n                return errorResponse(result.message, 400);\n            }\n\n            return successResponse({\n                transactionId: result.transactionId,\n                status: result.status,\n                message: result.message,\n            });\n        },\n        {\n            requiredType: 'any',\n        }\n    );\n});\n"],"names":[],"mappings":";;;;AACA;AASA;AACA;AACA;;;;;AAMO,MAAM,OAAO,IAAA,gJAAgB,EAAC,OAAO;IACxC,OAAO,IAAA,wIAAQ,EACX,SACA,OAAO;QACH,MAAM,aAAa,MAAM,IAAA,4IAAY,EAAC,SAAS,wJAAc;QAC7D,IAAI,CAAC,WAAW,OAAO,EAAE;YACrB,OAAO,WAAW,QAAQ;QAC9B;QAEA,MAAM,EAAE,aAAa,EAAE,eAAe,EAAE,MAAM,EAAE,WAAW,EAAE,cAAc,EAAE,GAAG,WAAW,IAAI;QAE/F,oBAAoB;QACpB,IAAI,gBAAgB;YAChB,MAAM,SAAS,MAAM,IAAA,gJAAgB,EAAC;YACtC,IAAI,OAAO,MAAM,EAAE;gBACf,OAAO,OAAO,QAAQ;YAC1B;QACJ;QAEA,gDAAgD;QAChD,MAAM,cAAc,MAAM,IAAA,oKAAkB,EAAC;QAC7C,IAAI,CAAC,aAAa;YACd,OAAO,IAAA,6IAAa,EAAC;QACzB;QAEA,wBAAwB;QACxB,IAAI,kBAAkB,YAAY,EAAE,EAAE;YAClC,OAAO,IAAA,6IAAa,EAAC;QACzB;QAEA,oDAAoD;QACpD,IAAI,IAAI,YAAY,EAAE,SAAS,YAAY;YACvC,MAAM,gBAAgB,MAAM,IAAA,gKAAc,EAAC;YAC3C,IAAI,CAAC,iBAAiB,cAAc,UAAU,KAAK,IAAI,QAAQ,EAAE,IAAI;gBACjE,OAAO,IAAA,6IAAa,EAAC;YACzB;QACJ;QAEA,wCAAwC;QACxC,MAAM,SAAS,MAAM,IAAA,8JAAQ,EAAC;YAC1B;YACA,aAAa,YAAY,EAAE;YAC3B;YACA;YACA,aAAc,IAAI,IAAI,EAAE,MAAM,IAAI,QAAQ,EAAE;QAChD;QAEA,IAAI,CAAC,OAAO,OAAO,EAAE;YACjB,OAAO,IAAA,6IAAa,EAAC,OAAO,OAAO,EAAE;QACzC;QAEA,OAAO,IAAA,+IAAe,EAAC;YACnB,eAAe,OAAO,aAAa;YACnC,QAAQ,OAAO,MAAM;YACrB,SAAS,OAAO,OAAO;QAC3B;IACJ,GACA;QACI,cAAc;IAClB;AAER"}}]
}