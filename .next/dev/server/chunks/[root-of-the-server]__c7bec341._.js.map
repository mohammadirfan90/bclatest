{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/db.ts"],"sourcesContent":["import mysql, { Pool, PoolConnection, RowDataPacket, ResultSetHeader } from 'mysql2/promise';\nimport fs from 'fs';\nimport path from 'path';\n\n// =============================================================================\n// Database Configuration\n// =============================================================================\n\n// Load SSL certificate for Azure MySQL\nconst getSSLConfig = () => {\n  if (process.env.DATABASE_SSL !== 'true') return undefined;\n\n  const certPath = path.join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');\n  try {\n    if (fs.existsSync(certPath)) {\n      return {\n        ca: fs.readFileSync(certPath),\n        rejectUnauthorized: false, // Azure MySQL uses self-signed cert chain\n      };\n    }\n  } catch {\n    console.warn('[DB] SSL certificate not found, using default SSL config');\n  }\n  return { rejectUnauthorized: false };\n};\n\nconst poolConfig = {\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT || '3306'),\n  user: process.env.DATABASE_USER || 'root',\n  password: process.env.DATABASE_PASSWORD || '',\n  database: process.env.DATABASE_NAME || 'bnkcore',\n  waitForConnections: true,\n  connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 0,\n  ssl: getSSLConfig(),\n};\n\n// =============================================================================\n// Connection Pool (Singleton)\n// =============================================================================\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = mysql.createPool(poolConfig);\n\n    // Log pool events in development\n    if (process.env.NODE_ENV === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {\n      pool.on('connection', () => {\n        console.log('[DB] New connection established');\n      });\n\n      pool.on('release', () => {\n        console.log('[DB] Connection released');\n      });\n    }\n  }\n  return pool;\n}\n\n// =============================================================================\n// Query Helpers\n// =============================================================================\n\nexport async function query<T extends RowDataPacket[]>(\n  sql: string,\n  params?: unknown[]\n): Promise<T> {\n  const pool = getPool();\n  const [rows] = await pool.query<T>(sql, params);\n  return rows;\n}\n\nexport async function queryOne<T extends RowDataPacket>(\n  sql: string,\n  params?: unknown[]\n): Promise<T | null> {\n  const rows = await query<T[]>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(\n  sql: string,\n  params?: unknown[]\n): Promise<ResultSetHeader> {\n  const pool = getPool();\n  const [result] = await pool.execute<ResultSetHeader>(sql, params);\n  return result;\n}\n\n// =============================================================================\n// Transaction Helper\n// =============================================================================\n\nexport async function withTransaction<T>(\n  callback: (connection: PoolConnection) => Promise<T>\n): Promise<T> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    await connection.beginTransaction();\n    const result = await callback(connection);\n    await connection.commit();\n    return result;\n  } catch (error) {\n    await connection.rollback();\n    throw error;\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Stored Procedure Caller\n// =============================================================================\n\nexport interface ProcedureResult<T = unknown> {\n  results: T[];\n  outParams: Record<string, unknown>;\n}\n\nexport async function callProcedure<T = unknown>(\n  procedureName: string,\n  inParams: unknown[],\n  outParamNames: string[]\n): Promise<ProcedureResult<T>> {\n  const pool = getPool();\n  const connection = await pool.getConnection();\n\n  try {\n    // Build the CALL statement with parameter placeholders\n    const inPlaceholders = inParams.map(() => '?').join(', ');\n    const outPlaceholders = outParamNames.map((name) => `@${name}`).join(', ');\n    const allPlaceholders = [inPlaceholders, outPlaceholders].filter(Boolean).join(', ');\n\n    const callSql = `CALL ${procedureName}(${allPlaceholders})`;\n\n    // Execute the procedure\n    const [results] = await connection.query(callSql, inParams);\n\n    // Get output parameters\n    const outParams: Record<string, unknown> = {};\n    if (outParamNames.length > 0) {\n      const selectOutSql = `SELECT ${outParamNames.map((name) => `@${name} AS ${name}`).join(', ')}`;\n      const [outRows] = await connection.query<RowDataPacket[]>(selectOutSql);\n      if (outRows[0]) {\n        Object.assign(outParams, outRows[0]);\n      }\n    }\n\n    // Handle multiple result sets from stored procedure\n    const resultSets = Array.isArray(results) ? results : [results];\n    const dataResults = resultSets.filter(\n      (r) => Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0])\n    ) as T[];\n\n    return { results: dataResults, outParams };\n  } finally {\n    connection.release();\n  }\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const pool = getPool();\n    const connection = await pool.getConnection();\n    await connection.ping();\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Cleanup\n// =============================================================================\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n\n// =============================================================================\n// Export types\n// =============================================================================\n\nexport type { Pool, PoolConnection, RowDataPacket, ResultSetHeader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/lib/services/analytics-service.ts"],"sourcesContent":["/**\n * Analytics Service\n * Feature 15: Financial Analytics, Management Reports & Materialized Aggregates\n * \n * Provides functions to query analytics tables and trigger aggregate generation.\n * Analytics data is derived from the ledger and must never be treated as source of truth.\n */\n\nimport { query, queryOne, execute } from '../db';\nimport { RowDataPacket, ResultSetHeader } from 'mysql2/promise';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface DailyTotal {\n    id: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    date: string;\n    openingBalance: number;\n    closingBalance: number;\n    totalDebits: number;\n    totalCredits: number;\n    debitCount: number;\n    creditCount: number;\n}\n\nexport interface MonthlySummary {\n    id: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    year: number;\n    month: number;\n    openingBalance: number;\n    closingBalance: number;\n    totalDebits: number;\n    totalCredits: number;\n    debitCount: number;\n    creditCount: number;\n    avgDailyBalance: number;\n    interestEarned: number;\n    feesCharged: number;\n}\n\nexport interface DailyTransactionSummary {\n    date: string;\n    totalDeposits: number;\n    totalWithdrawals: number;\n    transactionCount: number;\n    volume: number;\n}\n\nexport interface TopAccount {\n    rank: number;\n    accountId: number;\n    accountNumber: string;\n    customerName: string;\n    category: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME';\n    metricValue: number;\n}\n\nexport interface SystemTotals {\n    totalAccounts: number;\n    totalActiveAccounts: number;\n    totalVolume: number;\n    totalDeposits: number;\n    totalWithdrawals: number;\n    totalTransactions: number;\n    avgAccountBalance: number;\n}\n\nexport interface AggregateGenerationResult {\n    accountsProcessed: number;\n    status: string;\n    message: string;\n}\n\nexport interface RebuildResult {\n    dailyRows: number;\n    monthlyRows: number;\n    status: string;\n    message: string;\n}\n\n// =============================================================================\n// Row Types\n// =============================================================================\n\ninterface DailyTotalRow extends RowDataPacket {\n    id: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    date: Date;\n    opening_balance: string;\n    closing_balance: string;\n    total_debits: string;\n    total_credits: string;\n    debit_count: number;\n    credit_count: number;\n}\n\ninterface MonthlySummaryRow extends RowDataPacket {\n    id: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    year: number;\n    month: number;\n    opening_balance: string;\n    closing_balance: string;\n    total_debits: string;\n    total_credits: string;\n    debit_count: number;\n    credit_count: number;\n    avg_daily_balance: string;\n    interest_earned: string;\n    fees_charged: string;\n}\n\ninterface TopAccountRow extends RowDataPacket {\n    rank_position: number;\n    account_id: number;\n    account_number: string;\n    customer_name: string;\n    category: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME';\n    metric_value: string;\n}\n\ninterface SystemTotalsRow extends RowDataPacket {\n    total_accounts: number;\n    total_active_accounts: number;\n    total_volume: string;\n    total_deposits: string;\n    total_withdrawals: string;\n    total_transactions: number;\n    avg_account_balance: string;\n}\n\n// =============================================================================\n// Daily Totals\n// =============================================================================\n\n/**\n * Get daily totals for a specific date\n */\nexport async function getDailyTotals(\n    date: string,\n    options: { accountId?: number; page?: number; size?: number } = {}\n): Promise<{ totals: DailyTotal[]; total: number }> {\n    const { accountId, page = 1, size = 50 } = options;\n    const offset = (page - 1) * size;\n\n    let whereClause = 'WHERE dat.date = ?';\n    const params: (string | number)[] = [date];\n\n    if (accountId) {\n        whereClause += ' AND dat.account_id = ?';\n        params.push(accountId);\n    }\n\n    // Get count\n    const countResult = await queryOne<{ count: number } & RowDataPacket>(\n        `SELECT COUNT(*) as count \n         FROM daily_account_totals dat \n         ${whereClause}`,\n        params\n    );\n\n    // Get data\n    const rows = await query<DailyTotalRow[]>(\n        `SELECT dat.id, dat.account_id, a.account_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                dat.date, dat.opening_balance, dat.closing_balance,\n                dat.total_debits, dat.total_credits,\n                dat.debit_count, dat.credit_count\n         FROM daily_account_totals dat\n         INNER JOIN accounts a ON a.id = dat.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         ORDER BY dat.closing_balance DESC\n         LIMIT ? OFFSET ?`,\n        [...params, size, offset]\n    );\n\n    return {\n        totals: rows.map(row => ({\n            id: row.id,\n            accountId: row.account_id,\n            accountNumber: row.account_number,\n            customerName: row.customer_name,\n            date: row.date.toISOString().split('T')[0],\n            openingBalance: parseFloat(row.opening_balance),\n            closingBalance: parseFloat(row.closing_balance),\n            totalDebits: parseFloat(row.total_debits),\n            totalCredits: parseFloat(row.total_credits),\n            debitCount: row.debit_count,\n            creditCount: row.credit_count,\n        })),\n        total: countResult?.count || 0,\n    };\n}\n\n/**\n * Get system-wide totals for a specific date\n */\nexport async function getDailySystemTotals(date: string): Promise<SystemTotals> {\n    const row = await queryOne<SystemTotalsRow>(\n        `SELECT \n            COUNT(DISTINCT dat.account_id) as total_accounts,\n            COUNT(DISTINCT CASE WHEN a.status = 'ACTIVE' THEN a.id END) as total_active_accounts,\n            COALESCE(SUM(dat.total_debits + dat.total_credits), 0) as total_volume,\n            COALESCE(SUM(dat.total_credits), 0) as total_deposits,\n            COALESCE(SUM(dat.total_debits), 0) as total_withdrawals,\n            COALESCE(SUM(dat.debit_count + dat.credit_count), 0) as total_transactions,\n            COALESCE(AVG(dat.closing_balance), 0) as avg_account_balance\n         FROM daily_account_totals dat\n         INNER JOIN accounts a ON a.id = dat.account_id\n         WHERE dat.date = ?`,\n        [date]\n    );\n\n    return {\n        totalAccounts: row?.total_accounts || 0,\n        totalActiveAccounts: row?.total_active_accounts || 0,\n        totalVolume: parseFloat(row?.total_volume || '0'),\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        totalTransactions: row?.total_transactions || 0,\n        avgAccountBalance: parseFloat(row?.avg_account_balance || '0'),\n    };\n}\n\n/**\n * Get daily transaction summary directly from ledger_entries\n * ADHERES TO NON-NEGOTIABLE RULE: Compute on-the-fly from ledger_entries\n */\nexport async function getDailyTransactionSummary(date: string): Promise<DailyTransactionSummary> {\n    const row = await queryOne<RowDataPacket>(\n        `SELECT \n            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_deposits,\n            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_withdrawals,\n            COUNT(DISTINCT transaction_id) as transaction_count,\n            COALESCE(SUM(amount), 0) as volume\n         FROM ledger_entries\n         WHERE entry_date = ?`,\n        [date]\n    );\n\n    const result = {\n        date,\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        transactionCount: row?.transaction_count || 0,\n        volume: parseFloat(row?.volume || '0'),\n    };\n\n    // DEBUG: Write to a file since terminal output is hard to capture\n    try {\n        const fs = require('fs');\n        const logMsg = `[${new Date().toISOString()}] getDailyTransactionSummary date=${date} result=${JSON.stringify(result)}\\n`;\n        fs.appendFileSync('service_debug.log', logMsg);\n    } catch (e) { }\n\n    return result;\n}\n\n// =============================================================================\n// Monthly Summaries\n// =============================================================================\n\n/**\n * Get monthly summaries for a specific month\n */\nexport async function getMonthlySummaries(\n    year: number,\n    month: number,\n    options: { accountId?: number; page?: number; size?: number } = {}\n): Promise<{ summaries: MonthlySummary[]; total: number }> {\n    const { accountId, page = 1, size = 50 } = options;\n    const offset = (page - 1) * size;\n\n    let whereClause = 'WHERE mas.year = ? AND mas.month = ?';\n    const params: (number)[] = [year, month];\n\n    if (accountId) {\n        whereClause += ' AND mas.account_id = ?';\n        params.push(accountId);\n    }\n\n    // Get count\n    const countResult = await queryOne<{ count: number } & RowDataPacket>(\n        `SELECT COUNT(*) as count \n         FROM monthly_account_summaries mas \n         ${whereClause}`,\n        params\n    );\n\n    // Get data\n    const rows = await query<MonthlySummaryRow[]>(\n        `SELECT mas.id, mas.account_id, a.account_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                mas.year, mas.month, mas.opening_balance, mas.closing_balance,\n                mas.total_debits, mas.total_credits,\n                mas.debit_count, mas.credit_count,\n                mas.avg_daily_balance, mas.interest_earned, mas.fees_charged\n         FROM monthly_account_summaries mas\n         INNER JOIN accounts a ON a.id = mas.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         ORDER BY mas.closing_balance DESC\n         LIMIT ? OFFSET ?`,\n        [...params, size, offset]\n    );\n\n    return {\n        summaries: rows.map(row => ({\n            id: row.id,\n            accountId: row.account_id,\n            accountNumber: row.account_number,\n            customerName: row.customer_name,\n            year: row.year,\n            month: row.month,\n            openingBalance: parseFloat(row.opening_balance),\n            closingBalance: parseFloat(row.closing_balance),\n            totalDebits: parseFloat(row.total_debits),\n            totalCredits: parseFloat(row.total_credits),\n            debitCount: row.debit_count,\n            creditCount: row.credit_count,\n            avgDailyBalance: parseFloat(row.avg_daily_balance),\n            interestEarned: parseFloat(row.interest_earned),\n            feesCharged: parseFloat(row.fees_charged),\n        })),\n        total: countResult?.count || 0,\n    };\n}\n\n/**\n * Get system-wide totals for a specific month\n */\nexport async function getMonthlySystemTotals(year: number, month: number): Promise<SystemTotals> {\n    const row = await queryOne<SystemTotalsRow>(\n        `SELECT \n            COUNT(DISTINCT mas.account_id) as total_accounts,\n            COUNT(DISTINCT CASE WHEN a.status = 'ACTIVE' THEN a.id END) as total_active_accounts,\n            COALESCE(SUM(mas.total_debits + mas.total_credits), 0) as total_volume,\n            COALESCE(SUM(mas.total_credits), 0) as total_deposits,\n            COALESCE(SUM(mas.total_debits), 0) as total_withdrawals,\n            COALESCE(SUM(mas.debit_count + mas.credit_count), 0) as total_transactions,\n            COALESCE(AVG(mas.avg_daily_balance), 0) as avg_account_balance\n         FROM monthly_account_summaries mas\n         INNER JOIN accounts a ON a.id = mas.account_id\n         WHERE mas.year = ? AND mas.month = ?`,\n        [year, month]\n    );\n\n    return {\n        totalAccounts: row?.total_accounts || 0,\n        totalActiveAccounts: row?.total_active_accounts || 0,\n        totalVolume: parseFloat(row?.total_volume || '0'),\n        totalDeposits: parseFloat(row?.total_deposits || '0'),\n        totalWithdrawals: parseFloat(row?.total_withdrawals || '0'),\n        totalTransactions: row?.total_transactions || 0,\n        avgAccountBalance: parseFloat(row?.avg_account_balance || '0'),\n    };\n}\n\n// =============================================================================\n// Top Accounts\n// =============================================================================\n\n/**\n * Get top accounts for a specific month and category\n */\nexport async function getTopAccounts(\n    year: number,\n    month: number,\n    category?: 'HIGHEST_BALANCE' | 'MOST_TRANSACTIONS' | 'HIGHEST_VOLUME'\n): Promise<TopAccount[]> {\n    let whereClause = 'WHERE tam.year = ? AND tam.month = ?';\n    const params: (number | string)[] = [year, month];\n\n    if (category) {\n        whereClause += ' AND tam.category = ?';\n        params.push(category);\n    }\n\n    const rows = await query<TopAccountRow[]>(\n        `SELECT tam.rank_position, tam.account_id, a.account_number,\n                CONCAT(c.first_name, ' ', c.last_name) as customer_name,\n                tam.category, tam.metric_value\n         FROM top_accounts_monthly tam\n         INNER JOIN accounts a ON a.id = tam.account_id\n         INNER JOIN customers c ON c.id = a.customer_id\n         ${whereClause}\n         ORDER BY tam.category, tam.rank_position`,\n        params\n    );\n\n    return rows.map(row => ({\n        rank: row.rank_position,\n        accountId: row.account_id,\n        accountNumber: row.account_number,\n        customerName: row.customer_name,\n        category: row.category,\n        metricValue: parseFloat(row.metric_value),\n    }));\n}\n\n// =============================================================================\n// Aggregate Generation & Rebuild\n// =============================================================================\n\n/**\n * Generate monthly aggregates for a specific month\n * Calls sp_generate_monthly_aggregates stored procedure\n */\nexport async function generateMonthlyAggregates(\n    year: number,\n    month: number,\n    userId: number\n): Promise<AggregateGenerationResult> {\n    // Call the stored procedure\n    await execute(\n        `CALL sp_generate_monthly_aggregates(?, ?, ?, @accounts_processed, @status, @message)`,\n        [year, month, userId]\n    );\n\n    // Get output parameters\n    const result = await queryOne<{\n        accounts_processed: number;\n        status: string;\n        message: string;\n    } & RowDataPacket>(\n        `SELECT @accounts_processed as accounts_processed, @status as status, @message as message`\n    );\n\n    return {\n        accountsProcessed: result?.accounts_processed || 0,\n        status: result?.status || 'UNKNOWN',\n        message: result?.message || '',\n    };\n}\n\n/**\n * Rebuild all analytics tables from ledger\n * Admin-only operation - can be long-running\n */\nexport async function rebuildAnalytics(userId: number): Promise<RebuildResult> {\n    // Call the stored procedure\n    await execute(\n        `CALL sp_rebuild_analytics(?, @daily_rows, @monthly_rows, @status, @message)`,\n        [userId]\n    );\n\n    // Get output parameters\n    const result = await queryOne<{\n        daily_rows: number;\n        monthly_rows: number;\n        status: string;\n        message: string;\n    } & RowDataPacket>(\n        `SELECT @daily_rows as daily_rows, @monthly_rows as monthly_rows, @status as status, @message as message`\n    );\n\n    return {\n        dailyRows: result?.daily_rows || 0,\n        monthlyRows: result?.monthly_rows || 0,\n        status: result?.status || 'UNKNOWN',\n        message: result?.message || '',\n    };\n}\n\n// =============================================================================\n// Available Periods\n// =============================================================================\n\n/**\n * Get list of months with available analytics data\n */\nexport async function getAvailablePeriods(): Promise<{ year: number; month: number }[]> {\n    const rows = await query<({ year: number; month: number } & RowDataPacket)[]>(\n        `SELECT DISTINCT year, month \n         FROM monthly_account_summaries \n         ORDER BY year DESC, month DESC \n         LIMIT 24`\n    );\n\n    return rows.map(row => ({\n        year: row.year,\n        month: row.month,\n    }));\n}\n\n/**\n * Get list of dates with available daily analytics data\n */\nexport async function getAvailableDates(limit: number = 30): Promise<string[]> {\n    const rows = await query<({ date: Date } & RowDataPacket)[]>(\n        `SELECT DISTINCT date \n         FROM daily_account_totals \n         ORDER BY date DESC \n         LIMIT ?`,\n        [limit]\n    );\n\n    return rows.map(row => row.date.toISOString().split('T')[0]);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["file:///E:/octo-fortnight-main/src/app/api/v1/debug/reports/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getDailyTransactionSummary } from '@/lib/services/analytics-service';\r\n\r\nexport async function GET(request: NextRequest) {\r\n    const { searchParams } = new URL(request.url);\r\n    const date = searchParams.get('date') || '2026-01-17';\r\n\r\n    try {\r\n        const liveSummary = await getDailyTransactionSummary(date);\r\n        return NextResponse.json({ date, liveSummary });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC1C,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,OAAO,aAAa,GAAG,CAAC,WAAW;IAEzC,IAAI;QACA,MAAM,cAAc,MAAM,IAAA,8KAA0B,EAAC;QACrD,OAAO,+PAAY,CAAC,IAAI,CAAC;YAAE;YAAM;QAAY;IACjD,EAAE,OAAO,OAAY;QACjB,OAAO,+PAAY,CAAC,IAAI,CAAC;YAAE,OAAO,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrE;AACJ"}}]
}