module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/src/lib/db.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "callProcedure",
    ()=>callProcedure,
    "checkConnection",
    ()=>checkConnection,
    "closePool",
    ()=>closePool,
    "execute",
    ()=>execute,
    "getPool",
    ()=>getPool,
    "query",
    ()=>query,
    "queryOne",
    ()=>queryOne,
    "withTransaction",
    ()=>withTransaction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mysql2$40$3$2e$16$2e$0$2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mysql2@3.16.0/node_modules/mysql2/promise.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
// =============================================================================
// Database Configuration
// =============================================================================
// Load SSL certificate for Azure MySQL
const getSSLConfig = ()=>{
    if (process.env.DATABASE_SSL !== 'true') return undefined;
    const certPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'cert', 'DigiCertGlobalRootCA.crt');
    try {
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(certPath)) {
            return {
                ca: __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(certPath),
                rejectUnauthorized: false
            };
        }
    } catch  {
        console.warn('[DB] SSL certificate not found, using default SSL config');
    }
    return {
        rejectUnauthorized: false
    };
};
const poolConfig = {
    host: process.env.DATABASE_HOST || 'localhost',
    port: parseInt(process.env.DATABASE_PORT || '3306'),
    user: process.env.DATABASE_USER || 'root',
    password: process.env.DATABASE_PASSWORD || '',
    database: process.env.DATABASE_NAME || 'bnkcore',
    waitForConnections: true,
    connectionLimit: parseInt(process.env.DATABASE_POOL_MAX || '10'),
    queueLimit: 0,
    enableKeepAlive: true,
    keepAliveInitialDelay: 0,
    ssl: getSSLConfig()
};
// =============================================================================
// Connection Pool (Singleton)
// =============================================================================
let pool = null;
function getPool() {
    if (!pool) {
        pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mysql2$40$3$2e$16$2e$0$2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool(poolConfig);
        // Log pool events in development
        if (("TURBOPACK compile-time value", "development") === 'development' && process.env.ENABLE_QUERY_LOGGING === 'true') {
            pool.on('connection', ()=>{
                console.log('[DB] New connection established');
            });
            pool.on('release', ()=>{
                console.log('[DB] Connection released');
            });
        }
    }
    return pool;
}
async function query(sql, params) {
    const pool = getPool();
    const [rows] = await pool.query(sql, params);
    return rows;
}
async function queryOne(sql, params) {
    const rows = await query(sql, params);
    return rows[0] || null;
}
async function execute(sql, params) {
    const pool = getPool();
    const [result] = await pool.execute(sql, params);
    return result;
}
async function withTransaction(callback) {
    const pool = getPool();
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();
        const result = await callback(connection);
        await connection.commit();
        return result;
    } catch (error) {
        await connection.rollback();
        throw error;
    } finally{
        connection.release();
    }
}
async function callProcedure(procedureName, inParams, outParamNames) {
    const pool = getPool();
    const connection = await pool.getConnection();
    try {
        // Build the CALL statement with parameter placeholders
        const inPlaceholders = inParams.map(()=>'?').join(', ');
        const outPlaceholders = outParamNames.map((name)=>`@${name}`).join(', ');
        const allPlaceholders = [
            inPlaceholders,
            outPlaceholders
        ].filter(Boolean).join(', ');
        const callSql = `CALL ${procedureName}(${allPlaceholders})`;
        // Execute the procedure
        const [results] = await connection.query(callSql, inParams);
        // Get output parameters
        const outParams = {};
        if (outParamNames.length > 0) {
            const selectOutSql = `SELECT ${outParamNames.map((name)=>`@${name} AS ${name}`).join(', ')}`;
            const [outRows] = await connection.query(selectOutSql);
            if (outRows[0]) {
                Object.assign(outParams, outRows[0]);
            }
        }
        // Handle multiple result sets from stored procedure
        const resultSets = Array.isArray(results) ? results : [
            results
        ];
        const dataResults = resultSets.filter((r)=>Array.isArray(r) && r.length > 0 && !('affectedRows' in r[0]));
        return {
            results: dataResults,
            outParams
        };
    } finally{
        connection.release();
    }
}
async function checkConnection() {
    try {
        const pool = getPool();
        const connection = await pool.getConnection();
        await connection.ping();
        connection.release();
        return true;
    } catch  {
        return false;
    }
}
async function closePool() {
    if (pool) {
        await pool.end();
        pool = null;
    }
}
}),
"[project]/src/lib/services/auth-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "authenticateCustomer",
    ()=>authenticateCustomer,
    "authenticateUser",
    ()=>authenticateUser,
    "createCustomer",
    ()=>createCustomer,
    "createUser",
    ()=>createUser,
    "generateRefreshToken",
    ()=>generateRefreshToken,
    "generateToken",
    ()=>generateToken,
    "getSession",
    ()=>getSession,
    "hasAllPermissions",
    ()=>hasAllPermissions,
    "hasAnyPermission",
    ()=>hasAnyPermission,
    "hasPermission",
    ()=>hasPermission,
    "hashPassword",
    ()=>hashPassword,
    "isAnyRole",
    ()=>isAnyRole,
    "isRole",
    ()=>isRole,
    "logout",
    ()=>logout,
    "refreshAccessToken",
    ()=>refreshAccessToken,
    "verifyPassword",
    ()=>verifyPassword,
    "verifyToken",
    ()=>verifyToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bcryptjs$40$3$2e$0$2e$3$2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/bcryptjs@3.0.3/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$jsonwebtoken$40$9$2e$0$2e$3$2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/jsonwebtoken@9.0.3/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.ts [app-route] (ecmascript)");
// =============================================================================
// Session Helper for Next.js App Router
// =============================================================================
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.2_cd686fafa065e16de73e229f5879b04d/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
;
// =============================================================================
// Configuration
// =============================================================================
const JWT_SECRET = process.env.JWT_SECRET || 'development-secret-change-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';
const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';
const BCRYPT_ROUNDS = 12;
const MAX_FAILED_ATTEMPTS = 5;
async function hashPassword(password) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bcryptjs$40$3$2e$0$2e$3$2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, BCRYPT_ROUNDS);
}
async function verifyPassword(password, hash) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bcryptjs$40$3$2e$0$2e$3$2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].compare(password, hash);
}
function generateToken(payload) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$jsonwebtoken$40$9$2e$0$2e$3$2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
}
function generateRefreshToken(payload) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$jsonwebtoken$40$9$2e$0$2e$3$2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign({
        ...payload,
        refresh: true
    }, JWT_SECRET, {
        expiresIn: JWT_REFRESH_EXPIRES_IN
    });
}
function verifyToken(token) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$jsonwebtoken$40$9$2e$0$2e$3$2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, JWT_SECRET);
    } catch  {
        return null;
    }
}
async function authenticateUser(email, password) {
    const userRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name,
            u.role_id, r.code as role_code, r.name as role_name, r.permissions,
            u.status
     FROM users u
     INNER JOIN roles r ON r.id = u.role_id
     WHERE u.email = ?`, [
        email
    ]);
    if (!userRow) {
        return {
            success: false,
            error: 'Invalid email or password'
        };
    }
    if (userRow.status !== 'ACTIVE') {
        return {
            success: false,
            error: 'Account is not active'
        };
    }
    // Verify password
    const passwordValid = await verifyPassword(password, userRow.password_hash);
    if (!passwordValid) {
        return {
            success: false,
            error: 'Invalid email or password'
        };
    }
    // Update last login
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])('UPDATE users SET last_login_at = NOW() WHERE id = ?', [
        userRow.id
    ]);
    // Parse permissions (MySQL may return JSON as already-parsed array)
    const permissions = Array.isArray(userRow.permissions) ? userRow.permissions : JSON.parse(userRow.permissions || '[]');
    const user = {
        id: userRow.id,
        email: userRow.email,
        firstName: userRow.first_name,
        lastName: userRow.last_name,
        roleId: userRow.role_id,
        roleCode: userRow.role_code,
        roleName: userRow.role_name,
        permissions,
        status: userRow.status,
        mfaEnabled: false
    };
    // Generate tokens
    const token = generateToken({
        sub: userRow.id.toString(),
        type: 'user',
        email: userRow.email,
        role: userRow.role_code,
        permissions,
        tokenVersion: 1
    });
    const refreshToken = generateRefreshToken({
        sub: userRow.id.toString(),
        type: 'user',
        email: userRow.email,
        role: userRow.role_code,
        tokenVersion: 1
    });
    return {
        success: true,
        user,
        token,
        refreshToken
    };
}
async function authenticateCustomer(email, password) {
    const customerRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT id, customer_number, email, password_hash, first_name, last_name,
            status, kyc_status
     FROM customers
     WHERE email = ?`, [
        email
    ]);
    if (!customerRow) {
        console.log(`[Auth] Customer not found: ${email}`);
        return {
            success: false,
            error: 'Invalid email or password'
        };
    }
    console.log(`[Auth] Customer found: ${customerRow.id}, Status: ${customerRow.status}`);
    if (customerRow.status === 'SUSPENDED') {
        return {
            success: false,
            error: 'Account is suspended. Please contact support.'
        };
    }
    if (customerRow.status !== 'ACTIVE' && customerRow.status !== 'PENDING') {
        return {
            success: false,
            error: 'Account is not active'
        };
    }
    // Verify password
    const passwordValid = await verifyPassword(password, customerRow.password_hash);
    console.log(`[Auth] Password valid: ${passwordValid}`);
    if (!passwordValid) {
        return {
            success: false,
            error: 'Invalid email or password'
        };
    }
    const customer = {
        id: customerRow.id,
        customerNumber: customerRow.customer_number,
        email: customerRow.email,
        firstName: customerRow.first_name,
        lastName: customerRow.last_name,
        status: customerRow.status,
        kycStatus: customerRow.kyc_status
    };
    const token = generateToken({
        sub: customerRow.id.toString(),
        type: 'customer',
        email: customerRow.email,
        tokenVersion: 1
    });
    const refreshToken = generateRefreshToken({
        sub: customerRow.id.toString(),
        type: 'customer',
        email: customerRow.email,
        tokenVersion: 1
    });
    return {
        success: true,
        user: customer,
        token,
        refreshToken
    };
}
async function refreshAccessToken(refreshToken) {
    const payload = verifyToken(refreshToken);
    if (!payload) {
        return {
            success: false,
            error: 'Invalid refresh token'
        };
    }
    if (payload.type === 'user') {
        const userRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT u.id, u.email, r.code as role_code, r.permissions
       FROM users u
       INNER JOIN roles r ON r.id = u.role_id
       WHERE u.id = ? AND u.status = 'ACTIVE'`, [
            payload.sub
        ]);
        if (!userRow) {
            return {
                success: false,
                error: 'User not found or inactive'
            };
        }
        const permissions = Array.isArray(userRow.permissions) ? userRow.permissions : JSON.parse(userRow.permissions || '[]');
        const newToken = generateToken({
            sub: userRow.id.toString(),
            type: 'user',
            email: userRow.email,
            role: userRow.role_code,
            permissions,
            tokenVersion: 1
        });
        return {
            success: true,
            token: newToken
        };
    }
    if (payload.type === 'customer') {
        const customerRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT id, email FROM customers WHERE id = ? AND status = 'ACTIVE'`, [
            payload.sub
        ]);
        if (!customerRow) {
            return {
                success: false,
                error: 'Customer not found or inactive'
            };
        }
        const newToken = generateToken({
            sub: customerRow.id.toString(),
            type: 'customer',
            email: customerRow.email,
            tokenVersion: 1
        });
        return {
            success: true,
            token: newToken
        };
    }
    return {
        success: false,
        error: 'Invalid token type'
    };
}
async function createUser(email, password, firstName, lastName, roleId, createdBy) {
    const passwordHash = await hashPassword(password);
    try {
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])(`INSERT INTO users (email, password_hash, first_name, last_name, role_id, status, created_by, password_changed_at)
       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?, NOW())`, [
            email,
            passwordHash,
            firstName,
            lastName,
            roleId,
            createdBy ?? null
        ]);
        return {
            success: true,
            userId: result.insertId
        };
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            return {
                success: false,
                error: 'Email already exists'
            };
        }
        throw error;
    }
}
async function createCustomer(email, password, firstName, lastName, createdBy) {
    const passwordHash = await hashPassword(password);
    // Generate customer number
    const customerNumber = `C${Date.now().toString().slice(-10)}`;
    try {
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])(`INSERT INTO customers (customer_number, email, password_hash, first_name, last_name, status, created_by)
       VALUES (?, ?, ?, ?, ?, 'ACTIVE', ?)`, [
            customerNumber,
            email,
            passwordHash,
            firstName,
            lastName,
            createdBy ?? null
        ]);
        return {
            success: true,
            customerId: result.insertId,
            customerNumber
        };
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            return {
                success: false,
                error: 'Email already exists'
            };
        }
        throw error;
    }
}
function hasPermission(user, permission) {
    return user.permissions.includes(permission);
}
function hasAnyPermission(user, permissions) {
    return permissions.some((p)=>user.permissions.includes(p));
}
function hasAllPermissions(user, permissions) {
    return permissions.every((p)=>user.permissions.includes(p));
}
function isRole(user, role) {
    return user.roleCode === role;
}
function isAnyRole(user, roles) {
    return roles.includes(user.roleCode);
}
async function logout(userId, type) {
    const table = type === 'user' ? 'users' : 'customers';
    // Increment token version to invalidate all existing tokens
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])(`UPDATE ${table} SET token_version = token_version + 1 WHERE id = ?`, [
        userId
    ]);
    // Also remove any active sessions
    if (type === 'user') {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])('DELETE FROM user_sessions WHERE user_id = ?', [
            userId
        ]);
    }
}
;
async function getSession() {
    try {
        const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
        const headerList = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headers"])();
        let token = cookieStore.get('token')?.value;
        if (!token) {
            const authHeader = headerList.get('Authorization');
            if (authHeader?.startsWith('Bearer ')) {
                token = authHeader.substring(7);
            }
        }
        if (!token) return null;
        const payload = verifyToken(token);
        if (!payload) return null;
        if (payload.type === 'user') {
            const userRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT u.id, u.email, u.first_name, u.last_name, u.role_id, r.code as role_code, r.name as role_name, r.permissions, u.status
             FROM users u
             JOIN roles r ON r.id = u.role_id
             WHERE u.id = ?`, [
                payload.sub
            ]);
            if (!userRow) return null;
            const permissions = Array.isArray(userRow.permissions) ? userRow.permissions : JSON.parse(userRow.permissions || '[]');
            return {
                user: {
                    ...userRow,
                    firstName: userRow.first_name,
                    lastName: userRow.last_name,
                    roleId: userRow.role_id,
                    roleCode: userRow.role_code,
                    roleName: userRow.role_name,
                    permissions,
                    mfaEnabled: false
                },
                role: userRow.role_code
            };
        }
        if (payload.type === 'customer') {
            const customerRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT id, customer_number, email, first_name, last_name, status, kyc_status
             FROM customers WHERE id = ?`, [
                payload.sub
            ]);
            if (!customerRow) return null;
            return {
                user: {
                    ...customerRow,
                    customerNumber: customerRow.customer_number,
                    firstName: customerRow.first_name,
                    lastName: customerRow.last_name,
                    kycStatus: customerRow.kyc_status
                },
                role: 'CUSTOMER'
            };
        }
        return null;
    } catch (e) {
        return null;
    }
}
}),
"[project]/src/lib/api-utils.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkIdempotency",
    ()=>checkIdempotency,
    "createdResponse",
    ()=>createdResponse,
    "errorResponse",
    ()=>errorResponse,
    "forbiddenResponse",
    ()=>forbiddenResponse,
    "getIdempotencyKey",
    ()=>getIdempotencyKey,
    "getOffset",
    ()=>getOffset,
    "getPaginationMeta",
    ()=>getPaginationMeta,
    "notFoundResponse",
    ()=>notFoundResponse,
    "requireIdempotencyKey",
    ()=>requireIdempotencyKey,
    "serverErrorResponse",
    ()=>serverErrorResponse,
    "successResponse",
    ()=>successResponse,
    "unauthorizedResponse",
    ()=>unauthorizedResponse,
    "validateBody",
    ()=>validateBody,
    "validateQuery",
    ()=>validateQuery,
    "validationErrorResponse",
    ()=>validationErrorResponse,
    "withAuth",
    ()=>withAuth,
    "withErrorHandler",
    ()=>withErrorHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.2_cd686fafa065e16de73e229f5879b04d/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$auth$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/services/auth-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$4$2e$3$2e$5$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/errors.js [app-route] (ecmascript)");
;
;
;
;
function successResponse(data, meta) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: true,
        data,
        meta
    }, {
        status: 200
    });
}
function createdResponse(data) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: true,
        data
    }, {
        status: 201
    });
}
function errorResponse(error, status = 400) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error
    }, {
        status
    });
}
function validationErrorResponse(errors) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error: 'Validation failed',
        errors
    }, {
        status: 400
    });
}
function unauthorizedResponse(error = 'Unauthorized') {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error
    }, {
        status: 401
    });
}
function forbiddenResponse(error = 'Forbidden') {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error
    }, {
        status: 403
    });
}
function notFoundResponse(error = 'Not found') {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error
    }, {
        status: 404
    });
}
function serverErrorResponse(error = 'Internal server error') {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        success: false,
        error
    }, {
        status: 500
    });
}
async function withAuth(request, handler, options = {}) {
    const { requiredType = 'any', requiredRoles, requiredPermissions, hideFailure = false } = options;
    // Helper to return 404 if hideFailure is on, otherwise the actual error
    const getErrorResponse = (actualResponse)=>{
        return hideFailure ? notFoundResponse() : actualResponse;
    };
    // Get token from header
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return getErrorResponse(unauthorizedResponse('No token provided'));
    }
    const token = authHeader.substring(7);
    const payload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$auth$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyToken"])(token);
    if (!payload) {
        return getErrorResponse(unauthorizedResponse('Invalid or expired token'));
    }
    // Check required type
    if (requiredType !== 'any' && payload.type !== requiredType) {
        return getErrorResponse(forbiddenResponse(`Access restricted to ${requiredType}s`));
    }
    const authenticatedRequest = request;
    authenticatedRequest.tokenPayload = payload;
    // For user tokens, load full user info
    if (payload.type === 'user') {
        const [userRow] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT u.id, u.email, u.first_name, u.last_name, u.role_id,
              r.code as role_code, r.name as role_name, r.permissions,
              u.status
       FROM users u
       INNER JOIN roles r ON r.id = u.role_id
       WHERE u.id = ? AND u.status = 'ACTIVE'`, [
            payload.sub
        ]);
        if (!userRow) {
            return getErrorResponse(unauthorizedResponse('User not found or inactive'));
        }
        // Safely parse permissions - handle invalid JSON gracefully
        let permissions = [];
        try {
            const rawPerms = userRow.permissions;
            if (rawPerms && typeof rawPerms === 'string' && rawPerms.startsWith('[')) {
                permissions = JSON.parse(rawPerms);
            } else if (Array.isArray(rawPerms)) {
                permissions = rawPerms;
            }
        } catch (e) {
            console.warn('Invalid permissions JSON, defaulting to empty array');
            permissions = [];
        }
        authenticatedRequest.user = {
            id: userRow.id,
            email: userRow.email,
            firstName: userRow.first_name,
            lastName: userRow.last_name,
            roleId: userRow.role_id,
            roleCode: userRow.role_code,
            roleName: userRow.role_name,
            permissions,
            status: userRow.status,
            mfaEnabled: false
        };
        // Check required roles
        if (requiredRoles && requiredRoles.length > 0) {
            if (!requiredRoles.includes(userRow.role_code)) {
                return getErrorResponse(forbiddenResponse('Insufficient role privileges'));
            }
        }
        // Check required permissions
        if (requiredPermissions && requiredPermissions.length > 0) {
            const hasPermission = requiredPermissions.some((p)=>permissions.includes(p));
            if (!hasPermission) {
                return getErrorResponse(forbiddenResponse('Insufficient permissions'));
            }
        }
    }
    // For customer tokens
    if (payload.type === 'customer') {
        const [customerRow] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT id, customer_number, email, status
       FROM customers
       WHERE id = ? AND status = 'ACTIVE'`, [
            payload.sub
        ]);
        if (!customerRow) {
            return unauthorizedResponse('Customer not found or inactive');
        }
        authenticatedRequest.customer = {
            id: customerRow.id,
            customerNumber: customerRow.customer_number,
            email: customerRow.email
        };
    }
    return handler(authenticatedRequest);
}
async function validateBody(request, schema) {
    try {
        const body = await request.json();
        const data = schema.parse(body);
        return {
            success: true,
            data
        };
    } catch (error) {
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$4$2e$3$2e$5$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodError"]) {
            const errors = error.issues.map((e)=>({
                    field: e.path.join('.'),
                    message: e.message
                }));
            return {
                success: false,
                response: validationErrorResponse(errors)
            };
        }
        return {
            success: false,
            response: errorResponse('Invalid request body')
        };
    }
}
function validateQuery(request, schema) {
    try {
        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());
        const data = schema.parse(searchParams);
        return {
            success: true,
            data
        };
    } catch (error) {
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$zod$40$4$2e$3$2e$5$2f$node_modules$2f$zod$2f$v4$2f$classic$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodError"]) {
            const errors = error.issues.map((e)=>({
                    field: e.path.join('.'),
                    message: e.message
                }));
            return {
                success: false,
                response: validationErrorResponse(errors)
            };
        }
        return {
            success: false,
            response: errorResponse('Invalid query parameters')
        };
    }
}
function getIdempotencyKey(request) {
    return request.headers.get('Idempotency-Key') || request.headers.get('idempotency-key') || null;
}
function requireIdempotencyKey(request) {
    const key = getIdempotencyKey(request);
    if (!key) {
        return {
            success: false,
            response: errorResponse('Idempotency-Key header is required for this operation', 400)
        };
    }
    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(key)) {
        return {
            success: false,
            response: errorResponse('Invalid Idempotency-Key format. Must be a valid UUID.', 400)
        };
    }
    return {
        success: true,
        key
    };
}
async function checkIdempotency(idempotencyKey) {
    if (!idempotencyKey) {
        return {
            cached: false
        };
    }
    const [cached] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT response_status, response_body
     FROM idempotency_keys
     WHERE idempotency_key = ? AND expires_at > NOW()`, [
        idempotencyKey
    ]);
    if (cached) {
        const body = JSON.parse(cached.response_body);
        return {
            cached: true,
            response: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$2_cd686fafa065e16de73e229f5879b04d$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(body, {
                status: cached.response_status
            })
        };
    }
    return {
        cached: false
    };
}
function withErrorHandler(handler) {
    return async (request, context)=>{
        try {
            // Context is optional - routes without dynamic params won't have it
            return await handler(request, context);
        } catch (error) {
            console.error('API Error:', error);
            if (error instanceof Error) {
                // Don't expose internal error messages in production
                const message = ("TURBOPACK compile-time truthy", 1) ? error.message : "TURBOPACK unreachable";
                return serverErrorResponse(message);
            }
            return serverErrorResponse();
        }
    };
}
function getPaginationMeta(page, limit, total) {
    return {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
    };
}
function getOffset(page, limit) {
    return (page - 1) * limit;
}
}),
"[project]/src/lib/services/statement-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateCsvFromResults",
    ()=>generateCsvFromResults,
    "generateStatementPdf",
    ()=>generateStatementPdf,
    "getAccountStatement",
    ()=>getAccountStatement,
    "searchTransactions",
    ()=>searchTransactions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$StandardFonts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/api/StandardFonts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/api/colors.js [app-route] (ecmascript)");
;
;
async function getAccountStatement(accountId, options) {
    const { from, to, page = 1, size = 50 } = options;
    const offset = (page - 1) * size;
    // Get account info
    const account = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT a.id, a.account_number, at.name as account_type_name,
                CONCAT(c.first_name, ' ', c.last_name) as customer_name
         FROM accounts a
         JOIN customers c ON a.customer_id = c.id
         JOIN account_types at ON at.id = a.account_type_id
         WHERE a.id = ?`, [
        accountId
    ]);
    if (!account) {
        throw new Error('Account not found');
    }
    // Calculate opening balance (sum of all entries before the period start)
    const openingBalanceRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT 
            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,
            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits
         FROM ledger_entries
         WHERE account_id = ? AND entry_date < ?`, [
        accountId,
        from
    ]);
    const openingBalance = parseFloat(openingBalanceRow?.total_credits || '0') - parseFloat(openingBalanceRow?.total_debits || '0');
    const countRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT COUNT(*) as count
         FROM ledger_entries le
         WHERE le.account_id = ? AND le.entry_date >= ? AND le.entry_date <= ?`, [
        accountId,
        from,
        to
    ]);
    const total = countRow?.count || 0;
    // Get period totals for closing balance calculation
    const periodTotals = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT 
            COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,
            COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits
         FROM ledger_entries
         WHERE account_id = ? AND entry_date >= ? AND entry_date <= ?`, [
        accountId,
        from,
        to
    ]);
    const totalCredits = parseFloat(periodTotals?.total_credits || '0');
    const totalDebits = parseFloat(periodTotals?.total_debits || '0');
    const closingBalance = openingBalance + totalCredits - totalDebits;
    // Get ledger entries for period (ordered by created_at ASC for running balance)
    const rows = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT le.id, le.transaction_id, le.account_id, le.entry_type, 
                le.amount, le.currency, le.balance_after, le.description,
                le.entry_date, le.created_at, t.transaction_reference,
                tt.code as transaction_type
         FROM ledger_entries le
         JOIN transactions t ON le.transaction_id = t.id
         JOIN transaction_types tt ON t.transaction_type_id = tt.id
         WHERE le.account_id = ? AND le.entry_date >= ? AND le.entry_date <= ?
         ORDER BY le.created_at ASC, le.id ASC
         LIMIT ? OFFSET ?`, [
        accountId,
        from,
        to,
        size,
        offset
    ]);
    // Compute running balance for paginated entries
    // For running balance, we need to know the balance at the start of this page
    let runningBalance = openingBalance;
    // If we're not on page 1, calculate the balance up to this page
    if (page > 1) {
        const previousTotals = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT 
                COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,
                COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits
             FROM (
                SELECT entry_type, amount
                FROM ledger_entries
                WHERE account_id = ? AND entry_date >= ? AND entry_date <= ?
                ORDER BY created_at ASC, id ASC
                LIMIT ?
             ) as previous_entries`, [
            accountId,
            from,
            to,
            offset
        ]);
        runningBalance = openingBalance + parseFloat(previousTotals?.total_credits || '0') - parseFloat(previousTotals?.total_debits || '0');
    }
    const entries = rows.map((row)=>{
        const amount = parseFloat(row.amount);
        if (row.entry_type === 'CREDIT') {
            runningBalance += amount;
        } else {
            runningBalance -= amount;
        }
        return {
            id: row.id,
            date: row.entry_date,
            description: row.description,
            debit: row.entry_type === 'DEBIT' ? amount : null,
            credit: row.entry_type === 'CREDIT' ? amount : null,
            runningBalance: Math.round(runningBalance * 100) / 100,
            transactionReference: row.transaction_reference,
            transactionType: row.transaction_type
        };
    });
    return {
        statement: {
            account: {
                id: account.id,
                accountNumber: account.account_number,
                accountType: account.account_type_name,
                customerName: account.customer_name
            },
            period: {
                from,
                to
            },
            openingBalance: Math.round(openingBalance * 100) / 100,
            closingBalance: Math.round(closingBalance * 100) / 100,
            totalDebits: Math.round(totalDebits * 100) / 100,
            totalCredits: Math.round(totalCredits * 100) / 100,
            entries
        },
        total
    };
}
// =============================================================================
// Helpers
// =============================================================================
function maskAccountNumber(accountNumber) {
    if (accountNumber.length <= 4) return accountNumber;
    return '****' + accountNumber.slice(-4);
}
function formatCurrency(amount) {
    return new Intl.NumberFormat('en-BD', {
        style: 'currency',
        currency: 'BDT',
        minimumFractionDigits: 2
    }).format(amount);
}
function formatDate(date) {
    return new Intl.DateTimeFormat('en-GB', {
        day: '2-digit',
        month: 'short',
        year: 'numeric'
    }).format(new Date(date));
}
async function generateStatementPdf(accountId, from, to// YYYY-MM-DD
) {
    // Get all entries for the date range
    const { statement } = await getAccountStatement(accountId, {
        from,
        to,
        page: 1,
        size: 10000
    });
    // Create a new PDFDocument
    const pdfDoc = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PDFDocument"].create();
    const font = await pdfDoc.embedFont(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$StandardFonts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StandardFonts"].Helvetica);
    const fontBold = await pdfDoc.embedFont(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$StandardFonts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StandardFonts"].HelveticaBold);
    let page = pdfDoc.addPage([
        595.28,
        841.89
    ]); // A4
    const { width, height } = page.getSize();
    const margin = 50;
    let y = height - margin;
    // Helper to add new page
    const addNewPage = ()=>{
        page = pdfDoc.addPage([
            595.28,
            841.89
        ]);
        y = height - margin;
        return page;
    };
    // Helper to draw text
    const drawText = (text, x, currentY, size = 10, f = font, color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0, 0, 0))=>{
        page.drawText(text, {
            x,
            y: currentY,
            size,
            font: f,
            color
        });
    };
    // Simple Black & White Design
    const primaryColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0, 0, 0);
    const secondaryColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0.3, 0.3, 0.3);
    // Header
    const title = 'BNKCORE';
    const titleWidth = fontBold.widthOfTextAtSize(title, 22);
    drawText(title, (width - titleWidth) / 2, y, 22, fontBold);
    y -= 25;
    const subtitle = 'Core Banking System';
    const subtitleWidth = font.widthOfTextAtSize(subtitle, 10);
    drawText(subtitle, (width - subtitleWidth) / 2, y, 10, font);
    y -= 35;
    const reportTitle = 'Account Statement';
    const reportTitleWidth = fontBold.widthOfTextAtSize(reportTitle, 16);
    drawText(reportTitle, (width - reportTitleWidth) / 2, y, 16, fontBold);
    y -= 45;
    // Account Information
    const infoY = y;
    drawText('Account Holder:', margin, y, 10, fontBold);
    drawText(statement.account.customerName, margin + 90, y, 10, font);
    y -= 18;
    drawText('Account Number:', margin, y, 10, fontBold);
    // Display full account number
    drawText(statement.account.accountNumber, margin + 90, y, 10, font);
    y -= 18;
    drawText('Account Type:', margin, y, 10, fontBold);
    drawText(statement.account.accountType, margin + 90, y, 10, font);
    drawText('Statement Period:', 320, infoY, 10, fontBold);
    drawText(`${formatDate(new Date(from))} - ${formatDate(new Date(to))}`, 410, infoY, 10, font);
    drawText('Generated:', 320, infoY - 18, 10, fontBold);
    drawText(formatDate(new Date()), 410, infoY - 18, 10, font);
    y -= 50;
    // Summary Box
    page.drawRectangle({
        x: margin,
        y: y - 55,
        width: width - 2 * margin,
        height: 65,
        borderColor: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0, 0, 0),
        borderWidth: 1
    });
    const summaryY1 = y - 20;
    const summaryY2 = y - 45;
    drawText('Opening Balance:', margin + 15, summaryY1, 10, fontBold);
    drawText(formatCurrency(statement.openingBalance), margin + 110, summaryY1, 10, fontBold);
    drawText('Total Credits:', margin + 260, summaryY1, 10, fontBold);
    drawText(formatCurrency(statement.totalCredits), margin + 350, summaryY1, 10, fontBold);
    drawText('Closing Balance:', margin + 15, summaryY2, 10, fontBold);
    drawText(formatCurrency(statement.closingBalance), margin + 110, summaryY2, 10, fontBold);
    drawText('Total Debits:', margin + 260, summaryY2, 10, fontBold);
    drawText(formatCurrency(statement.totalDebits), margin + 350, summaryY2, 10, fontBold);
    y -= 90;
    // Table Column Definitions
    const colDate = margin;
    const colDesc = margin + 75;
    const colDebit = margin + 250;
    const colCredit = margin + 330;
    const colBalance = margin + 415;
    const colWidths = {
        debit: 70,
        credit: 70,
        balance: 80
    };
    const drawTableHeader = (currentY)=>{
        page.drawRectangle({
            x: margin,
            y: currentY - 18,
            width: width - 2 * margin,
            height: 25,
            color: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0.9, 0.9, 0.9)
        });
        const headerTextY = currentY - 3;
        drawText('Date', colDate + 5, headerTextY, 9, fontBold);
        drawText('Description', colDesc, headerTextY, 9, fontBold);
        const drawRightText = (text, x, targetWidth, currentYInner, size = 9, f = fontBold)=>{
            const textWidth = f.widthOfTextAtSize(text, size);
            drawText(text, x + targetWidth - textWidth - 5, currentYInner, size, f);
        };
        drawRightText('Debit', colDebit, colWidths.debit, headerTextY);
        drawRightText('Credit', colCredit, colWidths.credit, headerTextY);
        drawRightText('Balance', colBalance, colWidths.balance, headerTextY);
    };
    drawTableHeader(y);
    y -= 30;
    const drawRowRightText = (text, x, targetWidth, currentY, size = 8, f = font)=>{
        const textWidth = f.widthOfTextAtSize(text, size);
        drawText(text, x + targetWidth - textWidth - 5, currentY, size, f);
    };
    // Opening Balance Row
    drawText(formatDate(new Date(from)), colDate + 5, y, 8, fontBold);
    drawText('Opening Balance', colDesc, y, 8, fontBold);
    drawRowRightText(formatCurrency(statement.openingBalance), colBalance, colWidths.balance, y, 8, fontBold);
    y -= 18;
    // Transaction rows
    for (const entry of statement.entries){
        if (y < margin + 60) {
            addNewPage();
            drawTableHeader(y);
            y -= 30;
        }
        const index = statement.entries.indexOf(entry);
        if (index % 2 === 1) {
            page.drawRectangle({
                x: margin,
                y: y - 5,
                width: width - 2 * margin,
                height: 18,
                color: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0.98, 0.98, 0.98)
            });
        }
        drawText(formatDate(entry.date), colDate + 5, y, 8, font, secondaryColor);
        const desc = entry.description || entry.transactionType;
        drawText(desc.length > 35 ? desc.substring(0, 32) + '...' : desc, colDesc, y, 8, font);
        if (entry.debit) {
            drawRowRightText(formatCurrency(entry.debit), colDebit, colWidths.debit, y, 8, font);
        }
        if (entry.credit) {
            drawRowRightText(formatCurrency(entry.credit), colCredit, colWidths.credit, y, 8, font);
        }
        drawRowRightText(formatCurrency(entry.runningBalance), colBalance, colWidths.balance, y, 8, font);
        y -= 18;
    }
    // Closing Balance Row
    if (y < margin + 40) {
        addNewPage();
        drawTableHeader(y);
        y -= 30;
    }
    y -= 5;
    drawText(formatDate(new Date(to)), colDate + 5, y, 8, fontBold);
    drawText('Closing Balance', colDesc, y, 8, fontBold);
    drawRowRightText(formatCurrency(statement.closingBalance), colBalance, colWidths.balance, y, 8, fontBold);
    // Footer
    const pages = pdfDoc.getPages();
    for(let i = 0; i < pages.length; i++){
        const p = pages[i];
        const footerText = `Page ${i + 1} of ${pages.length} | This is a computer-generated document and does not require signature.`;
        const footerWidth = font.widthOfTextAtSize(footerText, 8);
        p.drawText(footerText, {
            x: (width - footerWidth) / 2,
            y: 30,
            size: 8,
            font: font,
            color: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pdf$2d$lib$40$1$2e$17$2e$1$2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$colors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rgb"])(0, 0, 0)
        });
    }
    const pdfBytes = await pdfDoc.save();
    return Buffer.from(pdfBytes);
}
async function searchTransactions(filters) {
    const { from, to, amountMin, amountMax, entryType, transactionType, reference, accountId, includeReversals = true, page = 1, size = 50 } = filters;
    const offset = (page - 1) * size;
    const conditions = [
        '1=1'
    ];
    const params = [];
    if (from) {
        conditions.push('le.entry_date >= ?');
        params.push(from);
    }
    if (to) {
        conditions.push('le.entry_date <= ?');
        params.push(to);
    }
    if (amountMin !== undefined) {
        conditions.push('le.amount >= ?');
        params.push(amountMin);
    }
    if (amountMax !== undefined) {
        conditions.push('le.amount <= ?');
        params.push(amountMax);
    }
    if (entryType) {
        conditions.push('le.entry_type = ?');
        params.push(entryType);
    }
    if (transactionType) {
        conditions.push('tt.code = ?');
        params.push(transactionType);
    }
    if (reference) {
        conditions.push('(t.transaction_reference LIKE ? OR le.description LIKE ?)');
        params.push(`%${reference}%`, `%${reference}%`);
    }
    if (accountId) {
        conditions.push('le.account_id = ?');
        params.push(accountId);
    }
    if (!includeReversals) {
        conditions.push("t.status != 'REVERSED'");
    }
    const whereClause = conditions.join(' AND ');
    const countRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT COUNT(*) as count
         FROM ledger_entries le
         JOIN transactions t ON le.transaction_id = t.id
         JOIN transaction_types tt ON t.transaction_type_id = tt.id
         JOIN accounts a ON le.account_id = a.id
         WHERE ${whereClause}`, params);
    // Get results
    const rows = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT le.id, t.transaction_reference, tt.code as transaction_type,
                le.account_id, a.account_number, le.entry_type, le.amount,
                le.balance_after, le.description, le.entry_date, le.created_at,
                (t.status = 'REVERSED') as is_reversal
         FROM ledger_entries le
         JOIN transactions t ON le.transaction_id = t.id
         JOIN transaction_types tt ON t.transaction_type_id = tt.id
         JOIN accounts a ON le.account_id = a.id
         WHERE ${whereClause}
         ORDER BY le.created_at DESC, le.id DESC
         LIMIT ? OFFSET ?`, [
        ...params,
        size,
        offset
    ]);
    const results = rows.map((row)=>({
            id: row.id,
            transactionReference: row.transaction_reference,
            transactionType: row.transaction_type,
            accountId: row.account_id,
            accountNumber: row.account_number,
            entryType: row.entry_type,
            amount: parseFloat(row.amount),
            balanceAfter: parseFloat(row.balance_after),
            description: row.description,
            entryDate: row.entry_date,
            createdAt: row.created_at,
            isReversal: Boolean(row.is_reversal)
        }));
    return {
        results,
        total: countRow?.count || 0
    };
}
function generateCsvFromResults(results) {
    const headers = [
        'ID',
        'Date',
        'Transaction Ref',
        'Type',
        'Account Number',
        'Entry Type',
        'Amount',
        'Balance After',
        'Description',
        'Is Reversal'
    ];
    const rows = results.map((r)=>[
            r.id,
            formatDate(r.entryDate),
            r.transactionReference,
            r.transactionType,
            r.accountNumber,
            r.entryType,
            r.amount.toFixed(2),
            r.balanceAfter.toFixed(2),
            `"${(r.description || '').replace(/"/g, '""')}"`,
            r.isReversal ? 'Yes' : 'No'
        ]);
    return [
        headers.join(','),
        ...rows.map((r)=>r.join(','))
    ].join('\n');
}
}),
"[project]/src/lib/services/account-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyForAccount",
    ()=>applyForAccount,
    "closeAccount",
    ()=>closeAccount,
    "createAccount",
    ()=>createAccount,
    "freezeAccount",
    ()=>freezeAccount,
    "getAccountById",
    ()=>getAccountById,
    "getAccountByNumber",
    ()=>getAccountByNumber,
    "getAccountsForCustomer",
    ()=>getAccountsForCustomer,
    "getPendingApplications",
    ()=>getPendingApplications,
    "onboardNewCustomer",
    ()=>onboardNewCustomer,
    "refreshAccountBalance",
    ()=>refreshAccountBalance,
    "unfreezeAccount",
    ()=>unfreezeAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.ts [app-route] (ecmascript)");
;
async function getAccountById(accountId) {
    const account = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT a.id, a.account_number, a.customer_id, a.account_type_id,
                at.code as account_type, at.name as account_type_name,
                a.status, a.created_at,
                COALESCE(ab.currency, 'BDT') as currency
         FROM accounts a
         JOIN account_types at ON at.id = a.account_type_id
         LEFT JOIN account_balances ab ON ab.account_id = a.id
         WHERE a.id = ?`, [
        accountId
    ]);
    if (!account) return null;
    return {
        id: account.id,
        accountNumber: account.account_number,
        customerId: account.customer_id,
        accountType: account.account_type,
        currency: account.currency,
        status: account.status,
        openedAt: account.created_at,
        createdAt: account.created_at
    };
}
async function getAccountByNumber(accountNumber) {
    const account = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])(`SELECT a.id, a.account_number, a.customer_id, a.account_type_id,
                at.code as account_type, at.name as account_type_name,
                a.status, a.created_at,
                COALESCE(ab.currency, 'BDT') as currency
         FROM accounts a
         JOIN account_types at ON at.id = a.account_type_id
         LEFT JOIN account_balances ab ON ab.account_id = a.id
         WHERE a.account_number = ?`, [
        accountNumber
    ]);
    if (!account) return null;
    return {
        id: account.id,
        accountNumber: account.account_number,
        customerId: account.customer_id,
        accountType: account.account_type,
        currency: account.currency,
        status: account.status,
        openedAt: account.created_at,
        createdAt: account.created_at
    };
}
async function getAccountsForCustomer(customerId) {
    const rows = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT a.id, a.account_number, a.customer_id, a.account_type_id,
                at.code as account_type, at.name as account_type_name,
                a.status, a.created_at,
                c.first_name, c.last_name,
                COALESCE(ab.available_balance, 0) as available_balance,
                COALESCE(ab.currency, 'BDT') as currency
         FROM accounts a
         JOIN customers c ON c.id = a.customer_id
         JOIN account_types at ON at.id = a.account_type_id
         LEFT JOIN account_balances ab ON ab.account_id = a.id
         WHERE a.customer_id = ?
         ORDER BY a.created_at DESC`, [
        customerId
    ]);
    return rows.map((row)=>({
            id: row.id,
            accountNumber: row.account_number,
            customerId: row.customer_id,
            accountType: row.account_type,
            accountTypeName: row.account_type_name,
            currency: row.currency,
            status: row.status,
            openedAt: row.created_at,
            createdAt: row.created_at,
            customerName: `${row.first_name} ${row.last_name}`,
            balance: {
                availableBalance: parseFloat(row.available_balance || '0')
            }
        }));
}
async function freezeAccount(accountId, bankerId, reason) {
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('UPDATE accounts SET status = "SUSPENDED", updated_at = NOW() WHERE id = ?', [
            accountId
        ]);
        return {
            success: true
        };
    } catch (error) {
        console.error('Error freezing account:', error);
        return {
            success: false,
            error: 'Failed'
        };
    }
}
async function unfreezeAccount(accountId, bankerId, reason) {
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('UPDATE accounts SET status = "ACTIVE", updated_at = NOW() WHERE id = ?', [
            accountId
        ]);
        return {
            success: true
        };
    } catch (error) {
        console.error('Error unfreezing account:', error);
        return {
            success: false,
            error: 'Failed'
        };
    }
}
async function closeAccount(accountId, bankerId, reason) {
    try {
        // 1. Check Balance (Must be 0)
        const balanceRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])('SELECT available_balance FROM account_balances WHERE account_id = ?', [
            accountId
        ]);
        const balance = parseFloat(balanceRow?.available_balance || '0');
        if (balance !== 0) {
            return {
                success: false,
                error: `Cannot close account. Non-zero balance: ${balance}`
            };
        }
        // 2. Update Account Status
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('UPDATE accounts SET status = "CLOSED", updated_at = NOW() WHERE id = ?', [
            accountId
        ]);
        return {
            success: true
        };
    } catch (error) {
        console.error('Error closing account:', error);
        return {
            success: false,
            error: 'Failed'
        };
    }
}
async function createAccount(customerId, accountTypeId, createdBy) {
    try {
        // 1. Verify Customer exists
        const customer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])('SELECT id FROM customers WHERE id = ?', [
            customerId
        ]);
        if (!customer) {
            return {
                success: false,
                error: 'Customer not found'
            };
        }
        // 2. Generate Account Number (matches existing 1001-XXXX-XXXX format)
        const segment1 = '1001';
        const segment2 = String(customerId).padStart(4, '0');
        const segment3 = String(Math.floor(1000 + Math.random() * 9000));
        const accountNumber = `${segment1}-${segment2}-${segment3}`;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withTransaction"])(async (conn)=>{
            // 3. Insert Account record
            const [accountResult] = await conn.execute(`INSERT INTO accounts (account_number, customer_id, account_type_id, status, opened_at, created_at, created_by)
                 VALUES (?, ?, ?, 'ACTIVE', NOW(), NOW(), ?)`, [
                accountNumber,
                customerId,
                accountTypeId,
                createdBy || null
            ]);
            const accountId = accountResult.insertId;
            // 4. Initialize Balance record
            await conn.execute(`INSERT INTO account_balances (account_id, available_balance, currency, version)
                 VALUES (?, 0.0000, 'BDT', 1)`, [
                accountId
            ]);
            return {
                success: true,
                accountId,
                accountNumber
            };
        });
    } catch (error) {
        console.error('Error creating account:', error);
        return {
            success: false,
            error: 'Database error during account creation'
        };
    }
}
async function applyForAccount(customerId, accountTypeCode) {
    // Lookup Account Type ID
    const typeRow = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryOne"])('SELECT id FROM account_types WHERE code = ?', [
        accountTypeCode
    ]);
    if (!typeRow) {
        return {
            success: false,
            error: 'Invalid account type'
        };
    }
    const result = await createAccount(customerId, typeRow.id);
    if (result.success) {
        return {
            success: true,
            applicationId: result.accountId
        };
    }
    return {
        success: false,
        error: result.error
    };
}
async function getPendingApplications() {
    // No longer applicable, returning empty array
    return [];
}
async function onboardNewCustomer(data) {
    try {
        // Generate a temporary password (they should change it later)
        const tempPassword = 'Welcome!' + Math.floor(1000 + Math.random() * 9000);
        const { hashPassword } = await __turbopack_context__.A("[project]/src/lib/services/auth-service.ts [app-route] (ecmascript, async loader)");
        const passwordHash = await hashPassword(tempPassword);
        // Create Customer (no automatic account)
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execute"])(`INSERT INTO customers 
             (customer_number, email, first_name, last_name, date_of_birth, status, kyc_status, created_at, created_by, password_hash)
             VALUES (?, ?, ?, ?, ?, 'ACTIVE', 'VERIFIED', NOW(), ?, ?)`, [
            data.customerNumber,
            data.email,
            data.firstName,
            data.lastName,
            data.dateOfBirth,
            data.createdBy,
            passwordHash
        ]);
        return {
            success: true,
            customerId: result.insertId,
            tempPassword
        };
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            return {
                success: false,
                error: 'Email or Customer Number already exists'
            };
        }
        console.error('Error during customer creation:', error);
        return {
            success: false,
            error: 'Database error during customer creation'
        };
    }
}
async function refreshAccountBalance(accountId) {
    // Placeholder - in real system would trigger reconciliation
    return;
}
}),
"[project]/src/app/api/v1/accounts/[id]/statement/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/api-utils.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$statement$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/services/statement-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$account$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/services/account-service.ts [app-route] (ecmascript)");
;
;
;
const GET = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withErrorHandler"])(async (request, context)=>{
    const params = await context?.params;
    const accountId = parseInt(params?.id || '0');
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withAuth"])(request, async (req)=>{
        // Validate account exists
        const account = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$account$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAccountById"])(accountId);
        if (!account) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["notFoundResponse"])('Account not found');
        }
        // Customers can only view their own accounts
        if (req.tokenPayload?.type === 'customer') {
            if (account.customerId !== req.customer?.id) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["notFoundResponse"])('Account not found');
            }
        }
        // Get query parameters
        const { searchParams } = new URL(request.url);
        const from = searchParams.get('from');
        const to = searchParams.get('to');
        const page = parseInt(searchParams.get('page') || '1');
        const size = parseInt(searchParams.get('size') || '50');
        // Validate required parameters
        if (!from || !to) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorResponse"])('Missing required parameters: from and to dates are required');
        }
        // Validate date format
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        if (!dateRegex.test(from) || !dateRegex.test(to)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorResponse"])('Invalid date format. Use YYYY-MM-DD');
        }
        // Validate date range
        if (new Date(from) > new Date(to)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorResponse"])('Invalid date range: from date must be before to date');
        }
        try {
            const { statement, total } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$services$2f$statement$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAccountStatement"])(accountId, {
                from,
                to,
                page,
                size
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["successResponse"])(statement, (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPaginationMeta"])(page, size, total));
        } catch (error) {
            console.error('Statement generation error:', error);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorResponse"])('Failed to generate statement');
        }
    }, {
        requiredType: 'any'
    });
});
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__f2ec915c._.js.map